<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 未分类 | 破船之家]]></title>
  <link href="http://BeyondVincent.github.io/blog/categories/wei-fen-lei/atom.xml" rel="self"/>
  <link href="http://BeyondVincent.github.io/"/>
  <updated>2014-02-21T15:11:01+08:00</updated>
  <id>http://BeyondVincent.github.io/</id>
  <author>
    <name><![CDATA[破船(BeyondVincent)]]></name>
    <email><![CDATA[beyondvincent@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我的初马不是马]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/05/11/21/"/>
    <updated>2013-05-11T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/05/11/21</id>
    <content type="html"><![CDATA[<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/2012-11-25-%E5%8C%97%E4%BA%AC%E9%A9%AC%E6%8B%89%E6%9D%BE.png"><img class="alignnone size-full wp-image-585" alt="2012-11-25-北京马拉松" src="http://beyondvincent.com/wp-content/uploads/2013/05/2012-11-25-北京马拉松.png" width="976" height="313" /></a></p>

<p>在即将到来的昆明半程马拉松之际（2013年5月25日举行），为我的初马画一个句号，交一份迟到的作业。</p>

<p>2012年11月25日，完成了我人生中的第一个马拉松（北京马拉松），为了这个马拉松，我准备了好久好久，也期盼了好久好久。虽说这一次的马拉松受到一点外界因素的干扰，不过终究是在延误一个月的情况下举行了，就是天气已经转冷，对于初跑马拉松的我，是一个不小的挑战。最终用时5小时35分06秒。</p>

<p>下面是我初马赛前、赛中和赛后的一些感受：</p>

<p>人生就像一场马拉松，没有充分的准备，终会完败！<br/>
人生就像一场马拉松，背负的太多，就难以完美收场！<br/>
人生就像一场马拉松，结局不重要，重要的是过程的享受！<br/>
人生就像一场马拉松，可以考验人挑战自我，超越极限，坚韧不拔，永不放弃的精神！</p>

<p>&nbsp;</p>

<p>马拉松路线地图：</p>

<p>起点：天安门前长安街出发<br/>
终点：鸟巢水立方</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/1.jpg"><img class="alignnone size-full wp-image-574" alt="1" src="http://beyondvincent.com/wp-content/uploads/2013/05/1.jpg" width="781" height="1024" /></a></p>

<p>&nbsp;</p>

<p>参赛物品：号码簿、计时芯片、雨衣、T恤等。</p>

<p>B1038——我的吉利数字</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/2.jpg"><img class="alignnone size-full wp-image-575" alt="2" src="http://beyondvincent.com/wp-content/uploads/2013/05/2.jpg" width="1024" height="768" /></a></p>

<p>&nbsp;</p>

<p>出发前，在等待起跑，天气比较糟糕哟，其实不利于跑步的。</p>

<p>&nbsp;</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/3.jpg"><img class="alignnone size-full wp-image-576" alt="3" src="http://beyondvincent.com/wp-content/uploads/2013/05/3.jpg" width="1024" height="768" /></a></p>

<p>&nbsp;</p>

<p>开跑，大家都非常期待哟，我也是哈</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/4.jpg"><img class="alignnone size-full wp-image-577" alt="4" src="http://beyondvincent.com/wp-content/uploads/2013/05/4.jpg" width="1024" height="768" /></a></p>

<p>&nbsp;</p>

<p>好多人，要路过天安门，接受毛主席的检阅</p>

<p>&nbsp;</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/5.jpg"><img class="alignnone size-full wp-image-578" alt="5" src="http://beyondvincent.com/wp-content/uploads/2013/05/5.jpg" width="1024" height="768" /></a></p>

<p>&nbsp;</p>

<p>大家都跑得很欢畅，就是天气是在太不给力了，空气差，还冷，不过有得跑，就不错了哟</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/6.jpg"><img class="alignnone size-full wp-image-579" alt="6" src="http://beyondvincent.com/wp-content/uploads/2013/05/6.jpg" width="1024" height="768" /></a></p>

<p>时间定格的一刹那</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/7.png"><img class="alignnone size-full wp-image-580" alt="7" src="http://beyondvincent.com/wp-content/uploads/2013/05/7.png" width="1024" height="462" /></a></p>

<p>拿着奖牌合影是少不了的事</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/8.jpg"><img class="alignnone size-full wp-image-581" alt="8" src="http://beyondvincent.com/wp-content/uploads/2013/05/8.jpg" width="1024" height="768" /></a></p>

<p>再来一张，这火红火红的，嘎嘎</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/9.png"><img class="alignnone size-full wp-image-582" alt="9" src="http://beyondvincent.com/wp-content/uploads/2013/05/9.png" width="822" height="614" /></a></p>

<p>奖牌特写</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/10.jpg"><img class="alignnone size-full wp-image-583" alt="10" src="http://beyondvincent.com/wp-content/uploads/2013/05/10.jpg" width="391" height="1024" /></a></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>获奖证书哟</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/11.png"><img class="alignnone size-full wp-image-584" alt="11" src="http://beyondvincent.com/wp-content/uploads/2013/05/11.png" width="788" height="558" /></a></p>

<p>下一个参加的马拉松已经确定：昆明半程国际马拉松：2013年5月25日。</p>

<p>万分期待哟哟哟</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS设计模式(01):观察者]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/05/05/18/"/>
    <updated>2013-05-05T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/05/05/18</id>
    <content type="html"><![CDATA[<h2><a href="http://beyondvincent.com/wp-content/uploads/2013/05/iOS-Observer-Pattern.png"><img class="alignnone size-full wp-image-517" title="点击查看大图" alt="iOS-Observer-Pattern" src="http://beyondvincent.com/wp-content/uploads/2013/05/iOS-Observer-Pattern.png" width="976" height="313" /></a></h2>

<h2><strong><span style="color: #339966;">什么是观察者模式</span></strong></h2>

<p>什么是<strong>观察者模式</strong>？你曾经订阅过报纸吗？在订阅报纸的时候，你不用去任何地方，只需要将你的个人地址信息以及订阅信息告诉出版社，出版社就知道如何将相关报纸传递给你。这种模式的第二个名称叫做<strong><span style="color: #339966;">发布/订阅模式</span></strong>。</p>

<p>在GoF中是这样描述观察者模式的——观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>

<p><span>观察者模式的的思想非常简单，Subject（主题）允许别的对象——观察者（这些对象实现了观察者接口）对这个Subject的改变进行订阅和取消订阅。当Subject发生了变化——那么Subject会将这个变化发送给所有的观察者，观察者就能对Subject的变化做出更新。在这里，Subject是报纸的出版社，而观察者则是订阅报纸的我和你，当Subject发生变化——有新的报纸，会做出通知——将报纸发送给所有的订阅者。</span></p>

<h2><strong><span style="color: #339966;">什么时候使用观察者模式？</span></strong></h2>

<ol>
<li><span style="line-height: 13px;">当你需要将改变通知所有的对象时，而你又不知道这些对象的具体类型，此时就可以使用观察者模式。</span></li>
<li>改变发生在同一个对象中，并在别的地方需要将相关的状态进行更新。</li>
</ol>


<h2><strong><span style="color: #339966;">iOS中观察者模式的实现方法</span></strong></h2>

<p>在iOS中观察者模式的实现有三种方法：</p>

<ol>
<li><h3><span style="color: #339966;">Notification</span></h3></li>
</ol>


<p>Notification - NotificationCenter机制使用了操作系统的功能。通过NSNotificationCenter可以让对象之间进行进行通讯，这些对象相互间可以不认识。当你用一个并行的流来推送通知，或者刷新数据库，并希望在界面中能够看到时，这非常有用。</p>

<p>NotificationCenter发布消息的方法如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">NSNotification  * broadcastMessage = [ NSNotification  notificationWithName: AnyNotification  object: Self ];
NSNotificationCenter  * notificationCenter = [ NSNotificationCenter  defaultCenter];
[NotificationCenter postNotification: broadCastMessage];</pre>


<p>上面的代码中，创建了一个NSNotification类型的对象，并指定名称为&#8221;broadcastMessage&#8221;，然后通过notificationCenter来发布这个消息。</p>

<p>要订阅感兴趣的对象中的相关事件，可以按照如下方法进行：</p>

<pre class="wp-code-highlight prettyprint linenums:1">NSNotificationCenter  * notificationCenter = [ NSNotificationCenter  defaultCenter];
[NotificationCenter addObserver: Self  selector: @ selector (update:) name: AnyNotification  object: nil ];</pre>


<p>如上代码所示：订阅了一个事件，并通过@selector指定了一个方法。</p>

<pre class="wp-code-highlight prettyprint linenums:1">// 收到通知中心发来的通知
-(void)update:(NSNotification *) notification
{
    if ([[notification name] isEqualToString:AnyNotification])
        NSLog (@"成功收到通知中心发来的名为%@的通知", AnyNotification);
}</pre>


<p>下面是运行上面代码，在控制台输出的内容：</p>

<pre class="wp-code-highlight prettyprint linenums:1">2013-05-05 23:43:15.570 ObserverPattern[1738:c07] 成功收到通知中心发来的名为broadcastMessage的通知</pre>




<ol start="2">
  <li>
    <h3>
      <span style="line-height: 13px; color: #339966;"> KVO</span>
    </h3>
  </li>
</ol>


<p>通过KVO，某个对象中的特定属性发生了改变，别的对象可以获得通知。苹果官方文档对KVO有了很好的解释：<span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank"><span style="color: #339966; text-decoration: underline;">Key-Value Observing Programming Guide</span></a></span></span>。下面两种方法都可以改变对象中属性的值：</p>

<pre class="wp-code-highlight prettyprint linenums:1">kvoSubj.changeableProperty = @"新的一个值";

[kvoSubj setValue:@"新的一个值" forKey:@"changeableProperty"];</pre>


<p>上面这种值改变的灵活性可以让我们对键值进行观察。</p>

<p>下面是新建的一个类KVOSubject，这个类中有一个属性changeableProperty：</p>

<pre class="wp-code-highlight prettyprint linenums:1">@interface KVOSubject : NSObject

@property (nonatomic, strong) NSString *changeableProperty;

@end

@implementation KVOSubject

@end</pre>


<p>接着新建了另外一个类KVOObserver，通过该类可以监听changeableProperty属性值的改变。</p>

<pre class="wp-code-highlight prettyprint linenums:1">@interface KVOObserver : NSObject
@end

@implementation KVOObserver

-(void) observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
    NSLog(@"KVO:值发生了改变");
}

@end</pre>


<p>如上代码所示，KVOObserver类只有一个方法observeValueForKeyPath。当changeableProperty属性值的改变时，这个方法会被调用。下面是测试的代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (IBAction)btnKVOObservationTest:(id)sender {
    KVOSubject *kvoSubj = [[KVOSubject alloc] init];
    KVOObserver *kvoObserver = [[KVOObserver alloc] init];

    [kvoSubj addObserver:kvoObserver forKeyPath:@"changeableProperty"
                 options:NSKeyValueObservingOptionNew context:nil];

    kvoSubj.changeableProperty = @"新的一个值";

    [kvoSubj setValue:@"新的一个值" forKey:@"changeableProperty"];

    [kvoSubj removeObserver:kvoObserver forKeyPath:@"changeableProperty"];
}</pre>


<p>执行上面的代码，可以看到控制台输出如下结果：</p>

<pre class="wp-code-highlight prettyprint linenums:1">2013-05-05 23:10:20.789 ObserverPattern[1358:c07] KVO:值发生了改变
2013-05-05 23:10:20.790 ObserverPattern[1358:c07] KVO:值发生了改变</pre>




<ol start="3">
  <li>
    <h3>
      <span style="color: #339966;">标准方法</span>
    </h3>
  </li>
</ol>


<p>先来看看Gof中对观察者模式定义的结构图：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/Observer-Structure.jpg"><img class="alignnone size-full wp-image-512" alt="Observer-Structure" src="http://beyondvincent.com/wp-content/uploads/2013/05/Observer-Structure.jpg" width="615" height="243" /></a></p>

<p>标准方法的实现是这样的：Subject（主题）知道所有的观察者，但是不知道它们的类型。下面我们就从创建Subject和Observer（观察者）的协议（protocol）开始。</p>

<pre class="wp-code-highlight prettyprint linenums:1">@protocol StandardObserver 
-(void) valueChanged:(NSString *)valueName newValue:(NSString *) newValue;
@end

@protocol StandardSubject 
-(void) addObserver:(id) observer;
-(void) removeObserver:(id) observer;
-(void) notifyObjects;
@end</pre>


<p>下面，我们来创建一个Subject的implementation （实现）</p>

<pre class="wp-code-highlight prettyprint linenums:1">@interface StandardSubjectImplementation : NSObject 
{
    @private NSString *_valueName;
    @private NSString *_newValue;
}
@property (nonatomic, strong) NSMutableSet *observerCollection;
-(void)changeValue:(NSString *)valueName andValue:(NSString *) newValue;
@end

@implementation StandardSubjectImplementation

-(NSMutableSet *) observerCollection
{
    if (_observerCollection == nil)
        _observerCollection = [[NSMutableSet alloc] init];

    return _observerCollection;
}

-(void) addObserver:(id)observer
{
    [self.observerCollection addObject:observer];
}

-(void) removeObserver:(id)observer
{
    [self.observerCollection removeObject:observer];
}

-(void) notifyObjects
{
    for (id observer in self.observerCollection) {
        [observer valueChanged: _valueName newValue:_newValue];
    }
}

-(void)changeValue:(NSString *)valueName andValue:(NSString *) newValue
{
    _newValue = newValue;
    _valueName = valueName;
    [self notifyObjects];
}
@end</pre>


<p>接下来是Observer的implementation （实现）：</p>

<pre class="wp-code-highlight prettyprint linenums:1">@interface SomeSubscriber : NSObject 
@end

@implementation SomeSubscriber
-(void) valueChanged:(NSString *)valueName newValue:(NSString *)newValue
{
    NSLog(@"SomeSubscriber输出: 值 %@ 已变为 %@", valueName, newValue);
}
@end

@interface OtherSubscriber : NSObject 

@end

@implementation OtherSubscriber

-(void) valueChanged:(NSString *)valueName newValue:(NSString *)newValue
{
    NSLog(@"OtherSubscriber输出: 值 %@ 已变为 %@", valueName, newValue);
}
@end</pre>


<p>下面是演示的代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">StandardSubjectImplementation * subj = [[StandardSubjectImplementation alloc] init];
SomeSubscriber * someSubscriber = [[SomeSubscriber alloc] init];
OtherSubscriber * otherSubscriber = [[OtherSubscriber alloc] init];

[Subj addObserver: someSubscriber];
[Subj addObserver: otherSubscriber];

[subj changeValue:@"version" andValue:@"1.0.0"];</pre>


<p>上面代码运行的log如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">2013-05-05 23:19:04.662 ObserverPattern[1459:c07] OtherSubscriber输出: 值 version 已变为 1.0.0
2013-05-05 23:19:04.664 ObserverPattern[1459:c07] SomeSubscriber输出: 值 version 已变为 1.0.0</pre>


<h2><span style="color: #339966;"><strong>代码实例</strong></span></h2>

<p>本文涉及到的相关实例代码和PDF归档可以到点击下图下载：</p>

<p><a href="https://github.com/BeyondVincent/ios_patterns/tree/master/ObserverPattern" target="_blank"><img alt="代码下载" src="http://beyondvincent.com/wp-content/uploads/2013/05/5555.png" width="150" height="150" /></a>            <a href="https://github.com/BeyondVincent/ios_patterns/raw/master/ObserverPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20For%20iOS-01-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.pdf" target="_blank"><img alt="pdf-icon" src="http://beyondvincent.com/wp-content/uploads/2013/05/pdf-icon.png" width="150" height="150" /></a></p>

<p>&nbsp;</p>

<p>美文推荐：<span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://blog.shinetech.com/2011/06/14/delegation-notification-and-observation/" target="_blank"><span style="color: #339966; text-decoration: underline;">When to use Delegation, Notification, or Observation in iOS</span></a></span></span></p>

<p>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_____</p>

<p>本文由破船原创<br/>
转载请注明出处：<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://www.beyondvincent.com/" target="_blank"><span style="color: #339966; text-decoration: underline;">BeyondVincent的博客</span></a></strong></span></span><br/>
_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_____</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何利用GCD Group批量下载文件]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/05/02/17/"/>
    <updated>2013-05-02T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/05/02/17</id>
    <content type="html"><![CDATA[<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/%E6%9C%AA%E5%91%BD%E5%90%8D.png"><img class="alignnone size-full wp-image-499" alt="未命名" src="http://beyondvincent.com/wp-content/uploads/2013/05/未命名.png" width="976" height="313" /></a></p>

<p>小引：有时候，我们在开发iOS程序时，需要批量下载一些文件（比如图片），只有当全部文件下载完毕，我们才做相应的处理（界面更新，通知用户等）——也就是说虽然有多个文件在下载，但是我们只需要收到一个全部下载完毕的通知。</p>

<p>在网上搜索了一番，感觉使用GCD的高级功能Group，比较方便。下面写了一个小Demo，实现了多个图片文件的异步并发下载，缓存到本地，并显示到界面中。</p>

<p>参考了唐巧的一篇博文：<span style="text-decoration: underline; color: #339966;"><span style="text-decoration: underline;"><a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/" target="_blank"><span style="color: #339966; text-decoration: underline;">使用GCD</span></a></span></span>。</p>

<p>另外感兴趣的同学可以看看下面几篇GCD相关文章，非常不错：</p>

<p>raywenderlich：<span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.raywenderlich.com/4295/multithreading-and-grand-central-dispatch-on-ios-for-beginners-tutorial" target="_blank"><span style="color: #339966; text-decoration: underline;">Multithreading and Grand Central Dispatch on iOS for Beginners Tutorial</span></a></span></span></p>

<p>苹果官网：<span style="text-decoration: underline; color: #339966;"><span style="text-decoration: underline;"><a href="http://developer.apple.com/library/ios/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html" target="_blank"><span style="color: #339966; text-decoration: underline;">Grand Central Dispatch (GCD) Reference</span></a></span></span><span style="color: #339966;"><span style="color: #339966;"> </span></span>和<span style="color: #339966;"> </span><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank"><span style="color: #339966; text-decoration: underline;">Concurrency Programming Guide</span></a></span></span></p>

<p>Demo可以到Github上下载：</p>

<p><span style="text-decoration: underline; color: #339966;"><span style="text-decoration: underline;"><a href="https://github.com/BeyondVincent/DownloadImage_GCD" target="_blank"><span style="color: #339966; text-decoration: underline;"> <a href="https://github.com/BeyondVincent/DownloadImage_GCD">https://github.com/BeyondVincent/DownloadImage_GCD</a></span></a></span></span></p>

<p>下面是使用GCD Group的关键代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (IBAction)downloadAction:(UIButton *)sender
{
    [self resetImage];
    self.status.text = @"正在下载";
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_t downloadImage = dispatch_group_create();

    for (ImageInfo *info in self.imageList) {
        NSString* imagePath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingPathComponent:info.imageName];

        NSFileManager *fileManager = [NSFileManager defaultManager];
        // 如果本地不存在图片，则从网络中下载
        if (![fileManager fileExistsAtPath:imagePath]) {
            dispatch_group_async(downloadImage, queue, ^{
                NSLog(@"Starting image download:%@", imagePath);
                // URL组装和编码
                NSString *urlString = [NSString stringWithFormat:@"%@/%@", self.baseUrl, info.imageName];
                NSURL *url = [NSURL URLWithString:[urlString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];
                NSLog(@"image download from url:%@", urlString);

                // 开始下载图片
                NSData *responseData = [NSData dataWithContentsOfURL:url];
                // 将图片保存到指定路径中
                [responseData writeToFile:imagePath atomically:YES];
                // 将下载的图片赋值给info
                info.image = [UIImage imageWithData:responseData];
                NSLog(@"image download finish:%@", imagePath);
            });
        } else { // 将本地图片加载到systemInfo.MyImage
            info.image = [UIImage imageWithData:[NSData dataWithContentsOfFile:imagePath]];
        }
    }
    dispatch_group_notify(downloadImage, dispatch_get_main_queue(), ^{
        // 图片加载完毕之后，显示出来
        self.status.text = @"图片文件下载并缓存完毕";
        [self showImage];
    });
}
</pre>


<p>上面关键的代码是dispatch_group_async（并行执行线程1）和dispatch_group_notify（全部下载完毕，由此进行回调通知）。在for语句中循环开启了6个并发任务。当6个任务完成之后，调用showImage方法，将图片显示出来。<br/>
下面是运行效果图（第一个图为程序刚刚启动时的效果，第二个为点击开始异步下载图片按钮之后的效果）：<br/>
<a href="http://beyondvincent.com/wp-content/uploads/2013/05/QQ20130502-3.png"><img class="alignnone size-full wp-image-501" alt="QQ20130502-3" src="http://beyondvincent.com/wp-content/uploads/2013/05/QQ20130502-3.png" width="618" height="448" /><br/>
</a><br/>
<a href="http://beyondvincent.com/wp-content/uploads/2013/05/QQ20130502-2.png"><img alt="QQ20130502-2" src="http://beyondvincent.com/wp-content/uploads/2013/05/QQ20130502-2.png" width="621" height="427" /></a><br/>
&nbsp;</p>

<p>在写本Demo的时候，遇到了以下两个问题</p>

<ol>
<li>关于图片的加载，UIImage中的imageNamed:方法只能加载程序main bundle中的图片。要想加载Document中的图片，需要使用UIImage的imageWithData方法。更多相关资料可以阅读苹果官方介绍：<span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIImage_Class/Reference/Reference.html" target="_blank"><span style="color: #339966;">UIImage</span></a></span></span></li>
<li>NSURL URLWithString:myString returns Nil。在初始化NSURL实例对象是，一直都返回Nil。后来在这里（<span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://stackoverflow.com/questions/5839877/nsurl-urlwithstringmystring-returns-nil" target="_blank"><span style="color: #339966;">Here</span></a></span></span>）发现原来是URL中含有特殊字符，需要进行编码处理，照着链接中的方法搞定。</li>
</ol>


<p>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_____</p>

<p>本文由破船原创<br/>
转载请注明出处：<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://www.beyondvincent.com/" target="_blank"><span style="color: #339966; text-decoration: underline;">BeyondVincent的博客</span></a></strong></span></span><br/>
_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_____</p>
]]></content>
  </entry>
  
</feed>
