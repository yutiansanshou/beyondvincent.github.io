<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS探索 | 破船之家]]></title>
  <link href="http://BeyondVincent.github.io/blog/categories/iostan-suo/atom.xml" rel="self"/>
  <link href="http://BeyondVincent.github.io/"/>
  <updated>2014-03-24T00:11:12+08:00</updated>
  <id>http://BeyondVincent.github.io/</id>
  <author>
    <name><![CDATA[破船(BeyondVincent)]]></name>
    <email><![CDATA[beyondvincent@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[减小iOS应用程序的大小]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/03/24/reducing-the-size-of-my-app/"/>
    <updated>2014-03-24T00:20:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/03/24/reducing-the-size-of-my-app</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/03/22.png" alt="" /></p>

<!--more-->


<p>本文译自：<a href="https://developer.apple.com/library/ios/qa/qa1795/_index.html#//apple_ref/doc/uid/DTS40014195">Reducing the size of my App</a></p>

<p>Q: 怎样才能让我的程序安装包小一点，让程序的下载和安装更快速？</p>

<p>A: 本文收集了一些减小程序安装包大小的相关技巧(当第一次下载和安装程序时)。如果是针对升级程序的话，可以看这篇文章(<a href="https://developer.apple.com/library/ios/qa/qa1779/">减小iOS应用程序升级时所需下载的大小</a>)(这与第一次安装使用的工作原理有所不同)。</p>

<h2>检查应用程序</h2>

<p>首先是检查<code>.app bundle</code>，看一下程序包里面哪些文件占的空间最大。</p>

<p>在做任何相关优化之前，我们需要做一些权衡。通过权衡，可以知道把优化的重点集中在什么地方。本文提到的一些技术缺点我们也需要做出考虑，我们必须考虑相关影响，以确保做出正确的决定。如果不做权衡的话，我们无法知道需要对程序做出什么样的改变。</p>

<p>当第一安装iOS程序时，需要下载完整的一个<code>.ipa</code>文件。(注意这<a href="https://developer.apple.com/library/ios/qa/qa1779/">不同于升级</a>)。实际上<code>.ipa</code>文件就是一个<code>.zip</code>结构。</p>

<p>我们可以通过这样的方法来找出程序的<code>.ipa</code>文件：从App Store下载应用，然后利用iTunes对iOS设备做同步处理，接着查看目录：<code>~/Music/iTunes/iTunes Music/Mobile Applications</code>，就能找到<code>.ipa</code>文件了。</p>

<p>当让我们也可以通过使用: <a href="https://developer.apple.com/library/ios/qa/qa1764/">Xcode的Archive命令来构造出<code>.ipa</code>文件——该文件与提交到App Store上的格式基本一致</a>。</p>

<h3>检查<code>.ipa</code>文件</h3>

<p>简单的将后缀为<code>.ipa</code>文件修改为<code>.zip</code>，然后利用Finder将其解压出来。右键单击解压出来的<code>.app bundle</code>，选择<code>显示包内容</code>，以查看里面的资源文件。通过该方法我们可以看到哪些文件占的空间最大。记住：<code>.app bundle</code>是经过压缩的，并且有些文件的压缩效果要比别的文件好，所以压缩后的效果才是才是最重要的。不过一般情况下在压缩前最大的文件，在压缩后依旧是最大的文件。我们可以将某个文件删除，然后在Finder中右键单击，选择<code>压缩</code>，这样可以更加精确的测量文件压缩效果。</p>

<h3>iOS App Store相关因素</h3>

<p>作为提交到App Store中app里的可执行文件是被加过密的。加密的副作用是可执行文件的压缩效果没有之前的好了，因为加密会隐藏一些细节问题。因此，从App Store下载下来的.ipa文件大小要比从本地build出来的.ipa文件大。</p>

<p>注意：将<code>长文本内容</code>和<code>表数据</code>等从代码中移除，并添加到外部文件中，这样可以减小最终安装包下载的大小——因为这些文件的压缩效果更好。</p>

<p>如果你选择Organizer window中的某个archived，然后点击<code>Estimate Size</code>，Xcode可以对最终分发的程序尺寸做出一个评估。这里并不考虑Mac App Store上面的和企业级部署的iOS程序。</p>

<h2>Build Settings</h2>

<h3>编译选项</h3>

<p>将build setting中的<code>Optimization Level</code>设置为<code>Fastest, Smallest [-Os]</code>; 将build setting 中的<code>Strip Debug Symbols During Copy</code>设置为<code>YES</code>(COPY_PHASE_STRIP = YES)，这样可以减小编译出二进制文件的尺寸。这里提到的这些设置在Xcode工程中对于<code>Release</code>的配置是默认的。</p>

<p>警告：这些设置会让你的程序很难debug。在一般开发环境build中不建议这样设置，</p>

<h3>Target针对较少的CPUs</h3>

<p>默认情况下，Xcode工程都配置为：对程序指定的特定CPU类型做优化处理，以生成相对于的可执行文件。不同的硬件，将运行不同的可执行代码。虽然这样优化后的程序，只能针对某些设备运行，但是这大大减小可执行程序的大小。</p>

<p>要想只设定特定类型的CPUs，可以修改build setting中的<code>Architectures</code>，将其从<code>Standard $(ARCHS_STANDARD)</code>修改为你希望支持的列表中对应的特定类型CPU。有效的CPU名称列在<code>Valid Architectures (VALID_ARCHS)</code> build setting中。请不要修改<code>Valid Architectures</code>设置项，最好由Xcode管理。</p>

<h2>Assets</h2>

<h3>对应用程序做一个完整性检查</h3>

<p>利用<a href="https://developer.apple.com/library/ios/qa/qa1795/_index.html#//apple_ref/doc/uid/DTS40014195-CH1-MEASURE">Inspecting Your App</a>中介绍的流程，对.app bundle做一个全面的检查，以了解那些是真正需要用到的。在程序中，经常会包含一些额外的文件，例如readme之类的，这些从来都不会被用到。</p>

<h3>将数据从代码中剥离出来</h3>

<p>将所有的资源(例如很长的字符串)从代码中剥离出来，并存入外部文件，这样会减小最终文件下载的大小，因为这些文件的压缩效果更好。(参考<a href="https://developer.apple.com/library/ios/qa/qa1795/_index.html#//apple_ref/doc/uid/DTS40014195-CH1-FAIRPLAY">iOS App Store Specific Considerations</a>中的完整介绍。)</p>

<h2>Image Assets</h2>

<h3>尽量使用8-bit图片</h3>

<p>使用8-bit的PNG图片，比32-bit的图片能减少4倍的压缩率。由于8-bit的图片支持最多256种不同的颜色，所以8-bit的图片一般只应该用于一小部分的颜色图片。例如灰度图片最好使用8-bit。</p>

<h3>针对32-bit的图片尽量使用高压缩的比率</h3>

<p>利用Adobe Photoshop的<code>Save For Web</code>可以减小JPEG和PNG的图片大小。在Xcode中，默认情况下，会自动的使用<a href="https://developer.apple.com/library/ios/qa/qa1681/">pngcrush</a>来压缩.png图片。</p>

<h2>Audio Assets</h2>

<h3>音频的压缩</h3>

<p>参考WWDC中的<a href="https://developer.apple.com/videos/wwdc/2011/?id=404">Audio Development for Games</a>，里面介绍了如何有效的处理音频。常规来说，我们要使用AAC或MP3来压缩音频，并且可以尝试降低一下音频的比特率。有时候44.1khz的采样是没有必要的，稍微低一点的比特率也不会降低音频的质量。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[提高Interface Builder高效工作的8个技巧]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/03/19/18-tips-for-working-effectively-with-interface-builder/"/>
    <updated>2014-03-19T00:10:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/03/19/18-tips-for-working-effectively-with-interface-builder</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/03/21.png" alt="" /></p>

<!--more-->


<p>本文译自：<a href="http://codesheriff.blogspot.com/2014/03/8-tips-for-working-effectively-with.html">8 Tips for working effectively with Interface Builder</a>(需翻墙)</p>

<p>先来看看目录：</p>

<ol>
<li>介绍</li>
<li>使view的Size与view中的Content相适应</li>
<li>按住option键—观察所选中view与另外view边缘之间的距离</li>
<li>Editor &ndash;> Embed In View, Unembed:</li>
<li>在不影响subview的位置时给view自由的添加padding</li>
<li>对不在最前端的view进行移动</li>
<li>IBOutletCollection排序</li>
<li>使用自定义属性</li>
<li>MoarFonts——字体定制：所见即所得</li>
</ol>


<h2>介绍</h2>

<p>在JoyTunes工作期间，我们在开发最新一版的钢琴应用程序，对程序的UI做了大量的重新设计，因而也在Interface Builder上花费了许多时间，对于图片和view的缩放操作，非常的让人不省心。不过在开发过程中，我们发现了许多非常不错的IB使用技巧，我寻思着这必须要跟大家分享，所以成就了这篇文章。</p>

<p>免责声明：
在JoyTune工作期间，我们使用的是.xib文件(不是storyboards)，并且没有使用Auto Layout。实际上这主要是历史原因导致的。所以，这里介绍的一些技巧可能稍微有点不同(如果你使用storyboard或Auto Layout)，不过大多数都是一样的。</p>

<h2>1. 使view的Size与view中的Content相适应</h2>

<p>很惭愧的是最近才发现这个功能——能节约大量时间。
选中任意的一个view，然后Editor->Size to Fit Content，或者简单的按 ⌘=
接着就会按照下面的规则对选中view的Size做出与之Content对应的适应。</p>

<ul>
<li> ImageView/Button的size会设置为图像的原始size(最常见的用法)：</li>
</ul>


<p><img src="/images/2014/03/12.gif" alt="" /></p>

<ul>
<li> Label/Button的size会被设置为与当前text内容相当的尺寸：</li>
</ul>


<p><img src="/images/2014/03/13.gif" alt="" /></p>

<ul>
<li> parent container view会与其subviews的frames相适应。</li>
</ul>


<p><img src="/images/2014/03/14.gif" alt="" /></p>

<h2>2.  按住option键—观察所选中view与另外view边缘之间的距离</h2>

<p>按住option键之后，选择一个view，然后将鼠标悬停在别的一些view上，会看到一些距离——选中view与别的view边缘之间的距离。</p>

<p><img src="/images/2014/03/15.gif" alt="" /></p>

<h2>3. Editor &ndash;> Embed In View, Unembed:</h2>

<p>你是不是对此素手无策呢：你希望将已有的一些subviews放入到不同的parent view中，甚至是不同的.xib文件中，但是当你把一些view重新设置之后，它们为自动的位于新的parent view中心？</p>

<p>现在好了，我们有一个解决办法，如下图所示：</p>

<p><img src="/images/2014/03/16.gif" alt="" /></p>

<h2>4. 在不影响subview的位置时给view自由的添加padding</h2>

<p>当试图给view添加padding时，默认情况下subview的x和y是不会改变的，但是有时候我们并不希望是这样的结果。我发现一个最好的方法，就是在按住⌘时拖动view的边缘：</p>

<p><img src="/images/2014/03/17.gif" alt="" /></p>

<h2>5. 对不在最前端的view进行移动</h2>

<p>刚开始我还以为要想移动不在最前端的view是不可行的。</p>

<p>有一种方法就是先将非最前端的view临时设置到最前端，移动好位置之后，在设置回去。</p>

<p>另外一种方法就是使用右边panel中的size inspector，不过有时候要想设置一个好的位置，需要不断的猜测和修正。</p>

<p>另外我发现一种方法：使用键盘上的上下左右键来移动view——这还不用把view设置为最前端：</p>

<ul>
<li> 在document outline中选中view</li>
<li> 为了获得view的焦点：单击root view的frame</li>
<li> 利用箭头进行移动</li>
</ul>


<p><img src="/images/2014/03/18.gif" alt="" /></p>

<p>提醒：
获得view的焦点还有一个更好的方法：在document outline上双击view，就可以用箭头移动view了。</p>

<h2>6. IBOutletCollection排序</h2>

<p>有时候IBOutletCollection里面元素的顺序对我们来说非常重要：我们希望按某个顺序对其进行迭代。</p>

<p>有一种方法：在代码里面利用x/y/tag对其做排序处理，然后在迭代。</p>

<p>实际上，没必要这么做。IBOutletCollection的顺序取决于我们dragged connection的顺序，可以通过^+单击 File&rsquo;s Owner来查看当前的顺序：</p>

<p><img src="/images/2014/03/19.gif" alt="" /></p>

<h2>7. 使用自定义属性</h2>

<p>可能这个功能是IB中很少被使用的：使用Identity inspector中的User Defined Runtime Attributes(用户自定义运行时属性)在view上设置自定义属性：</p>

<p><img src="/images/2014/03/20.gif" alt="" /></p>

<p>在此我定义了一个JTLabel类，我们可以设置它的stroke color和width，这样一来我们就不用在代码里面设置相关属性了。</p>

<p>利用这个功能很好的一例子就是<a href="http://canvaspod.io/">Canvas</a>，通过它不用写一行代码就能定义相关的动画。</p>

<h2>8. MoarFonts——字体定制：所见即所得</h2>

<p>在Interface Builder中字体的定制是个非常麻烦的事情。IB并没有内置该功能，我用过比较好的解决办法就是使用自定义属性——就像Canvas一样，或者使用字体替换技术——例如<a href="https://github.com/deni2s/IBCustomFonts">IBCustomFonts</a>。这些都是有效的方案，不过他们有一个致命的缺点——它们不能给我们一种WYSIWYG(所见即所得)的体验，当然，这也是为什么我们会第一时间使用Interface Builder的原因。</p>

<p>为了知道给label设置的自定义字体是否合适，我们必须要运行程序才能知道结果——这有点让人不能接受。</p>

<p>最近我发现了一个新的解决办法：使用<a href="http://pitaya.ch/moarfonts/">MoarFonts</a>。卖价10美元，没有demo，没有试用——不过请相信，这非常值得购买！它的使用方法非常简单：将MoarFonts当做script build phase，然后build app，接着重启Xcode，就可在Interface Builder中看到定制的字体。</p>

<p>打完收工！希望这些技巧对你能有所帮助。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在iOS上使用自签名的SSL证书]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/03/17/five-tips-for-using-self-signed-ssl-certificates-with-ios/"/>
    <updated>2014-03-17T14:15:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/03/17/five-tips-for-using-self-signed-ssl-certificates-with-ios</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/03/09.png" alt="" /></p>

<!--more-->


<p>本文译自：<a href="http://blog.httpwatch.com/2013/12/12/five-tips-for-using-self-signed-ssl-certificates-with-ios/">Five Tips for Using Self Signed SSL Certificates with iOS</a></p>

<p>小引：</p>

<p>上周苹果release了iOS 7.1，用户升级至此版本，去下载企业级应用时，如果应用不是用https部署的，那么会提示服务器上的证书无效，如下图所示：</p>

<p><img src="/images/2014/03/11.PNG" alt="" /></p>

<p>小引:</p>

<p>在iOS 7.1中需要将plists文件的url路径设置为https才能下载安装，如果之前是用http部署的，这就需要对服务器做一些修改。网上流传着(<a href="http://stackoverflow.com/questions/20276907/enterprise-app-deployment-doesnt-work-on-ios-7-1/22325916#22325916">Enterprise app deployment doesn&rsquo;t work on iOS 7.1</a>)把plist放到公开的具有https功能的文件服务器上即可(dropbox或SkyDrive)，经试验，都是可行的。不过如要企业内部的网络无法访问外网，这又如何是好呢？网上也流传需要受信任的证书才行，这样一来对于某些企业的内部部署就比较麻烦了(局域网、主机名变动等都会引起很麻烦的事情)，各区域可能还要用不同的证书(对应不同的host name)。</p>

<p>经查苹果的相关文档(2014年2月份)，是可以使用http或者https的，后来打电话咨询苹果技术支持人员，告知文档还没来得及更新，不过自签名的证书也可以使用，最好首先要把证书(最好是CA根证书)通过mail或者配置工具安装到iOS设备上，然后根据这个CA构建web 服务器上用到的证书，这样当iOS设备访问web服务器来安装app时，就可以正常进行了。这样的话，我们只需要根据不同的服务器制作对应的自签名证书即可，有问题也方便修改跟进。</p>

<p>下面这篇文章就是介绍如何在iOS上面使用自签名的SSL证书。</p>

<p>先来看看目录：</p>

<ol>
<li>在iPhone或者iPad上的Safari中不要接受自签名证书</li>
<li>像安装iOS的Configuration Profile一样安装自签名证书</li>
<li>不要用IIS创建自签名证书</li>
<li>利用OpenSSL创建自签名证书</li>
<li>创建自己的证书颁发机构(CA)</li>
</ol>


<p>虽说SSL证书的购买价格不是太贵，不过有时候我们自行创建的话要更加方便一些，例如我们需要在开发环境配置SSL时、我们的测试服务器有不同的主机名或者开发的系统只有本地局域网才能访问。</p>

<p>实际上我们可以免费的创建<a href="http://en.wikipedia.org/wiki/Self-signed_certificate">自签名SSL证书</a>，并不需要给证书颁发机构(CA)支付任何费用，也不需要遵守任何审计要求。</p>

<p>使用自签名SSL证书的缺点就是浏览器不会自动的信任相关的站点。如果用iPhone或者iPad上的Safari打开相关站点，会看到如下提示界面：</p>

<p><img src="/images/2014/03/01.png" alt="" /></p>

<p>这里的HttpWatch iOS app还会有更详细的提示内容：</p>

<p><img src="/images/2014/03/02.png" alt="" /></p>

<p>本文剩余内容将介绍如何对iOS做配置，以避免上面遇到的问题，以及如何方便的创建和管理自签名证书。</p>

<h2>在iPhone或者iPad上的Safari中不要接受自签名证书</h2>

<p>当在Safari中第一次访问自签名证书的站点时，会有如下提示(Continue或Details->Accept)：</p>

<p><img src="/images/2014/03/03.png" alt="" /></p>

<p>如果你照着选择的话，是可以在Safari中打开站点的，不过这样会有两个明显的缺点：</p>

<ol>
<li>在Safari中接受证书只会添加一个<code>SSL例外</code>：防止Safari对此站点做出的警告提示。实际上并不会将证书安装到iOS中，以成为可信任的证书。同台设备的其它程序在连接该站点时仍然会失败。</li>
<li>一旦将<code>SSL例外</code>添加到iOS 7中了，就无法从iOS 7中移除。在之前的版本还可以通过Settings->Safari，选中"Clear Cookies and Data"进行删除。在iOS 7中这好像没有效果。&mdash;&mdash;&mdash;除非<code>General &gt; Reset &gt; Reset Settings</code>。</li>
</ol>


<p>当然，苹果官方也提供了一个工具<a href="http://support.apple.com/downloads/#iphone%20configuration%20utility">iPhone configuration utility for Mac and PC</a>，通过该工具可以把证书安装至设备中。如果邮件不可用，或者要批量安装的话，这是一个好方法。</p>

<h2>像安装iOS的Configuration Profile一样安装自签名证书</h2>

<p>要想把SSL证书在iOS设备上安装为可信任的，可以通过发邮件到设备上，并将证书以附件的形式带在邮件中：</p>

<p><img src="/images/2014/03/04.png" alt="" /></p>

<p>选择邮件中的附件，以将证书安装至iOS设备中。选择附件之后，选择<code>Install</code>来安装证书。完成安装之后，再在Safari或者其它iOS应用中使用该证书时，就不会有相关提醒了。</p>

<p>并且这与Safari添加的<code>SSL例外</code>有一个很大的区别，你可以在任意时刻通过<code>Settings-&gt;General-&gt;Profiles</code>来查看相关证书，如果有必要的话，还可以将其移除：</p>

<p><img src="/images/2014/03/05.png" alt="" /></p>

<p>当然，苹果也提供了一个工具<a href="http://support.apple.com/downloads/#iphone%20configuration%20utility">iPhone configuration utility for Mac and PC</a>，通过该工具可以把证书安装到设备中，如果邮件不可用，或者要批量安装证书的话，可以用这个工具。</p>

<h2>不要用IIS创建自签名证书</h2>

<p>在IIS中创建自签名证书非常的简单。只需要选择菜单中的<code>Create Self-Signed Certificate</code>即可：</p>

<p><img src="/images/2014/03/06.png" alt="" /></p>

<p>不过IIS简单的使用计算机名称当做证书的主机名：</p>

<p><img src="/images/2014/03/07.png" alt="" /></p>

<p>大多数时候，计算机名称与主机名是不匹配的，这样的话自签名的证书永远都不会受信任——即使已经安装至iOS设备中：</p>

<p><img src="/images/2014/03/08.png" alt="" /></p>

<p>要修复这个问题可以安装并运行IIS 6 Toolkit中的SelfSSL。不过，要是使用OpenSSL则非常简单，下面我们就来看看吧。</p>

<h2>利用OpenSSL创建自签名证书</h2>

<p>创建自签名证书最简单的一种方法就是使用<a href="http://www.openssl.org/related/binaries.html">OpenSSL命令行工具</a>，这个工具在许多平台上面都可以使用，并且在Mac OSX上面是默认安装好了的。</p>

<p>首先，创建一个私钥文件：</p>

<p><code>
openssl genrsa -out myselfsigned.key 2048
</code></p>

<p>然后创建自签名证书：</p>

<p><code>
openssl req -new -x509 -key myselfsigned.key -out myselfsigned.cer -days 365
-subj /CN=www.mysite.com
</code></p>

<p>上面的命令中，关于私钥和证书(cer)的文件名可以是任意的。其中<code>CN</code>参数需要设置为主机名(例如<a href="https://www.mysite.com">https://www.mysite.com</a>)。而<code>days</code>参数则指定证书从创建开始的有效天数。</p>

<p>在Apache服务器上面可以直接使用私钥和证书文件(做相关的SSL配置即可)。在IIS中需要一个PFX文件，通过该文件，可以将证书导入至IIS的Server Certificates中。当然通过OpenSSL可以创建PFX文件：</p>

<p><code>
openssl pkcs12 -export -out myselfsigned.pfx -inkey myselfsigned.key
-in myselfsigned.cer
</code></p>

<h2>创建自己的证书颁发机构(CA)</h2>

<p>使用自签名证书会有这样的问题：需要为每台设备中用到的每个证书设置相关的信任关系。有一个解决办法就是创建自己的证书颁发机构(CA)根证书，然后基于该根证书创建别的证书。</p>

<p>这样一来就是自己扮演着CA，取代了商业性质的CA。这样做的好处就是自己的CA证书只需要在每台设备上安装一次即可。之后，设备会自动的信任基于CA根证书创建的证书。</p>

<p>创建CA证书只需要两个步骤即可，首先是创建私钥文件(跟之前的一样)：</p>

<p><code>
openssl genrsa -out myCA.key 2048
</code></p>

<p>然后是创建证书：</p>

<p><code>
openssl req -x509 -new -key myCA.key -out myCA.cer -days 730
-subj /CN="My Custom CA"
</code></p>

<p>上面创建的证书(myCA.key)可以公开发布出去，并安装在iOS或者其它OS上，以此当做内置的受信任根CA。自制的CA证书存储在<code>General-&gt;Settings-&gt;Profile</code>：</p>

<p><img src="/images/2014/03/10.png" alt="" /></p>

<p>其中私钥文件(myCA.key)只用是再创建新的SSL证书时使用。</p>

<p>上面的CA创建好之后，我们可以基于该证书创建许多证书。注意，这里多了一个步骤：必须创建一个CSR(客户端证书请求文件)——就像购买商业的SSL证书一样。</p>

<p>首先需要创建一个私钥文件：</p>

<p><code>
openssl genrsa -out mycert1.key 2048
</code></p>

<p>然后是创建CSR:</p>

<p><code>
openssl req -new -out mycert1.req -key mycert1.key -subj /CN=www2.mysite.com
</code></p>

<p>接着用这个CSR创建证书：</p>

<p><code>
openssl x509 -req -in mycert1.req -out mycert1.cer -CAkey myCA.key
-CA myCA.cer -days 365 -CAcreateserial -CAserial serial
</code></p>

<p>这里创建的证书(mycert.cer)可以安装在一台web服务器上，并且已经安装了相关CA证书的iOS设备都可以访问该web服务器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7中实现模糊效果]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/29/ios-7-blur-effects-gpuimage/"/>
    <updated>2014-01-29T19:10:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/29/ios-7-blur-effects-gpuimage</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/42.png" alt="" /></p>

<!--more-->


<p>本文译自<a href="http://www.raywenderlich.com/60968/ios-7-blur-effects-gpuimage">iOS 7 Blur Effects with GPUImage</a>。</p>

<p>iOS 7在视觉方面有许多改变，其中非常吸引人的功能之一就是在整个系统中巧妙的使用了模糊效果。许多第三方应用程序已经采用了这样的设计细节，并以各种奇妙的和具有创造性的方式使用它。</p>

<p>本文将通过几种不同的技术来实现iOS 7中的模糊效果，当然，这一切都利用了一个名为<a href="https://github.com/BradLarson/GPUImage">GPUImage</a>的框架。</p>

<p><code>GPUImage</code>是由<a href="http://www.sunsetlakesoftware.com/blog">Brad Larson</a>创建的，它利用GPU，使在图片和视频上应用不同的效果和滤镜变得非常的容易，同时它还拥有出色的性能，并且它的性能要比苹果内置的相关APIs出色。</p>

<p><code>注意：本文需要一台物理设备来编译并运行示例程序(在模拟器上无法使用)。同样还需要一个iOS开发者账号。如果你还没有开发者账号的话，可以来[这里](https://developer.apple.com/)注册一个。注册为开发者之后，会有许多福利哟，例如可以使用物理设备来开发程序，提前获得苹果的相关测试版程序，以及大量的开发资源。</code></p>

<p><img src="/images/2014/01/21.png" alt="iOS中利用GPUImage实现模糊效果" /></p>

<p>下面我们先来看看本文的目录结构：</p>

<ul>
<li>开始</li>
<li>为什么要是用模糊效果

<ul>
<li>深度引导</li>
<li>上下文</li>
<li>关注度</li>
</ul>
</li>
<li>添加静态的模糊效果

<ul>
<li>创建截图Category</li>
<li>利用断点测试截屏图片</li>
<li>显示截屏图片</li>
<li>设置contentsRect</li>
<li>重置模糊滤镜</li>
<li>对其背景图片</li>
</ul>
</li>
<li>实时模糊</li>
<li>线程中简洁的分支</li>
<li>一些潜在的实时模糊方案</li>
<li>一个折中的方法——对视频实时模糊

<ul>
<li>利用GPUImage对视频进行模糊处理</li>
</ul>
</li>
<li>何去何从？</li>
</ul>


<h2>开始</h2>

<p>首先先来<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2013/12/Video-Blurring.zip">这里</a>下载本文的starter工程，并将其解压出来。</p>

<p>用Xcode打开<code>Video Blurring.xcodeproj</code>，并将工程运行到设备中。此时看到程序的效果如下所示：</p>

<p><img src="/images/2014/01/22.png" alt="" /></p>

<p>点击屏幕左上角的<code>菜单</code>(三条横纹)，可以看到界面中出现两个选项：录制视频和播放已有视频。</p>

<p>请注意，现在所有的用户界面都有一个灰色的背景，是不是感觉有点沉闷呢，本文我们就利用iOS 7中的模糊效果来替换掉这些沉闷的灰色背景。</p>

<h2>为什么要是用模糊效果</h2>

<p>除了外观看起来很棒以外，模糊效果还可以让程序给用户带来3个重要的概念：深度引导、上下文和关注度。</p>

<h3>深度引导</h3>

<p>在用户界面上，模糊效果可以给用户提供一个深度引导效果，并且有利于用户对程序导航的理解。在之前的iOS版本中的深度引导效果是通过：三维斜面(three-dimensional bevels)和有关泽的按钮(反映出一个模拟的光源)，而在iOS 7中是通过模糊和视差(<a href="http://en.wikipedia.org/wiki/Parallax">parallax</a>)来实现的。</p>

<p>这里说的视差效果，可以很明显的观察出来：在装有iOS 7的设备中，将设备从一侧倾斜至另一侧，会发现设备中的图标在移动(会独立于背景)。这样可以给用户做出一个提示：界面是由不同的层构成的，并且重要的界面元素是在最前面的——这也涉及到下面将要介绍的一个概念：上下文。</p>

<h3>上下文</h3>

<p>上下文可以让用户在程序内获得一种轴承的感觉。动画的过度效果就提供了一种非常优秀的上下文，当用户点击一个按钮时，在两个view之间利用动画效果来切换画面(而不是直接显示一个新的view)，可以让用户知道新的view是从哪里出现的，并且可以让用户很容易知道如何回到上一个view。</p>

<p>模糊效果可以将上一个view当做背景显示出来，尽管上一个view已经失去焦点了，不过可以给用户提供更多的上下文：刚刚是在哪里。通知中心就是一个非常棒的例子：当拉下通知中心时，我们可以在背景中看到原来的view(即使现在正在处于通知中心界面)。</p>

<h3>关注度</h3>

<p>让界面更加关注于某些选择项上，而移除不需要的内容，让用户可以更加快捷的进行导航。用户可以本能的忽略那些被模糊的界面元素，而将注意力集中到某些界面元素中。</p>

<p>通过本文，你将学到两种模糊类型的实现方法：静态模糊和动态模糊。静态模糊代表着快照的时间点，它并不能反映被模糊界面元素的变化。大多数情况下，使用静态模糊效果就足够了。相反，动态模糊则是对需要模糊的背景做出实时更新。</p>

<p>相信看到具体的效果才是最好的，下面我们就来看看模糊效果的具体实现吧！</p>

<h2>添加静态的模糊效果</h2>

<p>创建一个静态模糊效果首先是将当前屏幕中的view转换为一幅图片。获得图片之后，只需要对图片做模糊处理就可以了。将view转换为一幅图片(截屏)苹果已经提供了一些非常棒的APIs了，并且在iOS 7中又有了新的方法可以让截屏更加快速。</p>

<p>这些新的方法属于<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/uiview_class/uiview/uiview.html#//apple_ref/occ/instm/UIView/drawViewHierarchyInRect:afterScreenUpdates:">截屏APIs</a>中的一部分，截屏APIs不仅可以对某个view截屏，还能把整个view层次截屏，如果你希望对某个view截屏，那么可以把view中的按钮、标签、开关等各种view也进行截屏。</p>

<p>此处我们将截屏的逻辑实现到<code>UIView</code>的一个category中。这样一来，我们就可以很方便快捷的将任意的view(以及view中的内容)转换为一个图片——也算是代码的重用吧。</p>

<h3>创建截图Category</h3>

<p>打开<code>File/New/File...</code>，然后选择<code>iOS/Cocoa Touch/Objective-C category</code>，如下图所示：</p>

<p><img src="/images/2014/01/23.png" alt="" /></p>

<p>将这个category命名为<code>Screenshot</code>，并将它的category选为<code>UIView</code>,如下图所示：</p>

<p><img src="/images/2014/01/24.png" alt="" /></p>

<p>将下面这个方法声明到<code>UIView+Screenshot.h</code>中：</p>

<p><code>objc
-(UIImage *)convertViewToImage;
</code></p>

<p>接着将如下方法添加到<code>UIView+Screenshot.m</code>中：</p>

<p>```objc
&ndash;(UIImage *)convertViewToImage
{</p>

<pre><code>UIGraphicsBeginImageContext(self.bounds.size);
[self drawViewHierarchyInRect:self.bounds afterScreenUpdates:YES];
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();

return image;
</code></pre>

<p>}
```</p>

<p>上面的方法中，首先调用了<code>UIGraphicsBeginImageContext()</code>，最后调用的是<code>UIGraphicsEndImageContext()</code>，这两行代码可以理解为图形上下文的一个事物处理过程。一个上下文可以理解为不同的概念，例如屏幕，或者此处可以理解为一幅图片。这里的两行代码起到一个离屏画布的作用——可以将view绘制上去。</p>

<p><code>drawViewHierarchyInRect:afterScreenUpdates:</code>方法利用view层次结构并将其绘制到当前的上下文中。</p>

<p>最后，<code>UIGraphicsGetImageFromCurrentImageContext()</code>从图形上下文中获取刚刚生成的<code>UIImage</code>。</p>

<p>现在，我们已经完成了category的实现，接着我们只需要在使用到的地方将其import一下即可。</p>

<p>如下代码所示，将代码添加到<code>DropDownMenuController.m</code>顶部：</p>

<p>```objc</p>

<h1>import &ldquo;UIView+Screenshot.h&rdquo;</h1>

<p>```</p>

<p>同时，将如下方法添加到相同的文件中：</p>

<p>```objc
&ndash;(void)updateBlur
{</p>

<pre><code>UIImage *image = [self.view.superview convertViewToImage];
</code></pre>

<p>}
```</p>

<p>上面的代码确保是对superview进行截屏，而不仅仅是当前的view。不这样做的话，截屏获得的图片只是menu本身。</p>

<h3>利用断点测试截屏图片</h3>

<p>为了测试截屏的效果，我们在<code>convertViewToImage</code>调用的下面一行添加一个断点。这样当命中断点时，程序会在断点中暂停执行，这样我们就可以看到截屏的图片，以此确保截屏代码的正确性:</p>

<p><img src="/images/2014/01/25.png" alt="" /></p>

<p>在测试之前还有一件事情需要做：调用上面这个方法。</p>

<p>找到<code>show</code>方法，并在<code>addToParentViewController</code>下面直接调用一下<code>updateBlur</code>：</p>

<p>```objc
&ndash;(void)show {</p>

<pre><code>[self addToParentViewController];

[self updateBlur]; // Add this line

CGRect deviceSize = [UIScreen mainScreen].bounds;

[UIView animateWithDuration:0.25f animations:^(void){
    _blurView.frame = CGRectMake(0, 0, deviceSize.size.height, MENUSIZE);
    _backgroundView.frame = CGRectMake(0, 0, _backgroundView.frame.size.width, MENUSIZE);
}];
</code></pre>

<p>}
```</p>

<p>编译并运行程序，点击菜单按钮，可以看到Xcode在断点出停止了，如下所示：</p>

<p><img src="/images/2014/01/26.png" alt="" /></p>

<p>在debugger左下角hand pane中选择<code>image</code>，然后单击<code>快速查找图标</code>按钮，就可以预览刚刚的截屏啦：</p>

<p><img src="/images/2014/01/27.png" alt="" /></p>

<p>如上图所示，正是我们所预期的。</p>

<h3>显示截屏图片</h3>

<p>将截取到的图片显示到菜单的背景中就是小菜一碟啦。</p>

<p>一般来说我们都会利用<code>UIImageView</code>来显示一幅图片，而由于我们要利用<code>GPUImage</code>来模糊图片，所以需要使用<code>GPUImageView</code>。</p>

<p>在这里的工程中，已经添加好了<code>GPUImage</code>框架，我们只需要将头文件import一下即可。</p>

<p>将下面的代码添加到<code>DropDownMenuController.m</code>顶部：</p>

<p>```objc</p>

<h1>import &lt;GPUImage/GPUImage.h></h1>

<p>```</p>

<p><code>注意：GPUImage被包含在一个框架中，所以在import语句中，需要利用尖括弧，而不是双引号</code>。</p>

<p>此时，有一个_blurView，类型为UIView——是菜单的灰色背景。将UIView修改为<code>GPUImageView</code>，如下所示：</p>

<p>```objc
@implementation DropDownMenuController {</p>

<pre><code>GPUImageView *_blurView;
UIView *_backgroundView;
</code></pre>

<p>}
```</p>

<p>修改之后，Xcode会报一个warning：大意是你利用<code>UIView</code>进行实例化，而不是预期的<code>GPUImageView</code>。</p>

<p>可以通过下面的方法消除这个警告，在<code>viewDidLad</code>中修改做如下修改：</p>

<p><code>objc
_blurView = [[GPUImageView alloc] initWithFrame:CGRectMake(0, 0, deviceSize.size.height, 0)];
</code></p>

<p>紧随其后，将如下两行代码添加进去，并移除设置背景色的代码：</p>

<p><code>objc
_blurView.clipsToBounds = YES;
_blurView.layer.contentsGravity = kCAGravityTop;
</code></p>

<p><code>clipToBounds</code>属性设置为YES，把超出_blurView范围的子view隐藏起来，而<code>contentsGravity</code>确保图片出现在image view的顶部。</p>

<p>由于<code>_blurView</code>已经用于背景了，所以此处不需要额外设置了。</p>

<p>接着，我们还需要声明一个用于模糊效果的过滤器。</p>

<p>将如下代码添加到<code>DropDownMenuController.m:</code>文件的<code>@implementation</code>中：</p>

<p><code>objc
GPUImageiOSBlurFilter *_blurFilter;
</code></p>

<p>找到之前添加的断点，右键单击，并选中<code>Delete Breakpoint</code>：</p>

<p><img src="/images/2014/01/28.png" alt="" /></p>

<p>下面是非常重要的一步了——初始化模糊滤镜。将如下代码添加到<code>DropDownMenuController.m</code>中：</p>

<p>```objc
&ndash;(void)updateBlur
{</p>

<pre><code>if(_blurFilter == nil){
    _blurFilter = [[GPUImageiOSBlurFilter alloc] init];
     _blurFilter.blurRadiusInPixels = 1.0f;

}

UIImage *image = [self.view.superview convertViewToImage];
</code></pre>

<p>}
```</p>

<p><code>注意：上面将模糊半径设置为一个像素，这里暂时将这个值设置低一点，这样可以确保图片的正确定位，当一切ok之后，再增加模糊半径即可。</code></p>

<p>下面是时候将图片显示到<code>GPUImageView</code>中了。不过并不是简单的实例化一个<code>UIImage</code>，并将其添加到<code>GPUImageView</code>中。首先需创建一个<code>GPUImagePicture</code>。</p>

<p>将如下代码添加到<code>updateBlur</code>方法的底部：</p>

<p><code>objc
GPUImagePicture *picture = [[GPUImagePicture alloc] initWithImage:image];
</code></p>

<p>至此，我们获得了一个图片，模糊滤镜和iamge view。</p>

<p>接着再将如下代码添加到<code>updateBlur</code>底部：</p>

<p>```objc
[picture addTarget:<em>blurFilter];
[</em>blurFilter addTarget:_blurView];</p>

<p>[picture processImage];
```</p>

<p>上面这几行代码，就像胶水一样，将所有的事情关联起来。将滤镜当做target添加到图片中，然后将image view当做滤镜的target。</p>

<p>上面代码对图片的处理全程发生在GPU上，也就是说当进行模糊计算和显示时，并不会影响到用户界面。当处理结束时，会把图片显示到image view上面。</p>

<p>编译并运行程序，点击菜单按钮，可以看到如下类似画面：</p>

<p><img src="/images/2014/01/29.png" alt="" /></p>

<p>上面的图片看起来是不是有点奇怪？看到的图片被缩放到适配到菜单视图中了。要对此做出修正，我们需要指定图片的哪一部分需要显示在<code>GPUImageView</code>中——也就是处理截屏视图的上半部分。</p>

<h3>设置contentsRect</h3>

<p>按照如下代码所示修改<code>DropDownMenuController.m</code>文件中的<code>show</code>方法：</p>

<p>```objc
&ndash;(void)show
{</p>

<pre><code>[self addToParentViewController];

[self updateBlur];

CGRect deviceSize = [UIScreen mainScreen].bounds;

[UIView animateWithDuration:0.25f animations:^(void){
    _blurView.frame = CGRectMake(0.0f, 0.0f, deviceSize.size.height, MENUSIZE);
    _backgroundView.frame = CGRectMake(0.0f, 0.0f, _backgroundView.frame.size.width, MENUSIZE);
    _blurView.layer.contentsRect = CGRectMake(0.0f, 0.0f, 1.0f, MENUSIZE / 320.0f); // Add this line!
}];
</code></pre>

<p>}
```</p>

<p>通过指定<code>_blurView.layer.contentsRect</code>来定义一个矩形，在单元坐标空间(unit coordinate space)中，表示只使用layer content的一部分。</p>

<p>编译并运行程序，点击菜单按钮，会看到如下图所示效果：</p>

<p><img src="/images/2014/01/30.png" alt="" /></p>

<p>虽然已经使用了图片的一部分，看起来还是不正确，这是因为它的缩放比例还不适合！此处还缺少对正确内容的缩放。</p>

<p>将下面这行代码添加到<code>show</code>方法中动画block的尾部：</p>

<p><code>objc
_blurView.layer.contentsScale = (MENUSIZE / 320.0f) * 2;
</code></p>

<p><code>contentsScale</code>属性声明了layer在逻辑坐标空间(以点为单位)和物理坐标空间(以像素为单位)之间的映射关系。更高比例因子表示在渲染layer时，一个点代表着多个像素点。</p>

<p>编译并运行程序，点击菜单按钮，可以看到缩放比例已经正常了：</p>

<p><img src="/images/2014/01/31.png" alt="" /></p>

<p>没错——看起来好多了！现在关闭程序，然后重新打开，ou~~发生了什么？如下图所示：</p>

<p><img src="/images/2014/01/32.png" alt="" /></p>

<p>看起来这还是有点问题。如果在对view进行animation之前将contentScale设置回2.0，会解决half bar的问题。</p>

<p>将如下代码添加到<code>DropDownMenuController.m</code>中<code>show</code>方法里面的animation block上面：</p>

<p><code>objc
_blurView.layer.contentsScale = 2.0f;
</code></p>

<p>编译并运行程序，然后点击菜单，接着关闭菜单，再打开菜单，此时菜单开起来如下所示：</p>

<p><img src="/images/2014/01/33.png" alt="" /></p>

<p>现在半个尺寸的黑色box已经没有问题了——但是现在是全尺寸的黑色box！</p>

<h3>重置模糊滤镜</h3>

<p>上面问题产生的原因是由于进行了二次模糊计算。解决的方法是移除模糊滤镜中的所有target。如果不这样做的话，之后对滤镜的调用不会输出任何的内容——进而引起黑色box的问题。</p>

<p>按照如下代码更新一下<code>updateBlur</code>方法：</p>

<p>```objc
&ndash;(void)updateBlur
{</p>

<pre><code>if(_blurFilter == nil){
    _blurFilter = [[GPUImageiOSBlurFilter alloc] init];
    _blurFilter.blurRadiusInPixels = 1.0f;
}

UIImage *image = [self.view.superview convertViewToImage];

GPUImagePicture *picture = [[GPUImagePicture alloc] initWithImage:image];
[picture addTarget:_blurFilter];
[_blurFilter addTarget:_blurView];

[picture processImageWithCompletionHandler:^{
    [_blurFilter removeAllTargets];
}];
</code></pre>

<p>}
```</p>

<p>上面的代码用<code>processImageWithCompletionHandler:</code>替换了<code>processImage</code>方法。这个新的方法有一个completion block，当image 处理结束时，会运行这个block。一旦image处理结束，我们就可以安全的将滤镜中的target全部移除。</p>

<p>编译并运行程序，点击菜单，检查一下黑色box问题是不是已经解决掉了：</p>

<p><img src="/images/2014/01/34.png" alt="" /></p>

<p>多次打开和关闭菜单，确保之前的那个bug已经解决掉啦！</p>

<p>现在仔细观察一下打开菜单的模糊效果——有些东西看起来不正确。为了更加明显的观察到问题，我们减慢动画的时间，让其慢慢的移动。</p>

<p>在<code>show</code>方法中，将animation bloc的持续时间修改为10.0f。</p>

<p>编译并运行程序，点击菜单，然后观察一下菜单出场的慢动作：</p>

<p><img src="/images/2014/01/35.png" alt="" /></p>

<p>恩，现在可能你已经发现问题了。被模糊的图片从顶部往下滑动——而我们的本意是希望模糊效果从上往下滑(并不是图片本身)。</p>

<h3>对其背景图片</h3>

<p>此处我们需要对静态模糊效果使用一些技巧。当出现菜单时，我们需要利用背景来将模糊效果对其。所以在这里我们不是对image view做移动处理，而是需要对image view做扩展处理，从0开始扩展至image view的全尺寸。这样就可以确保菜单打开时，图片依然保留在原位。</p>

<p>在<code>show</code>方法中，我们已经将菜单打开至全尺寸了，所以现在只需要将<code>contentRect</code>的高度设置为0即可(当image view首次创建并隐藏的时候)。</p>

<p>将下面的代码添加至<code>DropDownMenuController.m</code>文件的<code>viewDidLoad</code>方法中——在_blurView初始化的下方：</p>

<p><code>objc
_blurView.layer.contentsRect = CGRectMake(0.0f, 0.0f, 1.0f, 0.0f);
</code></p>

<p>同时，在相同的一个文件中，将下面的代码添加到animation block的尾部：</p>

<p><code>objc
_blurView.layer.contentsRect = CGRectMake(0.0f, 0.0f, 1.0f, 0.0f);
</code></p>

<p><code>contentRect</code>属性是可以动画方式设置的。因此在动画期间会rect会自动的插补上。</p>

<p>编译并运行程序。可以看到，问题已经解决：</p>

<p><img src="/images/2014/01/36.png" alt="" /></p>

<p>这样看起来自然多了。现在我们已经有一个具有模糊背景的滑动菜单了。</p>

<p>现在是时候把动画所需时间调整一下了（为了更好的效果，其实之前设置的值是为了测试所用）：设置为0.25秒，接着在<code>updateBlur</code>方法中将<code>_blurFilter.blurRadiusInPixels</code>设置为<code>4.0f</code>。</p>

<p>编译并运行程序，多次打开菜单，看看效果如何：</p>

<p><img src="/images/2014/01/37.png" alt="" /></p>

<h2>实时模糊</h2>

<p>实时模糊涉及到的技术具有一定的难度，有些难点需要解决才行。为了有效的进行实时模糊，我们需要不停(每秒60帧)的截屏、模糊计算和显示。使用<code>GPUImage</code>每秒中处理60张图片(模糊并显示图片)一点问题都没有。</p>

<p>真正棘手的问题是什么呢？如何实时的截取屏幕图片，信不信由你！</p>

<p>由于截取的屏幕是主用户界面，所有必须使用CPU的主线程来截屏，并将其转换为一幅图片。</p>

<p><code>提醒：如果事物每秒钟的变化速度在46帧以上，那么人眼就无法识别出来了。这对于开发者来说也是一种解脱——现代处理器在各帧之间可以完成更多的大量工作。</code></p>

<h2>线程中简洁的分支</h2>

<p>当运行程序时，会执行大量的指令列表。每一个指令列表都运行在各自的线程中，而我们又可以在多个线程中并发运行各自的指令列表。一个程序在主线程中开始运行，然后会根据需要，创建新的线程，并在后台执行线程。如果之前你并没有管理过多线程，你可能在写程序的时候总是在主线程中执行指令。</p>

<p>主线程主要处理与用户的交互，以及界面的更新。确保主线程的响应时间是非常关键的。如果在主线程上做了太多的任务，你会明显的感觉到主界面响应迟钝。</p>

<p>如果你曾经使用过Twitter货Facebook，并滚动操作过它里面的内容，你可能已经感觉到后台线程在执行操作了——在滚动的过程中，并不是所有的个人图片立即显示出来，滚动过程中，程序会启动后台线程来获取图片，当图片获取成功之后，再显示到屏幕中。</p>

<p>如果不使用后台线程，那么table view的滚动过程中，如果在主线程上去获取个人图片，会感觉到table view被冻结住了。由于图片的获取需要一些时间，所以最好将这样耗时的操作让后台线程来做，这样就能对用户界面做平滑的操作和响应了。</p>

<p>那么对本文的程序有什么影响呢？之间介绍了，<code>UIView</code>的截屏APIs操作必须在主线程中运行。这就意味着每次截屏时，整个用户界面都会被冻结中。</p>

<p>对于静态模糊效果时，由于这个截屏操作很快，你不会感觉到界面的冻结。并且只需要截屏一次。然而在实时模糊效果中需要每秒中截屏60次。如果在主线程中做这样频繁的截屏操作，那么animation和transition会变得非常的迟钝。</p>

<p>更糟糕的时，如果用户界面复杂度增加，那么在截屏过程中就需要消耗更多的时间，那么就会导致整个程序无法使用了！</p>

<p>那么怎么办呢！</p>

<h2>一些潜在的实时模糊方案</h2>

<p>这里有一个关于实时模糊方案：源代码开源的<a href="https://github.com/nicklockwood/FXBlurView">live blur libraries</a>，它通过降低截屏的速度来实现实时模糊效果，并不是使用每秒截屏60次，可能是20、30或者40次。即使看起来没有多大区别，但是你的眼睛还是能发现一定的迟钝——模糊效果并没有跟程序的其它部分同步起来——这样一来，界面看起会没有模糊效果更加的糟糕。</p>

<p>实际上苹果在它们自己的一些程序中处理实时模糊并不存在类似的问题——但是苹果并没有公开相关的API。在iOS 7中<code>UIView</code>的截屏方法，相比于旧方法，性能有了很大的提升，但还是不能满足实时模糊的需求。</p>

<p>一些开发者利用<code>UIToolbar</code>的模糊效果来做一些不好的操作。没错，这是有效果的，但是强烈建议不要在程序中使用它们。虽然这不是私有API，但是这并不算是一种可行的方法，苹果也可能会<a href="https://github.com/JagCesar/iOS-blur/issues/25">reject</a>你的程序。也就是说在，在之后的iOS 7版本中，并不能保证还能正常使用。</p>

<p>苹果可以在任何时候对<code>UIToolBar</code>做出修改，或许你的程序就有问题了。在iOS 7.0.3更新中，苹果的修改已经影响到UIToolbar和UINavigationBar了，有些开发者也因此报告出利用相关模糊效果已经失效了！所以最好不要陷入这样潜在的陷阱里面！</p>

<h2>一个折中的方法——对视频实时模糊</h2>

<p>OK，此时你可能在想，要想在程序中做到实时模糊是不可能的了。那么还有什么方法可以突破限制，做到实时模糊效果呢？</p>

<p>在许多场景中，静态模糊是可以接受的。上一节中，我们对view做适当的修改，让用户看起来是对背景图做的实际模糊处理。当然，这对于静止不动的背景是合适的，并且还可以在模糊背景上实现一些不错的效果。</p>

<p>我们可以做一些实验，看看能不能找到一些效果来实现之前无法做到的实时模糊效果呢？</p>

<p>有一个方法可以试试：对实时视频做模糊处理，虽然截屏是一个非常大的瓶颈，但是<code>GPUImage</code>非常的强大，它能够对视频进行模糊(无论是来自摄像头的视频或者已经录制好的视频，都没问题)。</p>

<h3>利用GPUImage对视频进行模糊处理</h3>

<p>利用<code>GPUImage</code>对视频的模糊处理与图片的模糊处理类似。针对图片，我们实例化一个<code>GPUImagePicture</code>，然后将其发送给<code>GPUImageiOSBlurFilter</code>，接着再将其发送给<code>GPUImageView</code>。</p>

<p>类似的方法，对于视频，我们使用<code>GPUImageVideoCamera</code>或<code>GPUImageMovie</code>，将后将其发送给<code>GPUImageiOSBlurFilter</code>，接着再将其发送给一个<code>GPUImageView</code>。<code>GPUImageVideoCamera</code>用于设备中的实时摄像头，而<code>GPUImageMovie</code>用于已经录制好的视频。</p>

<p>在我们的starter工程中，已经实例化并配置好了<code>GPUImageVideoCamera</code>。现在的任务是将播放和录制按钮的灰色背景替换为视频的实时滤镜效果。</p>

<p>首先是将此处提供的灰色背景实例<code>UIView</code>替换为<code>GPUImageView</code>。完成之后，我们需要调整每个view的<code>contentRect</code>(基于view的frame)。</p>

<p>这听起来对每个view都需要做大量的工作。为了让任务变得简单，我们创建一个<code>GPUImageView</code>的子类，并把自定义的代码放进去，以便重用。</p>

<p>打开<code>File/New/File…</code>，然后选择<code>iOS/Cocoa Touch/Objective-C class</code>，如下所示：</p>

<p><img src="/images/2014/01/38.png" alt="" /></p>

<p>将类命名为<code>BlurView</code>，继承自<code>GPUImageView</code>，如下图所示：</p>

<p><img src="/images/2014/01/39.png" alt="" /></p>

<p>打开<code>ViewController.m</code>文件，将下面的import添加到文件顶部：</p>

<p>```objc</p>

<h1>import &ldquo;BlurView.h&rdquo;</h1>

<p>```</p>

<p>还是在<code>ViewController.m</code>中，在<code>@implementation</code>中找到<code>_recordView</code>和<code>_controlView</code>的声明，将其修改为<code>BlurView</code>类型，如下所示：</p>

<p>```objc
BlurView <em>_recordView; //Update this!
UIButton </em><em>recordButton;
BOOL </em>recording;</p>

<p>BlurView <em>_controlView; //Update this too!
UIButton </em><em>controlButton;
BOOL </em>playing;
```</p>

<p>然后按照如下代码修改<code>viewDidLoad</code>方法：</p>

<p>```objc</p>

<pre><code>_recordView = [[BlurView alloc] initWithFrame:
                CGRectMake(self.view.frame.size.height/2 - 50, 250, 110, 60)]; //Update this!
//_recordView.backgroundColor = [UIColor grayColor]; //Delete this!

_recordButton = [UIButton buttonWithType:UIButtonTypeCustom];
_recordButton.frame = CGRectMake(5, 5, 100, 50);
[_recordButton setTitle:@"Record" forState:UIControlStateNormal];
[_recordButton setTitleColor:[UIColor redColor] forState:UIControlStateNormal];
[_recordButton setImage:[UIImage imageNamed:@"RecordDot.png"] forState:UIControlStateNormal] ;
[_recordButton addTarget:self 
                  action:@selector(recordVideo) 
        forControlEvents:UIControlEventTouchUpInside];

[_recordView addSubview:_recordButton];
_recording = NO;

_recordView.hidden = YES;
[self.view addSubview:_recordView];


_controlView = [[BlurView alloc] initWithFrame:
                 CGRectMake(self.view.frame.size.height/2 - 40, 230, 80, 80)]; //Update this!
//_controlView.backgroundColor = [UIColor grayColor]; //Delete this!
</code></pre>

<p>```</p>

<p>接着，需要创建模糊图片，将其显示到上面构建的image view中。回到<code>@implementation</code>中，将下面的两个声明添加进去：</p>

<p><code>objc
GPUImageiOSBlurFilter *_blurFilter;
GPUImageBuffer *_videoBuffer;
</code></p>

<p>现在你已经知道<code>GPUImageiOSBlurFilter</code>的作用了，那么<code>GPUImageBuffer</code>的作用是什么呢？它的任务是获取视频的输出，并获取每一帧，这样我们就可以方便的对其做模糊处理。一个额外的好处就是它可以提升程序的性能！</p>

<p>一般来说，视频输出的内容会通过模糊滤镜处理，然后发送到背景视图中(被显示出来)。不过，在这里使用buffer的话，发送到buffer的视频输出内容，会被分为背景视图和模糊滤镜。这样可以对视频的输出显示做到平滑处理。</p>

<p>将下面的代码添加到<code>viewDidLoad</code>方法的顶部(在super调用的后面)：</p>

<p>```objc
_blurFilter = [[GPUImageiOSBlurFilter alloc] init];</p>

<p><em>videoBuffer = [[GPUImageBuffer alloc] init];
[</em>videoBuffer setBufferSize:1];
```</p>

<p>还是在同一个文件中，将如下高亮显示的语句添加到<code>useLiveCamera</code>方法中：</p>

<p>```objc
&ndash;(void)useLiveCamera
{</p>

<pre><code>if (![UIImagePickerController isSourceTypeAvailable: UIImagePickerControllerSourceTypeCamera]) {
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"No camera detected" 
                                                    message:@"The current device has no camera" 
                                                   delegate:self 
                                          cancelButtonTitle:@"Ok" 
                                          otherButtonTitles:nil];
    [alert show];
    return;
}

_liveVideo = [[GPUImageVideoCamera alloc] initWithSessionPreset:AVCaptureSessionPreset1280x720
                                                 cameraPosition:AVCaptureDevicePositionBack];
_liveVideo.outputImageOrientation = UIInterfaceOrientationLandscapeLeft;

[_liveVideo addTarget:_videoBuffer];           //Update this
[_videoBuffer addTarget:_backgroundImageView]; //Add this
[_videoBuffer addTarget:_blurFilter];          //And this
[_blurFilter addTarget:_recordView];           //And finally this

[_liveVideo startCameraCapture];

_recordView.hidden = NO;
_controlView.hidden = YES;
</code></pre>

<p>}
```
上面的模糊背景是用于录制按钮的。对于播放按钮也要做类似的处理。</p>

<p>将下面的代码添加到<code>loadVideoWithURL:</code>方法中(在<code>_recordedVideo.playAtActualSpeed = YES;</code>之后)：</p>

<p><code>objc
[_recordedVideo addTarget:_videoBuffer];
[_videoBuffer addTarget:_backgroundImageView];
[_videoBuffer addTarget:_blurFilter];
[_blurFilter addTarget:_controlView];
</code></p>

<p>编译并运行程序，打开录制操作，看看情况如何：</p>

<p><img src="/images/2014/01/40.png" alt="" /></p>

<p>好消息是看起来基本正常！坏消息是整个屏幕被缩放到录制按钮中去了。这个问题跟之前遇到的类似。我们需要给<code>BlurView</code>这是适当的<code>contentRect</code>。</p>

<p>打开<code>BlurView.m</code>，用下面的代码替换掉<code>initWithFrame:</code>方法：</p>

<p>```objc
&ndash; (id)initWithFrame:(CGRect)frame
{</p>

<pre><code>self = [super initWithFrame:frame];
if (self) {
    CGRect deviceSize = [UIScreen mainScreen].bounds;
    self.layer.contentsRect = CGRectMake(frame.origin.x/deviceSize.size.height, 
                                         frame.origin.y/deviceSize.size.width, 
                                         frame.size.width/deviceSize.size.height, 
                                         frame.size.height/deviceSize.size.width);
    self.fillMode = kGPUImageFillModeStretch;
}
return self;
</code></pre>

<p>}
```</p>

<p><code>contentRect</code>的每个参数必须在<code>0.0f</code>和<code>1.0f</code>之间。在这里只需要利用view的位置除以屏幕的size，得到的值即可。</p>

<p>编译并运行程序，看看效果如何：</p>

<p><img src="/images/2014/01/41.png" alt="" /></p>

<p>恭喜！至此已经完成了静态模糊和实时视频模糊的实现。现在你已经完全可以在程序中添加iOS 7的模糊效果啦！</p>

<h2>何去何从？</h2>

<p>可以在<a href="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/Video-Blurring-Final1.zip">这里</a>下载到完整的工程。</p>

<p>本文不仅指导你在程序中使用iOS 7的模糊效果，还介绍了如何使用<code>GPUImage</code>框架，这个框架也是我非常希望你能看到的东西。重要的是，本文指出了为什么要使用模糊，什么时候使用模糊效果是合适的，这在iOS 7的新设计语言中是一个关键的概念。当然也希望在未来的版本中，苹果能够将相关APIs提供给开发者使用，不过在那之前，<code>GPUImage</code>是一个不错的替代品。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对NSArray中自定义的对象进行排序]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/26/how-to-sort-nsarray-with-custom-objects/"/>
    <updated>2014-01-26T16:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/26/how-to-sort-nsarray-with-custom-objects</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/20.png" alt="" /></p>

<!--more-->


<p>本文译自<a href="http://ios-blog.co.uk/tutorials/how-to-sort-nsarray-with-custom-objects/">How to sort NSArray with custom objects</a>。</p>

<p>我们开发的每个程序都会使用到一些数据，而这些数据一般被封装在一个自定义的类中。例如一个音乐程序可能会有一个Song类，聊天程序则又一个Friend类，点菜程序会有一个Recipe类等。有时候我们希望在程序中显示的列表数据是按照一定顺序进行排列的，本文我们就来看看在iOS中有哪些方法可以对NSArray中的对象进行排序。下面是目录：</p>

<ul>
<li>小引</li>
<li>使用NSComparator进行排序</li>
<li>使用NSDescriptor进行排序</li>
<li>使用selector进行排序</li>
</ul>


<h3>小引</h3>

<p>我们将要排序的对象是一个Persion类，如下定义：</p>

<p>```objc
@interface Person : NSObject</p>

<p>@property (nonatomic, copy) NSString <em>name;
@property (nonatomic, copy) NSString </em>surname;
@property (nonatomic, strong) NSDate *dateOfBirth;</p>

<p>@end
```</p>

<p>而数组中包含如下内容：</p>

<p><code>objc
Smith John 03/01/1984
Andersen Jane 16/03/1979
Clark Anne 13/09/1995
Smith David 19/07/1981
Johnson Rose 22/02/1989
</code></p>

<h3>使用NSComparator进行排序</h3>

<p>comparator实际上是用一个block对象作比较操作。它的定义如下所示：</p>

<p><code>objc
typedef NSComparisonResult (^NSComparator)(id obj1, id obj2);
</code></p>

<p>上面的参数(obj1、obj2)就是我们将要做比较的对象。block返回的结果为NSComparisonResult类型来表示两个对象的顺序。</p>

<p>要对整个数组做排序，则需要使用NSArray的<code>sortArrayUsingComparator:</code>方法，如下代码所示：</p>

<p>```objc
NSArray <em>sortedArray = [self.persons sortedArrayUsingComparator:^NSComparisonResult(Person </em>p1, Person *p2){</p>

<pre><code>return [p1.surname compare:p2.surname];
</code></pre>

<p>}];
```</p>

<p>最终排序的结果如下所示：</p>

<p><code>objc
Andersen Jane
Clark Anne
Johnson Rose
Smith John
Smith David
</code></p>

<h3>使用NSDescriptor进行排序</h3>

<p>Sort descriptor不仅可以用来对数组进行排序，还能指定element在table view中的排序，以及Core Data中对fetch request返回的数据做排序处理。通过sort descriptor可以很方便的对数组进行多个key的排序。下面来看看如何对我们的数组做surname排序，然后在进行name排序：</p>

<p>```objc
NSSortDescriptor <em>firstDescriptor = [[NSSortDescriptor alloc] initWithKey:@&ldquo;surname&rdquo; ascending:YES];
NSSortDescriptor </em>secondDescriptor = [[NSSortDescriptor alloc] initWithKey:@&ldquo;name&rdquo; ascending:YES];</p>

<p>NSArray *sortDescriptors = [NSArray arrayWithObjects:firstDescriptor, secondDescriptor, nil];</p>

<p>NSArray *sortedArray = [self.persons sortedArrayUsingDescriptors:sortDescriptors];
```</p>

<p>上面代码的排序结果如下所示：</p>

<p><code>objc
Andersen Jane
Clark Anne
Johnson Rose
Smith David
Smith John
</code></p>

<h3>使用selector进行排序</h3>

<p>当面，我们也可以定义自己的方法进行两个对象做比较，并将该方法用于数组排序。comparator消息会被发送到数值中的每个对象中，并携带数组中另外的一个对象当做参数。自定义的的方法的返回结果是这样的：如果本身对象小于参数中的对象，就返回<code>NSOrederedAscending</code>，相反，则返回<code>NSOrderedDescending</code>，如果相等，那么返回<code>NSOrderedSame</code>。如下代码所示：</p>

<p>```objc
&ndash; (NSComparisonResult)compare:(Person *)otherPerson {</p>

<pre><code>return [self.dateOfBirth compare:otherPerson.dateOfBirth];
</code></pre>

<p>}
```</p>

<p>这个方法定义在Person类中，用来对person的生日进行排序。</p>

<p>上面所介绍的这些方法都是为了完成相同的事情：对数组做排序处理，你可能在想改选择使用哪个呢？当需要通过多个key进行排序，那么最简单的方法就是使用sort descriptor。如果比较方法很复杂的话，建议在使用外面自己的selector。Block是再iOS 4之后引入的一个强大功能，用block作比较，可以不必使用任何的变量就能完成一个简单的比较方法，当然，你也可以定义一个复杂的block，来替换selector。</p>

<p>最后，其实这里并没有标准答案，你可以跟着自己的感觉走:]</p>
]]></content>
  </entry>
  
</feed>
