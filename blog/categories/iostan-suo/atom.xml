<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS探索 | 破船之家]]></title>
  <link href="http://BeyondVincent.github.io/blog/categories/iostan-suo/atom.xml" rel="self"/>
  <link href="http://BeyondVincent.github.io/"/>
  <updated>2014-03-17T15:05:15+08:00</updated>
  <id>http://BeyondVincent.github.io/</id>
  <author>
    <name><![CDATA[破船(BeyondVincent)]]></name>
    <email><![CDATA[beyondvincent@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在iOS上使用自签名的SSL证书]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/03/17/five-tips-for-using-self-signed-ssl-certificates-with-ios/"/>
    <updated>2014-03-17T14:15:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/03/17/five-tips-for-using-self-signed-ssl-certificates-with-ios</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/03/09.png" alt="" /></p>

<!--more-->


<p>本文译自：<a href="http://blog.httpwatch.com/2013/12/12/five-tips-for-using-self-signed-ssl-certificates-with-ios/">Five Tips for Using Self Signed SSL Certificates with iOS</a></p>

<p>小引：</p>

<p>上周苹果release了iOS 7.1，用户升级至此版本，去下载企业级应用时，如果应用不是用https部署的，那么会提示服务器上的证书无效，如下图所示：</p>

<p><img src="/images/2014/03/11.png" alt="" /></p>

<p>小引:</p>

<p>在iOS 7.1中需要将plists文件的url路径设置为https才能下载安装，如果之前是用http部署的，这就需要对服务器做一些修改。网上流传着(<a href="http://stackoverflow.com/questions/20276907/enterprise-app-deployment-doesnt-work-on-ios-7-1/22325916#22325916">Enterprise app deployment doesn&rsquo;t work on iOS 7.1</a>)把plist放到公开的具有https功能的文件服务器上即可(dropbox或SkyDrive)，经试验，都是可行的。不过如要企业内部的网络无法访问外网，这又如何是好呢？网上也流传需要受信任的证书才行，这样一来对于某些企业的内部部署就比较麻烦了(局域网、主机名变动等都会引起很麻烦的事情)，各区域可能还要用不同的证书(对应不同的host name)。</p>

<p>经查苹果的相关文档(2014年2月份)，是可以使用http或者https的，后来打电话咨询苹果技术支持人员，告知文档还没来得及更新，不过自签名的证书也可以使用，最好首先要把证书(最好是CA根证书)通过mail或者配置工具安装到iOS设备上，然后根据这个CA构建web 服务器上用到的证书，这样当iOS设备访问web服务器来安装app时，就可以正常进行了。这样的话，我们只需要根据不同的服务器制作对应的自签名证书即可，有问题也方便修改跟进。</p>

<p>下面这篇文章就是介绍如何在iOS上面使用自签名的SSL证书。</p>

<p>先来看看目录：</p>

<ol>
<li>在iPhone或者iPad上的Safari中不要接受自签名证书</li>
<li>像安装iOS的Configuration Profile一样安装自签名证书</li>
<li>不要用IIS创建自签名证书</li>
<li>利用OpenSSL创建自签名证书</li>
<li>创建自己的证书颁发机构(CA)</li>
</ol>


<p>虽说SSL证书的购买价格不是太贵，不过有时候我们自行创建的话要更加方便一些，例如我们需要在开发环境配置SSL时、我们的测试服务器有不同的主机名或者开发的系统只有本地局域网才能访问。</p>

<p>实际上我们可以免费的创建<a href="http://en.wikipedia.org/wiki/Self-signed_certificate">自签名SSL证书</a>，并不需要给证书颁发机构(CA)支付任何费用，也不需要遵守任何审计要求。</p>

<p>使用自签名SSL证书的缺点就是浏览器不会自动的信任相关的站点。如果用iPhone或者iPad上的Safari打开相关站点，会看到如下提示界面：</p>

<p><img src="/images/2014/03/01.png" alt="" /></p>

<p>这里的HttpWatch iOS app还会有更详细的提示内容：</p>

<p><img src="/images/2014/03/02.png" alt="" /></p>

<p>本文剩余内容将介绍如何对iOS做配置，以避免上面遇到的问题，以及如何方便的创建和管理自签名证书。</p>

<h2>在iPhone或者iPad上的Safari中不要接受自签名证书</h2>

<p>当在Safari中第一次访问自签名证书的站点时，会有如下提示(Continue或Details->Accept)：</p>

<p><img src="/images/2014/03/03.png" alt="" /></p>

<p>如果你照着选择的话，是可以在Safari中打开站点的，不过这样会有两个明显的缺点：</p>

<ol>
<li>在Safari中接受证书只会添加一个<code>SSL例外</code>：防止Safari对此站点做出的警告提示。实际上并不会将证书安装到iOS中，以成为可信任的证书。同台设备的其它程序在连接该站点时仍然会失败。</li>
<li>一旦将<code>SSL例外</code>添加到iOS 7中了，就无法从iOS 7中移除。在之前的版本还可以通过Settings->Safari，选中"Clear Cookies and Data"进行删除。在iOS 7中这好像没有效果。&mdash;&mdash;&mdash;除非<code>General &gt; Reset &gt; Reset Settings</code>。</li>
</ol>


<p>当然，苹果官方也提供了一个工具<a href="http://support.apple.com/downloads/#iphone%20configuration%20utility">iPhone configuration utility for Mac and PC</a>，通过该工具可以把证书安装至设备中。如果邮件不可用，或者要批量安装的话，这是一个好方法。</p>

<h2>像安装iOS的Configuration Profile一样安装自签名证书</h2>

<p>要想把SSL证书在iOS设备上安装为可信任的，可以通过发邮件到设备上，并将证书以附件的形式带在邮件中：</p>

<p><img src="/images/2014/03/04.png" alt="" /></p>

<p>选择邮件中的附件，以将证书安装至iOS设备中。选择附件之后，选择<code>Install</code>来安装证书。完成安装之后，再在Safari或者其它iOS应用中使用该证书时，就不会有相关提醒了。</p>

<p>并且这与Safari添加的<code>SSL例外</code>有一个很大的区别，你可以在任意时刻通过<code>Settings-&gt;General-&gt;Profiles</code>来查看相关证书，如果有必要的话，还可以将其移除：</p>

<p><img src="/images/2014/03/05.png" alt="" /></p>

<p>当然，苹果也提供了一个工具<a href="http://support.apple.com/downloads/#iphone%20configuration%20utility">iPhone configuration utility for Mac and PC</a>，通过该工具可以把证书安装到设备中，如果邮件不可用，或者要批量安装证书的话，可以用这个工具。</p>

<h2>不要用IIS创建自签名证书</h2>

<p>在IIS中创建自签名证书非常的简单。只需要选择菜单中的<code>Create Self-Signed Certificate</code>即可：</p>

<p><img src="/images/2014/03/06.png" alt="" /></p>

<p>不过IIS简单的使用计算机名称当做证书的主机名：</p>

<p><img src="/images/2014/03/07.png" alt="" /></p>

<p>大多数时候，计算机名称与主机名是不匹配的，这样的话自签名的证书永远都不会受信任——即使已经安装至iOS设备中：</p>

<p><img src="/images/2014/03/08.png" alt="" /></p>

<p>要修复这个问题可以安装并运行IIS 6 Toolkit中的SelfSSL。不过，要是使用OpenSSL则非常简单，下面我们就来看看吧。</p>

<h2>利用OpenSSL创建自签名证书</h2>

<p>创建自签名证书最简单的一种方法就是使用<a href="http://www.openssl.org/related/binaries.html">OpenSSL命令行工具</a>，这个工具在许多平台上面都可以使用，并且在Mac OSX上面是默认安装好了的。</p>

<p>首先，创建一个私钥文件：</p>

<p><code>
openssl genrsa -out myselfsigned.key 2048
</code></p>

<p>然后创建自签名证书：</p>

<p><code>
openssl req -new -x509 -key myselfsigned.key -out myselfsigned.cer -days 365
-subj /CN=www.mysite.com
</code></p>

<p>上面的命令中，关于私钥和证书(cer)的文件名可以是任意的。其中<code>CN</code>参数需要设置为主机名(例如<a href="https://www.mysite.com">https://www.mysite.com</a>)。而<code>days</code>参数则指定证书从创建开始的有效天数。</p>

<p>在Apache服务器上面可以直接使用私钥和证书文件(做相关的SSL配置即可)。在IIS中需要一个PFX文件，通过该文件，可以将证书导入至IIS的Server Certificates中。当然通过OpenSSL可以创建PFX文件：</p>

<p><code>
openssl pkcs12 -export -out myselfsigned.pfx -inkey myselfsigned.key
-in myselfsigned.cer
</code></p>

<h2>创建自己的证书颁发机构(CA)</h2>

<p>使用自签名证书会有这样的问题：需要为每台设备中用到的每个证书设置相关的信任关系。有一个解决办法就是创建自己的证书颁发机构(CA)根证书，然后基于该根证书创建别的证书。</p>

<p>这样一来就是自己扮演着CA，取代了商业性质的CA。这样做的好处就是自己的CA证书只需要在每台设备上安装一次即可。之后，设备会自动的信任基于CA根证书创建的证书。</p>

<p>创建CA证书只需要两个步骤即可，首先是创建私钥文件(跟之前的一样)：</p>

<p><code>
openssl genrsa -out myCA.key 2048
</code></p>

<p>然后是创建证书：</p>

<p><code>
openssl req -x509 -new -key myCA.key -out myCA.cer -days 730
-subj /CN="My Custom CA"
</code></p>

<p>上面创建的证书(myCA.key)可以公开发布出去，并安装在iOS或者其它OS上，以此当做内置的受信任根CA。自制的CA证书存储在<code>General-&gt;Settings-&gt;Profile</code>：</p>

<p><img src="/images/2014/03/10.png" alt="" /></p>

<p>其中私钥文件(myCA.key)只用是再创建新的SSL证书时使用。</p>

<p>上面的CA创建好之后，我们可以基于该证书创建许多证书。注意，这里多了一个步骤：必须创建一个CSR(客户端证书请求文件)——就像购买商业的SSL证书一样。</p>

<p>首先需要创建一个私钥文件：</p>

<p><code>
openssl genrsa -out mycert1.key 2048
</code></p>

<p>然后是创建CSR:</p>

<p><code>
openssl req -new -out mycert1.req -key mycert1.key -subj /CN=www2.mysite.com
</code></p>

<p>接着用这个CSR创建证书：</p>

<p><code>
openssl x509 -req -in mycert1.req -out mycert1.cer -CAkey myCA.key
-CA myCA.cer -days 365 -CAcreateserial -CAserial serial
</code></p>

<p>这里创建的证书(mycert.cer)可以安装在一台web服务器上，并且已经安装了相关CA证书的iOS设备都可以访问该web服务器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7中实现模糊效果]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/29/ios-7-blur-effects-gpuimage/"/>
    <updated>2014-01-29T19:10:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/29/ios-7-blur-effects-gpuimage</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/42.png" alt="" /></p>

<!--more-->


<p>本文译自<a href="http://www.raywenderlich.com/60968/ios-7-blur-effects-gpuimage">iOS 7 Blur Effects with GPUImage</a>。</p>

<p>iOS 7在视觉方面有许多改变，其中非常吸引人的功能之一就是在整个系统中巧妙的使用了模糊效果。许多第三方应用程序已经采用了这样的设计细节，并以各种奇妙的和具有创造性的方式使用它。</p>

<p>本文将通过几种不同的技术来实现iOS 7中的模糊效果，当然，这一切都利用了一个名为<a href="https://github.com/BradLarson/GPUImage">GPUImage</a>的框架。</p>

<p><code>GPUImage</code>是由<a href="http://www.sunsetlakesoftware.com/blog">Brad Larson</a>创建的，它利用GPU，使在图片和视频上应用不同的效果和滤镜变得非常的容易，同时它还拥有出色的性能，并且它的性能要比苹果内置的相关APIs出色。</p>

<p><code>注意：本文需要一台物理设备来编译并运行示例程序(在模拟器上无法使用)。同样还需要一个iOS开发者账号。如果你还没有开发者账号的话，可以来[这里](https://developer.apple.com/)注册一个。注册为开发者之后，会有许多福利哟，例如可以使用物理设备来开发程序，提前获得苹果的相关测试版程序，以及大量的开发资源。</code></p>

<p><img src="/images/2014/01/21.png" alt="iOS中利用GPUImage实现模糊效果" /></p>

<p>下面我们先来看看本文的目录结构：</p>

<ul>
<li>开始</li>
<li>为什么要是用模糊效果

<ul>
<li>深度引导</li>
<li>上下文</li>
<li>关注度</li>
</ul>
</li>
<li>添加静态的模糊效果

<ul>
<li>创建截图Category</li>
<li>利用断点测试截屏图片</li>
<li>显示截屏图片</li>
<li>设置contentsRect</li>
<li>重置模糊滤镜</li>
<li>对其背景图片</li>
</ul>
</li>
<li>实时模糊</li>
<li>线程中简洁的分支</li>
<li>一些潜在的实时模糊方案</li>
<li>一个折中的方法——对视频实时模糊

<ul>
<li>利用GPUImage对视频进行模糊处理</li>
</ul>
</li>
<li>何去何从？</li>
</ul>


<h2>开始</h2>

<p>首先先来<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2013/12/Video-Blurring.zip">这里</a>下载本文的starter工程，并将其解压出来。</p>

<p>用Xcode打开<code>Video Blurring.xcodeproj</code>，并将工程运行到设备中。此时看到程序的效果如下所示：</p>

<p><img src="/images/2014/01/22.png" alt="" /></p>

<p>点击屏幕左上角的<code>菜单</code>(三条横纹)，可以看到界面中出现两个选项：录制视频和播放已有视频。</p>

<p>请注意，现在所有的用户界面都有一个灰色的背景，是不是感觉有点沉闷呢，本文我们就利用iOS 7中的模糊效果来替换掉这些沉闷的灰色背景。</p>

<h2>为什么要是用模糊效果</h2>

<p>除了外观看起来很棒以外，模糊效果还可以让程序给用户带来3个重要的概念：深度引导、上下文和关注度。</p>

<h3>深度引导</h3>

<p>在用户界面上，模糊效果可以给用户提供一个深度引导效果，并且有利于用户对程序导航的理解。在之前的iOS版本中的深度引导效果是通过：三维斜面(three-dimensional bevels)和有关泽的按钮(反映出一个模拟的光源)，而在iOS 7中是通过模糊和视差(<a href="http://en.wikipedia.org/wiki/Parallax">parallax</a>)来实现的。</p>

<p>这里说的视差效果，可以很明显的观察出来：在装有iOS 7的设备中，将设备从一侧倾斜至另一侧，会发现设备中的图标在移动(会独立于背景)。这样可以给用户做出一个提示：界面是由不同的层构成的，并且重要的界面元素是在最前面的——这也涉及到下面将要介绍的一个概念：上下文。</p>

<h3>上下文</h3>

<p>上下文可以让用户在程序内获得一种轴承的感觉。动画的过度效果就提供了一种非常优秀的上下文，当用户点击一个按钮时，在两个view之间利用动画效果来切换画面(而不是直接显示一个新的view)，可以让用户知道新的view是从哪里出现的，并且可以让用户很容易知道如何回到上一个view。</p>

<p>模糊效果可以将上一个view当做背景显示出来，尽管上一个view已经失去焦点了，不过可以给用户提供更多的上下文：刚刚是在哪里。通知中心就是一个非常棒的例子：当拉下通知中心时，我们可以在背景中看到原来的view(即使现在正在处于通知中心界面)。</p>

<h3>关注度</h3>

<p>让界面更加关注于某些选择项上，而移除不需要的内容，让用户可以更加快捷的进行导航。用户可以本能的忽略那些被模糊的界面元素，而将注意力集中到某些界面元素中。</p>

<p>通过本文，你将学到两种模糊类型的实现方法：静态模糊和动态模糊。静态模糊代表着快照的时间点，它并不能反映被模糊界面元素的变化。大多数情况下，使用静态模糊效果就足够了。相反，动态模糊则是对需要模糊的背景做出实时更新。</p>

<p>相信看到具体的效果才是最好的，下面我们就来看看模糊效果的具体实现吧！</p>

<h2>添加静态的模糊效果</h2>

<p>创建一个静态模糊效果首先是将当前屏幕中的view转换为一幅图片。获得图片之后，只需要对图片做模糊处理就可以了。将view转换为一幅图片(截屏)苹果已经提供了一些非常棒的APIs了，并且在iOS 7中又有了新的方法可以让截屏更加快速。</p>

<p>这些新的方法属于<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/uiview_class/uiview/uiview.html#//apple_ref/occ/instm/UIView/drawViewHierarchyInRect:afterScreenUpdates:">截屏APIs</a>中的一部分，截屏APIs不仅可以对某个view截屏，还能把整个view层次截屏，如果你希望对某个view截屏，那么可以把view中的按钮、标签、开关等各种view也进行截屏。</p>

<p>此处我们将截屏的逻辑实现到<code>UIView</code>的一个category中。这样一来，我们就可以很方便快捷的将任意的view(以及view中的内容)转换为一个图片——也算是代码的重用吧。</p>

<h3>创建截图Category</h3>

<p>打开<code>File/New/File...</code>，然后选择<code>iOS/Cocoa Touch/Objective-C category</code>，如下图所示：</p>

<p><img src="/images/2014/01/23.png" alt="" /></p>

<p>将这个category命名为<code>Screenshot</code>，并将它的category选为<code>UIView</code>,如下图所示：</p>

<p><img src="/images/2014/01/24.png" alt="" /></p>

<p>将下面这个方法声明到<code>UIView+Screenshot.h</code>中：</p>

<p><code>objc
-(UIImage *)convertViewToImage;
</code></p>

<p>接着将如下方法添加到<code>UIView+Screenshot.m</code>中：</p>

<p>```objc
&ndash;(UIImage *)convertViewToImage
{</p>

<pre><code>UIGraphicsBeginImageContext(self.bounds.size);
[self drawViewHierarchyInRect:self.bounds afterScreenUpdates:YES];
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();

return image;
</code></pre>

<p>}
```</p>

<p>上面的方法中，首先调用了<code>UIGraphicsBeginImageContext()</code>，最后调用的是<code>UIGraphicsEndImageContext()</code>，这两行代码可以理解为图形上下文的一个事物处理过程。一个上下文可以理解为不同的概念，例如屏幕，或者此处可以理解为一幅图片。这里的两行代码起到一个离屏画布的作用——可以将view绘制上去。</p>

<p><code>drawViewHierarchyInRect:afterScreenUpdates:</code>方法利用view层次结构并将其绘制到当前的上下文中。</p>

<p>最后，<code>UIGraphicsGetImageFromCurrentImageContext()</code>从图形上下文中获取刚刚生成的<code>UIImage</code>。</p>

<p>现在，我们已经完成了category的实现，接着我们只需要在使用到的地方将其import一下即可。</p>

<p>如下代码所示，将代码添加到<code>DropDownMenuController.m</code>顶部：</p>

<p>```objc</p>

<h1>import &ldquo;UIView+Screenshot.h&rdquo;</h1>

<p>```</p>

<p>同时，将如下方法添加到相同的文件中：</p>

<p>```objc
&ndash;(void)updateBlur
{</p>

<pre><code>UIImage *image = [self.view.superview convertViewToImage];
</code></pre>

<p>}
```</p>

<p>上面的代码确保是对superview进行截屏，而不仅仅是当前的view。不这样做的话，截屏获得的图片只是menu本身。</p>

<h3>利用断点测试截屏图片</h3>

<p>为了测试截屏的效果，我们在<code>convertViewToImage</code>调用的下面一行添加一个断点。这样当命中断点时，程序会在断点中暂停执行，这样我们就可以看到截屏的图片，以此确保截屏代码的正确性:</p>

<p><img src="/images/2014/01/25.png" alt="" /></p>

<p>在测试之前还有一件事情需要做：调用上面这个方法。</p>

<p>找到<code>show</code>方法，并在<code>addToParentViewController</code>下面直接调用一下<code>updateBlur</code>：</p>

<p>```objc
&ndash;(void)show {</p>

<pre><code>[self addToParentViewController];

[self updateBlur]; // Add this line

CGRect deviceSize = [UIScreen mainScreen].bounds;

[UIView animateWithDuration:0.25f animations:^(void){
    _blurView.frame = CGRectMake(0, 0, deviceSize.size.height, MENUSIZE);
    _backgroundView.frame = CGRectMake(0, 0, _backgroundView.frame.size.width, MENUSIZE);
}];
</code></pre>

<p>}
```</p>

<p>编译并运行程序，点击菜单按钮，可以看到Xcode在断点出停止了，如下所示：</p>

<p><img src="/images/2014/01/26.png" alt="" /></p>

<p>在debugger左下角hand pane中选择<code>image</code>，然后单击<code>快速查找图标</code>按钮，就可以预览刚刚的截屏啦：</p>

<p><img src="/images/2014/01/27.png" alt="" /></p>

<p>如上图所示，正是我们所预期的。</p>

<h3>显示截屏图片</h3>

<p>将截取到的图片显示到菜单的背景中就是小菜一碟啦。</p>

<p>一般来说我们都会利用<code>UIImageView</code>来显示一幅图片，而由于我们要利用<code>GPUImage</code>来模糊图片，所以需要使用<code>GPUImageView</code>。</p>

<p>在这里的工程中，已经添加好了<code>GPUImage</code>框架，我们只需要将头文件import一下即可。</p>

<p>将下面的代码添加到<code>DropDownMenuController.m</code>顶部：</p>

<p>```objc</p>

<h1>import &lt;GPUImage/GPUImage.h></h1>

<p>```</p>

<p><code>注意：GPUImage被包含在一个框架中，所以在import语句中，需要利用尖括弧，而不是双引号</code>。</p>

<p>此时，有一个_blurView，类型为UIView——是菜单的灰色背景。将UIView修改为<code>GPUImageView</code>，如下所示：</p>

<p>```objc
@implementation DropDownMenuController {</p>

<pre><code>GPUImageView *_blurView;
UIView *_backgroundView;
</code></pre>

<p>}
```</p>

<p>修改之后，Xcode会报一个warning：大意是你利用<code>UIView</code>进行实例化，而不是预期的<code>GPUImageView</code>。</p>

<p>可以通过下面的方法消除这个警告，在<code>viewDidLad</code>中修改做如下修改：</p>

<p><code>objc
_blurView = [[GPUImageView alloc] initWithFrame:CGRectMake(0, 0, deviceSize.size.height, 0)];
</code></p>

<p>紧随其后，将如下两行代码添加进去，并移除设置背景色的代码：</p>

<p><code>objc
_blurView.clipsToBounds = YES;
_blurView.layer.contentsGravity = kCAGravityTop;
</code></p>

<p><code>clipToBounds</code>属性设置为YES，把超出_blurView范围的子view隐藏起来，而<code>contentsGravity</code>确保图片出现在image view的顶部。</p>

<p>由于<code>_blurView</code>已经用于背景了，所以此处不需要额外设置了。</p>

<p>接着，我们还需要声明一个用于模糊效果的过滤器。</p>

<p>将如下代码添加到<code>DropDownMenuController.m:</code>文件的<code>@implementation</code>中：</p>

<p><code>objc
GPUImageiOSBlurFilter *_blurFilter;
</code></p>

<p>找到之前添加的断点，右键单击，并选中<code>Delete Breakpoint</code>：</p>

<p><img src="/images/2014/01/28.png" alt="" /></p>

<p>下面是非常重要的一步了——初始化模糊滤镜。将如下代码添加到<code>DropDownMenuController.m</code>中：</p>

<p>```objc
&ndash;(void)updateBlur
{</p>

<pre><code>if(_blurFilter == nil){
    _blurFilter = [[GPUImageiOSBlurFilter alloc] init];
     _blurFilter.blurRadiusInPixels = 1.0f;

}

UIImage *image = [self.view.superview convertViewToImage];
</code></pre>

<p>}
```</p>

<p><code>注意：上面将模糊半径设置为一个像素，这里暂时将这个值设置低一点，这样可以确保图片的正确定位，当一切ok之后，再增加模糊半径即可。</code></p>

<p>下面是时候将图片显示到<code>GPUImageView</code>中了。不过并不是简单的实例化一个<code>UIImage</code>，并将其添加到<code>GPUImageView</code>中。首先需创建一个<code>GPUImagePicture</code>。</p>

<p>将如下代码添加到<code>updateBlur</code>方法的底部：</p>

<p><code>objc
GPUImagePicture *picture = [[GPUImagePicture alloc] initWithImage:image];
</code></p>

<p>至此，我们获得了一个图片，模糊滤镜和iamge view。</p>

<p>接着再将如下代码添加到<code>updateBlur</code>底部：</p>

<p>```objc
[picture addTarget:<em>blurFilter];
[</em>blurFilter addTarget:_blurView];</p>

<p>[picture processImage];
```</p>

<p>上面这几行代码，就像胶水一样，将所有的事情关联起来。将滤镜当做target添加到图片中，然后将image view当做滤镜的target。</p>

<p>上面代码对图片的处理全程发生在GPU上，也就是说当进行模糊计算和显示时，并不会影响到用户界面。当处理结束时，会把图片显示到image view上面。</p>

<p>编译并运行程序，点击菜单按钮，可以看到如下类似画面：</p>

<p><img src="/images/2014/01/29.png" alt="" /></p>

<p>上面的图片看起来是不是有点奇怪？看到的图片被缩放到适配到菜单视图中了。要对此做出修正，我们需要指定图片的哪一部分需要显示在<code>GPUImageView</code>中——也就是处理截屏视图的上半部分。</p>

<h3>设置contentsRect</h3>

<p>按照如下代码所示修改<code>DropDownMenuController.m</code>文件中的<code>show</code>方法：</p>

<p>```objc
&ndash;(void)show
{</p>

<pre><code>[self addToParentViewController];

[self updateBlur];

CGRect deviceSize = [UIScreen mainScreen].bounds;

[UIView animateWithDuration:0.25f animations:^(void){
    _blurView.frame = CGRectMake(0.0f, 0.0f, deviceSize.size.height, MENUSIZE);
    _backgroundView.frame = CGRectMake(0.0f, 0.0f, _backgroundView.frame.size.width, MENUSIZE);
    _blurView.layer.contentsRect = CGRectMake(0.0f, 0.0f, 1.0f, MENUSIZE / 320.0f); // Add this line!
}];
</code></pre>

<p>}
```</p>

<p>通过指定<code>_blurView.layer.contentsRect</code>来定义一个矩形，在单元坐标空间(unit coordinate space)中，表示只使用layer content的一部分。</p>

<p>编译并运行程序，点击菜单按钮，会看到如下图所示效果：</p>

<p><img src="/images/2014/01/30.png" alt="" /></p>

<p>虽然已经使用了图片的一部分，看起来还是不正确，这是因为它的缩放比例还不适合！此处还缺少对正确内容的缩放。</p>

<p>将下面这行代码添加到<code>show</code>方法中动画block的尾部：</p>

<p><code>objc
_blurView.layer.contentsScale = (MENUSIZE / 320.0f) * 2;
</code></p>

<p><code>contentsScale</code>属性声明了layer在逻辑坐标空间(以点为单位)和物理坐标空间(以像素为单位)之间的映射关系。更高比例因子表示在渲染layer时，一个点代表着多个像素点。</p>

<p>编译并运行程序，点击菜单按钮，可以看到缩放比例已经正常了：</p>

<p><img src="/images/2014/01/31.png" alt="" /></p>

<p>没错——看起来好多了！现在关闭程序，然后重新打开，ou~~发生了什么？如下图所示：</p>

<p><img src="/images/2014/01/32.png" alt="" /></p>

<p>看起来这还是有点问题。如果在对view进行animation之前将contentScale设置回2.0，会解决half bar的问题。</p>

<p>将如下代码添加到<code>DropDownMenuController.m</code>中<code>show</code>方法里面的animation block上面：</p>

<p><code>objc
_blurView.layer.contentsScale = 2.0f;
</code></p>

<p>编译并运行程序，然后点击菜单，接着关闭菜单，再打开菜单，此时菜单开起来如下所示：</p>

<p><img src="/images/2014/01/33.png" alt="" /></p>

<p>现在半个尺寸的黑色box已经没有问题了——但是现在是全尺寸的黑色box！</p>

<h3>重置模糊滤镜</h3>

<p>上面问题产生的原因是由于进行了二次模糊计算。解决的方法是移除模糊滤镜中的所有target。如果不这样做的话，之后对滤镜的调用不会输出任何的内容——进而引起黑色box的问题。</p>

<p>按照如下代码更新一下<code>updateBlur</code>方法：</p>

<p>```objc
&ndash;(void)updateBlur
{</p>

<pre><code>if(_blurFilter == nil){
    _blurFilter = [[GPUImageiOSBlurFilter alloc] init];
    _blurFilter.blurRadiusInPixels = 1.0f;
}

UIImage *image = [self.view.superview convertViewToImage];

GPUImagePicture *picture = [[GPUImagePicture alloc] initWithImage:image];
[picture addTarget:_blurFilter];
[_blurFilter addTarget:_blurView];

[picture processImageWithCompletionHandler:^{
    [_blurFilter removeAllTargets];
}];
</code></pre>

<p>}
```</p>

<p>上面的代码用<code>processImageWithCompletionHandler:</code>替换了<code>processImage</code>方法。这个新的方法有一个completion block，当image 处理结束时，会运行这个block。一旦image处理结束，我们就可以安全的将滤镜中的target全部移除。</p>

<p>编译并运行程序，点击菜单，检查一下黑色box问题是不是已经解决掉了：</p>

<p><img src="/images/2014/01/34.png" alt="" /></p>

<p>多次打开和关闭菜单，确保之前的那个bug已经解决掉啦！</p>

<p>现在仔细观察一下打开菜单的模糊效果——有些东西看起来不正确。为了更加明显的观察到问题，我们减慢动画的时间，让其慢慢的移动。</p>

<p>在<code>show</code>方法中，将animation bloc的持续时间修改为10.0f。</p>

<p>编译并运行程序，点击菜单，然后观察一下菜单出场的慢动作：</p>

<p><img src="/images/2014/01/35.png" alt="" /></p>

<p>恩，现在可能你已经发现问题了。被模糊的图片从顶部往下滑动——而我们的本意是希望模糊效果从上往下滑(并不是图片本身)。</p>

<h3>对其背景图片</h3>

<p>此处我们需要对静态模糊效果使用一些技巧。当出现菜单时，我们需要利用背景来将模糊效果对其。所以在这里我们不是对image view做移动处理，而是需要对image view做扩展处理，从0开始扩展至image view的全尺寸。这样就可以确保菜单打开时，图片依然保留在原位。</p>

<p>在<code>show</code>方法中，我们已经将菜单打开至全尺寸了，所以现在只需要将<code>contentRect</code>的高度设置为0即可(当image view首次创建并隐藏的时候)。</p>

<p>将下面的代码添加至<code>DropDownMenuController.m</code>文件的<code>viewDidLoad</code>方法中——在_blurView初始化的下方：</p>

<p><code>objc
_blurView.layer.contentsRect = CGRectMake(0.0f, 0.0f, 1.0f, 0.0f);
</code></p>

<p>同时，在相同的一个文件中，将下面的代码添加到animation block的尾部：</p>

<p><code>objc
_blurView.layer.contentsRect = CGRectMake(0.0f, 0.0f, 1.0f, 0.0f);
</code></p>

<p><code>contentRect</code>属性是可以动画方式设置的。因此在动画期间会rect会自动的插补上。</p>

<p>编译并运行程序。可以看到，问题已经解决：</p>

<p><img src="/images/2014/01/36.png" alt="" /></p>

<p>这样看起来自然多了。现在我们已经有一个具有模糊背景的滑动菜单了。</p>

<p>现在是时候把动画所需时间调整一下了（为了更好的效果，其实之前设置的值是为了测试所用）：设置为0.25秒，接着在<code>updateBlur</code>方法中将<code>_blurFilter.blurRadiusInPixels</code>设置为<code>4.0f</code>。</p>

<p>编译并运行程序，多次打开菜单，看看效果如何：</p>

<p><img src="/images/2014/01/37.png" alt="" /></p>

<h2>实时模糊</h2>

<p>实时模糊涉及到的技术具有一定的难度，有些难点需要解决才行。为了有效的进行实时模糊，我们需要不停(每秒60帧)的截屏、模糊计算和显示。使用<code>GPUImage</code>每秒中处理60张图片(模糊并显示图片)一点问题都没有。</p>

<p>真正棘手的问题是什么呢？如何实时的截取屏幕图片，信不信由你！</p>

<p>由于截取的屏幕是主用户界面，所有必须使用CPU的主线程来截屏，并将其转换为一幅图片。</p>

<p><code>提醒：如果事物每秒钟的变化速度在46帧以上，那么人眼就无法识别出来了。这对于开发者来说也是一种解脱——现代处理器在各帧之间可以完成更多的大量工作。</code></p>

<h2>线程中简洁的分支</h2>

<p>当运行程序时，会执行大量的指令列表。每一个指令列表都运行在各自的线程中，而我们又可以在多个线程中并发运行各自的指令列表。一个程序在主线程中开始运行，然后会根据需要，创建新的线程，并在后台执行线程。如果之前你并没有管理过多线程，你可能在写程序的时候总是在主线程中执行指令。</p>

<p>主线程主要处理与用户的交互，以及界面的更新。确保主线程的响应时间是非常关键的。如果在主线程上做了太多的任务，你会明显的感觉到主界面响应迟钝。</p>

<p>如果你曾经使用过Twitter货Facebook，并滚动操作过它里面的内容，你可能已经感觉到后台线程在执行操作了——在滚动的过程中，并不是所有的个人图片立即显示出来，滚动过程中，程序会启动后台线程来获取图片，当图片获取成功之后，再显示到屏幕中。</p>

<p>如果不使用后台线程，那么table view的滚动过程中，如果在主线程上去获取个人图片，会感觉到table view被冻结住了。由于图片的获取需要一些时间，所以最好将这样耗时的操作让后台线程来做，这样就能对用户界面做平滑的操作和响应了。</p>

<p>那么对本文的程序有什么影响呢？之间介绍了，<code>UIView</code>的截屏APIs操作必须在主线程中运行。这就意味着每次截屏时，整个用户界面都会被冻结中。</p>

<p>对于静态模糊效果时，由于这个截屏操作很快，你不会感觉到界面的冻结。并且只需要截屏一次。然而在实时模糊效果中需要每秒中截屏60次。如果在主线程中做这样频繁的截屏操作，那么animation和transition会变得非常的迟钝。</p>

<p>更糟糕的时，如果用户界面复杂度增加，那么在截屏过程中就需要消耗更多的时间，那么就会导致整个程序无法使用了！</p>

<p>那么怎么办呢！</p>

<h2>一些潜在的实时模糊方案</h2>

<p>这里有一个关于实时模糊方案：源代码开源的<a href="https://github.com/nicklockwood/FXBlurView">live blur libraries</a>，它通过降低截屏的速度来实现实时模糊效果，并不是使用每秒截屏60次，可能是20、30或者40次。即使看起来没有多大区别，但是你的眼睛还是能发现一定的迟钝——模糊效果并没有跟程序的其它部分同步起来——这样一来，界面看起会没有模糊效果更加的糟糕。</p>

<p>实际上苹果在它们自己的一些程序中处理实时模糊并不存在类似的问题——但是苹果并没有公开相关的API。在iOS 7中<code>UIView</code>的截屏方法，相比于旧方法，性能有了很大的提升，但还是不能满足实时模糊的需求。</p>

<p>一些开发者利用<code>UIToolbar</code>的模糊效果来做一些不好的操作。没错，这是有效果的，但是强烈建议不要在程序中使用它们。虽然这不是私有API，但是这并不算是一种可行的方法，苹果也可能会<a href="https://github.com/JagCesar/iOS-blur/issues/25">reject</a>你的程序。也就是说在，在之后的iOS 7版本中，并不能保证还能正常使用。</p>

<p>苹果可以在任何时候对<code>UIToolBar</code>做出修改，或许你的程序就有问题了。在iOS 7.0.3更新中，苹果的修改已经影响到UIToolbar和UINavigationBar了，有些开发者也因此报告出利用相关模糊效果已经失效了！所以最好不要陷入这样潜在的陷阱里面！</p>

<h2>一个折中的方法——对视频实时模糊</h2>

<p>OK，此时你可能在想，要想在程序中做到实时模糊是不可能的了。那么还有什么方法可以突破限制，做到实时模糊效果呢？</p>

<p>在许多场景中，静态模糊是可以接受的。上一节中，我们对view做适当的修改，让用户看起来是对背景图做的实际模糊处理。当然，这对于静止不动的背景是合适的，并且还可以在模糊背景上实现一些不错的效果。</p>

<p>我们可以做一些实验，看看能不能找到一些效果来实现之前无法做到的实时模糊效果呢？</p>

<p>有一个方法可以试试：对实时视频做模糊处理，虽然截屏是一个非常大的瓶颈，但是<code>GPUImage</code>非常的强大，它能够对视频进行模糊(无论是来自摄像头的视频或者已经录制好的视频，都没问题)。</p>

<h3>利用GPUImage对视频进行模糊处理</h3>

<p>利用<code>GPUImage</code>对视频的模糊处理与图片的模糊处理类似。针对图片，我们实例化一个<code>GPUImagePicture</code>，然后将其发送给<code>GPUImageiOSBlurFilter</code>，接着再将其发送给<code>GPUImageView</code>。</p>

<p>类似的方法，对于视频，我们使用<code>GPUImageVideoCamera</code>或<code>GPUImageMovie</code>，将后将其发送给<code>GPUImageiOSBlurFilter</code>，接着再将其发送给一个<code>GPUImageView</code>。<code>GPUImageVideoCamera</code>用于设备中的实时摄像头，而<code>GPUImageMovie</code>用于已经录制好的视频。</p>

<p>在我们的starter工程中，已经实例化并配置好了<code>GPUImageVideoCamera</code>。现在的任务是将播放和录制按钮的灰色背景替换为视频的实时滤镜效果。</p>

<p>首先是将此处提供的灰色背景实例<code>UIView</code>替换为<code>GPUImageView</code>。完成之后，我们需要调整每个view的<code>contentRect</code>(基于view的frame)。</p>

<p>这听起来对每个view都需要做大量的工作。为了让任务变得简单，我们创建一个<code>GPUImageView</code>的子类，并把自定义的代码放进去，以便重用。</p>

<p>打开<code>File/New/File…</code>，然后选择<code>iOS/Cocoa Touch/Objective-C class</code>，如下所示：</p>

<p><img src="/images/2014/01/38.png" alt="" /></p>

<p>将类命名为<code>BlurView</code>，继承自<code>GPUImageView</code>，如下图所示：</p>

<p><img src="/images/2014/01/39.png" alt="" /></p>

<p>打开<code>ViewController.m</code>文件，将下面的import添加到文件顶部：</p>

<p>```objc</p>

<h1>import &ldquo;BlurView.h&rdquo;</h1>

<p>```</p>

<p>还是在<code>ViewController.m</code>中，在<code>@implementation</code>中找到<code>_recordView</code>和<code>_controlView</code>的声明，将其修改为<code>BlurView</code>类型，如下所示：</p>

<p>```objc
BlurView <em>_recordView; //Update this!
UIButton </em><em>recordButton;
BOOL </em>recording;</p>

<p>BlurView <em>_controlView; //Update this too!
UIButton </em><em>controlButton;
BOOL </em>playing;
```</p>

<p>然后按照如下代码修改<code>viewDidLoad</code>方法：</p>

<p>```objc</p>

<pre><code>_recordView = [[BlurView alloc] initWithFrame:
                CGRectMake(self.view.frame.size.height/2 - 50, 250, 110, 60)]; //Update this!
//_recordView.backgroundColor = [UIColor grayColor]; //Delete this!

_recordButton = [UIButton buttonWithType:UIButtonTypeCustom];
_recordButton.frame = CGRectMake(5, 5, 100, 50);
[_recordButton setTitle:@"Record" forState:UIControlStateNormal];
[_recordButton setTitleColor:[UIColor redColor] forState:UIControlStateNormal];
[_recordButton setImage:[UIImage imageNamed:@"RecordDot.png"] forState:UIControlStateNormal] ;
[_recordButton addTarget:self 
                  action:@selector(recordVideo) 
        forControlEvents:UIControlEventTouchUpInside];

[_recordView addSubview:_recordButton];
_recording = NO;

_recordView.hidden = YES;
[self.view addSubview:_recordView];


_controlView = [[BlurView alloc] initWithFrame:
                 CGRectMake(self.view.frame.size.height/2 - 40, 230, 80, 80)]; //Update this!
//_controlView.backgroundColor = [UIColor grayColor]; //Delete this!
</code></pre>

<p>```</p>

<p>接着，需要创建模糊图片，将其显示到上面构建的image view中。回到<code>@implementation</code>中，将下面的两个声明添加进去：</p>

<p><code>objc
GPUImageiOSBlurFilter *_blurFilter;
GPUImageBuffer *_videoBuffer;
</code></p>

<p>现在你已经知道<code>GPUImageiOSBlurFilter</code>的作用了，那么<code>GPUImageBuffer</code>的作用是什么呢？它的任务是获取视频的输出，并获取每一帧，这样我们就可以方便的对其做模糊处理。一个额外的好处就是它可以提升程序的性能！</p>

<p>一般来说，视频输出的内容会通过模糊滤镜处理，然后发送到背景视图中(被显示出来)。不过，在这里使用buffer的话，发送到buffer的视频输出内容，会被分为背景视图和模糊滤镜。这样可以对视频的输出显示做到平滑处理。</p>

<p>将下面的代码添加到<code>viewDidLoad</code>方法的顶部(在super调用的后面)：</p>

<p>```objc
_blurFilter = [[GPUImageiOSBlurFilter alloc] init];</p>

<p><em>videoBuffer = [[GPUImageBuffer alloc] init];
[</em>videoBuffer setBufferSize:1];
```</p>

<p>还是在同一个文件中，将如下高亮显示的语句添加到<code>useLiveCamera</code>方法中：</p>

<p>```objc
&ndash;(void)useLiveCamera
{</p>

<pre><code>if (![UIImagePickerController isSourceTypeAvailable: UIImagePickerControllerSourceTypeCamera]) {
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"No camera detected" 
                                                    message:@"The current device has no camera" 
                                                   delegate:self 
                                          cancelButtonTitle:@"Ok" 
                                          otherButtonTitles:nil];
    [alert show];
    return;
}

_liveVideo = [[GPUImageVideoCamera alloc] initWithSessionPreset:AVCaptureSessionPreset1280x720
                                                 cameraPosition:AVCaptureDevicePositionBack];
_liveVideo.outputImageOrientation = UIInterfaceOrientationLandscapeLeft;

[_liveVideo addTarget:_videoBuffer];           //Update this
[_videoBuffer addTarget:_backgroundImageView]; //Add this
[_videoBuffer addTarget:_blurFilter];          //And this
[_blurFilter addTarget:_recordView];           //And finally this

[_liveVideo startCameraCapture];

_recordView.hidden = NO;
_controlView.hidden = YES;
</code></pre>

<p>}
```
上面的模糊背景是用于录制按钮的。对于播放按钮也要做类似的处理。</p>

<p>将下面的代码添加到<code>loadVideoWithURL:</code>方法中(在<code>_recordedVideo.playAtActualSpeed = YES;</code>之后)：</p>

<p><code>objc
[_recordedVideo addTarget:_videoBuffer];
[_videoBuffer addTarget:_backgroundImageView];
[_videoBuffer addTarget:_blurFilter];
[_blurFilter addTarget:_controlView];
</code></p>

<p>编译并运行程序，打开录制操作，看看情况如何：</p>

<p><img src="/images/2014/01/40.png" alt="" /></p>

<p>好消息是看起来基本正常！坏消息是整个屏幕被缩放到录制按钮中去了。这个问题跟之前遇到的类似。我们需要给<code>BlurView</code>这是适当的<code>contentRect</code>。</p>

<p>打开<code>BlurView.m</code>，用下面的代码替换掉<code>initWithFrame:</code>方法：</p>

<p>```objc
&ndash; (id)initWithFrame:(CGRect)frame
{</p>

<pre><code>self = [super initWithFrame:frame];
if (self) {
    CGRect deviceSize = [UIScreen mainScreen].bounds;
    self.layer.contentsRect = CGRectMake(frame.origin.x/deviceSize.size.height, 
                                         frame.origin.y/deviceSize.size.width, 
                                         frame.size.width/deviceSize.size.height, 
                                         frame.size.height/deviceSize.size.width);
    self.fillMode = kGPUImageFillModeStretch;
}
return self;
</code></pre>

<p>}
```</p>

<p><code>contentRect</code>的每个参数必须在<code>0.0f</code>和<code>1.0f</code>之间。在这里只需要利用view的位置除以屏幕的size，得到的值即可。</p>

<p>编译并运行程序，看看效果如何：</p>

<p><img src="/images/2014/01/41.png" alt="" /></p>

<p>恭喜！至此已经完成了静态模糊和实时视频模糊的实现。现在你已经完全可以在程序中添加iOS 7的模糊效果啦！</p>

<h2>何去何从？</h2>

<p>可以在<a href="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/Video-Blurring-Final1.zip">这里</a>下载到完整的工程。</p>

<p>本文不仅指导你在程序中使用iOS 7的模糊效果，还介绍了如何使用<code>GPUImage</code>框架，这个框架也是我非常希望你能看到的东西。重要的是，本文指出了为什么要使用模糊，什么时候使用模糊效果是合适的，这在iOS 7的新设计语言中是一个关键的概念。当然也希望在未来的版本中，苹果能够将相关APIs提供给开发者使用，不过在那之前，<code>GPUImage</code>是一个不错的替代品。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对NSArray中自定义的对象进行排序]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/26/how-to-sort-nsarray-with-custom-objects/"/>
    <updated>2014-01-26T16:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/26/how-to-sort-nsarray-with-custom-objects</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/20.png" alt="" /></p>

<!--more-->


<p>本文译自<a href="http://ios-blog.co.uk/tutorials/how-to-sort-nsarray-with-custom-objects/">How to sort NSArray with custom objects</a>。</p>

<p>我们开发的每个程序都会使用到一些数据，而这些数据一般被封装在一个自定义的类中。例如一个音乐程序可能会有一个Song类，聊天程序则又一个Friend类，点菜程序会有一个Recipe类等。有时候我们希望在程序中显示的列表数据是按照一定顺序进行排列的，本文我们就来看看在iOS中有哪些方法可以对NSArray中的对象进行排序。下面是目录：</p>

<ul>
<li>小引</li>
<li>使用NSComparator进行排序</li>
<li>使用NSDescriptor进行排序</li>
<li>使用selector进行排序</li>
</ul>


<h3>小引</h3>

<p>我们将要排序的对象是一个Persion类，如下定义：</p>

<p>```objc
@interface Person : NSObject</p>

<p>@property (nonatomic, copy) NSString <em>name;
@property (nonatomic, copy) NSString </em>surname;
@property (nonatomic, strong) NSDate *dateOfBirth;</p>

<p>@end
```</p>

<p>而数组中包含如下内容：</p>

<p><code>objc
Smith John 03/01/1984
Andersen Jane 16/03/1979
Clark Anne 13/09/1995
Smith David 19/07/1981
Johnson Rose 22/02/1989
</code></p>

<h3>使用NSComparator进行排序</h3>

<p>comparator实际上是用一个block对象作比较操作。它的定义如下所示：</p>

<p><code>objc
typedef NSComparisonResult (^NSComparator)(id obj1, id obj2);
</code></p>

<p>上面的参数(obj1、obj2)就是我们将要做比较的对象。block返回的结果为NSComparisonResult类型来表示两个对象的顺序。</p>

<p>要对整个数组做排序，则需要使用NSArray的<code>sortArrayUsingComparator:</code>方法，如下代码所示：</p>

<p>```objc
NSArray <em>sortedArray = [self.persons sortedArrayUsingComparator:^NSComparisonResult(Person </em>p1, Person *p2){</p>

<pre><code>return [p1.surname compare:p2.surname];
</code></pre>

<p>}];
```</p>

<p>最终排序的结果如下所示：</p>

<p><code>objc
Andersen Jane
Clark Anne
Johnson Rose
Smith John
Smith David
</code></p>

<h3>使用NSDescriptor进行排序</h3>

<p>Sort descriptor不仅可以用来对数组进行排序，还能指定element在table view中的排序，以及Core Data中对fetch request返回的数据做排序处理。通过sort descriptor可以很方便的对数组进行多个key的排序。下面来看看如何对我们的数组做surname排序，然后在进行name排序：</p>

<p>```objc
NSSortDescriptor <em>firstDescriptor = [[NSSortDescriptor alloc] initWithKey:@&ldquo;surname&rdquo; ascending:YES];
NSSortDescriptor </em>secondDescriptor = [[NSSortDescriptor alloc] initWithKey:@&ldquo;name&rdquo; ascending:YES];</p>

<p>NSArray *sortDescriptors = [NSArray arrayWithObjects:firstDescriptor, secondDescriptor, nil];</p>

<p>NSArray *sortedArray = [self.persons sortedArrayUsingDescriptors:sortDescriptors];
```</p>

<p>上面代码的排序结果如下所示：</p>

<p><code>objc
Andersen Jane
Clark Anne
Johnson Rose
Smith David
Smith John
</code></p>

<h3>使用selector进行排序</h3>

<p>当面，我们也可以定义自己的方法进行两个对象做比较，并将该方法用于数组排序。comparator消息会被发送到数值中的每个对象中，并携带数组中另外的一个对象当做参数。自定义的的方法的返回结果是这样的：如果本身对象小于参数中的对象，就返回<code>NSOrederedAscending</code>，相反，则返回<code>NSOrderedDescending</code>，如果相等，那么返回<code>NSOrderedSame</code>。如下代码所示：</p>

<p>```objc
&ndash; (NSComparisonResult)compare:(Person *)otherPerson {</p>

<pre><code>return [self.dateOfBirth compare:otherPerson.dateOfBirth];
</code></pre>

<p>}
```</p>

<p>这个方法定义在Person类中，用来对person的生日进行排序。</p>

<p>上面所介绍的这些方法都是为了完成相同的事情：对数组做排序处理，你可能在想改选择使用哪个呢？当需要通过多个key进行排序，那么最简单的方法就是使用sort descriptor。如果比较方法很复杂的话，建议在使用外面自己的selector。Block是再iOS 4之后引入的一个强大功能，用block作比较，可以不必使用任何的变量就能完成一个简单的比较方法，当然，你也可以定义一个复杂的block，来替换selector。</p>

<p>最后，其实这里并没有标准答案，你可以跟着自己的感觉走:]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C中的Literals]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/23/guided-tour-through-objective-c-literals/"/>
    <updated>2014-01-23T15:30:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/23/guided-tour-through-objective-c-literals</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/19.png" alt="" /></p>

<!--more-->


<p>本文译自<a href="http://www.thinkandbuild.it/guided-tour-through-objective-c-literals/">Guided tour through Objective-C Literals</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker">twitter</a>上联系原作者，当然也可以在最后的评论中回复我。</p>

<p>苹果在2012年就已经把Literals加入到LLVM中，利用Literals，不仅可以方便快捷的创建某些特定数据类型，还可以简化代码量，加强代码的可读性。</p>

<p>下面先来看看目录：</p>

<ol>
<li>NSNumber</li>
<li>NSArray</li>
<li>NSDictionary</li>
<li>Expressions</li>
</ol>


<p>下面我们就让代码来说话吧。</p>

<h3>1. NSNumber</h3>

<p>曾经你是否一直这样来实例化<code>NSNumber</code>：</p>

<p><code>objc
NSNumber *integer = [NSNumber numberWithInt:19];
</code></p>

<p>是不是感觉比较麻烦，现在好了，通过Literal，只需要如下一行简洁的代码即可：</p>

<p><code>objc
NSNumber *integer = @19
</code></p>

<p>在上面的代码中，使用了<code>@</code>符号，这跟创建NSString一样(只是不用双引号吧了)，这样一来，就非常容易记住和使用啦。</p>

<p>不仅如此，我们还可以利用C语言中的后缀风格来定义NSNumber，如下代码所示：</p>

<p><code>objc
NSNumber *unsignedInteger = @19U;   //Unsigned Integer
NSNumber *longInteger = @19L;       //Long Integer
NSNumber *floatNumber = @19.5493F;  //Float
 
NSNumber *boolean = @YES; //        //BOOL
</code></p>

<h3>2. NSArray</h3>

<p>有些编程语言创建数组是非常简单的，例如PHP。但是在引入Literal之前，Objective-C中创建数组的语法确不简单。如下代码所示：</p>

<p><code>objc
NSArray *array = [NSArray arrayWithObjects: [NSNumber numberWithInt:10],
                                            @"A String!",
                                            [NSNumber numberWithFloat:10.654F],
                                             nil];
</code></p>

<p>上面代码中不仅初始化对象复杂，还需要额外添加一个nil。但是要用Literal，看起来完全不一样了：</p>

<p><code>objc
NSArray *array_l = @[@10, @"A string", @10.645F];
</code></p>

<p>如上所示，利用Literal，可以通过<code>@[]</code>轻松的搞定数组初始化，并且省掉最后的<code>nil</code>。实际上编译器会把上面的代码替换为<code>[NSArray arrayWithObjects:count:]</code>。</p>

<p>在Literal之前，访问数组中的对象需要使用一个类似这样的方法<code>objectAtIndex</code>：</p>

<p><code>objc
id obj = [array objectAtIndex:0];
</code></p>

<p>而来到Literal的世界中，可以使用一对方括弧<code>[]</code>加对象对应的索引就可以访问到了：</p>

<p><code>objc
id obj = array[0];
</code></p>

<p>通过上面的语法，我们可以按照下面的方法来修改可变数组中的值：</p>

<p><code>objc
NSMutableArray *mutableArray = [NSMutableArray arrayWithObject:@[@11,@76]];
mutableArray[0] = @51;
</code></p>

<h3>3. NSDictionary</h3>

<p>在Literal引入之前，NSDictionary对象的实例化跟NSArray类似，看起来也很长，并且在最后需要<code>nil</code>，如下代码所示：</p>

<p><code>objc
NSDictionary *dict = [NSDictionary dictionaryWithObjects:[NSArray arrayWithObjects: [NSNumber numberWithInt:10],
                                                                                    [NSNumber numberWithInt:20],
                                                                                    [NSNumber numberWithInt:30],
                                                                                    nil]
                                                 forKeys:[NSArray arrayWithObjects: @"first",
                                                                                    @"second",
                                                                                    @"third",
                                                                                    nil]];
</code></p>

<p>上面的代码看起来着实有点过头了。如果要用Literal的话，就简洁明了多了：</p>

<p><code>objc
NSDictionary *dicts = @{@"first":@10, @"second":@20, @"third":@30};
</code></p>

<p>在上面NSDictionary实例化过程中，通过Literal，除了可以定义NSNumber和NSArray之外，还可以以可读的方式一一放置key和对应的值。相信这种方法大家都会喜欢。</p>

<p>从上面的介绍，你应该会喜欢上Literal，它确实可以让我们的代码更加容易读懂，并且不容易出错！！！</p>

<p>另外，我们还可以通过下面这样的方式访问字典中key对应的内容：(感谢<a href="http://weibo.com/u/2135198615">@谌启亮</a>在评论中的提醒)</p>

<p><code>objc
NSString *firstValue = dicts[@"first"]
</code></p>

<p>// 注意：下面这一点内容我摘自<a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">Objective-C-Literals-Boxed Expressions</a></p>

<h3>4. Expressions</h3>

<p>Objective-C提供了一种新的语法对C表达式进行包装：<code>@( &lt;expression&gt; )</code></p>

<p>它支持标量表达式(numeric, enumerated, BOOL)，以及C字符串指针类型：</p>

<p>```objc
// numbers.
NSNumber <em>smallestInt = @(-INT_MAX &ndash; 1);  // [NSNumber numberWithInt:(-INT_MAX &ndash; 1)]
NSNumber </em>piOverTwo = @(M_PI / 2);        // [NSNumber numberWithDouble:(M_PI / 2)]</p>

<p>// enumerated types.
typedef enum { Red, Green, Blue } Color;
NSNumber *favoriteColor = @(Green);       // [NSNumber numberWithInt:((int)Green)]</p>

<p>// strings.
NSString <em>path = @(getenv(&ldquo;PATH&rdquo;));       // [NSString stringWithUTF8String:(getenv(&ldquo;PATH&rdquo;))]
NSArray </em>pathComponents = [path componentsSeparatedByString:@&ldquo;:&rdquo;];
```</p>

<p>关于Literals的更多详细内容可以参考：<a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">Objective-C-Literals</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何自定义iOS中的控件]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/20/how-to-build-a-custom-control-in-ios/"/>
    <updated>2014-01-20T17:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/20/how-to-build-a-custom-control-in-ios</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/18.png" alt="" /></p>

<!--more-->


<p>本文译自<a href="http://www.thinkandbuild.it/how-to-build-a-custom-control-in-ios/">How to build a custom control in iOS</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker">twitter</a>上联系原作者，当然也可以在最后的评论中回复我。</p>

<p>下面先来看看目录：</p>

<ol>
<li>子类化UIControl

<ul>
<li>绘制用户界面

<ul>
<li>绘制背景</li>
<li>绘制用户的可操作区域</li>
<li>绘制手柄</li>
</ul>
</li>
<li>跟踪用户的操作

<ul>
<li>开始跟踪</li>
<li>持续跟踪</li>
<li>结束跟踪</li>
</ul>
</li>
<li>Target-Action模式</li>
</ul>
</li>
<li>如何使用自定义控件</li>
<li>总结</li>
<li>代码下载</li>
</ol>


<p>在开发过程中，有时候UIKit的标准控件并不能满足我们的需求，例如你需要一个控件能支持用户方便的选择0-360°之间的一个角度值，此时就需要根据自己的需求自定义控件了。</p>

<p>对于选择角度值的控件可以这样实现：创建一个圆形的滑块，用户通过拖动手柄操作就能选择角度值。实际上这样的控件在别的一些平台中你可能看到过，但是在UIKit中并没有。</p>

<p>本文就实现一个选择角度值的控件来介绍控件的自定义。下面先来看看到底要做成什么样子：</p>

<p><img src="/images/2014/01/12.png" alt="" /></p>

<h3>1. 子类化UIControl</h3>

<p><code>UIControl</code>是UIView的子类，它又是所有UIKit控件的父类(例如UIButton、UISlider和UISwitch等)。</p>

<p>UIControl的主要作用是创建相应的逻辑将action分发到对应的target，另外90%的情况下，它会根据自身的状态(例如Highlighted, Selected和Disabled等)来绘制用户界面。</p>

<p>通过UIControl，我们主要管理3个重要的任务：</p>

<ul>
<li>绘制用户界面</li>
<li>跟踪用户的操作</li>
<li>Target-Action模式</li>
</ul>


<p>在本文的圆形滑块中，我们要做如下一些事情：</p>

<p>定制一个用户界面(圆形滑块本身)，通过该界面用户可以通过手柄进行界面交互。用户的交互操作会被转换为控件target对应的action(控件将滑块按钮的frame origin转换为0-360之间的一个值，并用于target/action上)。</p>

<p>建议在学习本文的时候从文章尾部的连接中下载完整的示例工程。</p>

<p>下面我将从上面列出的3个重要任务一一进行分解介绍。</p>

<p>这些步骤都是模块化的，所以如果你对界面的绘制不感兴趣，可以跳过<code>绘制用户界面</code>，直接学习后面的步骤。</p>

<p>打开工程文件中的<code>TBCircluarSlider.m</code>文件。然后开始学习下面的内容。</p>

<h4>1.1 绘制用户界面</h4>

<p>我比较喜欢使用Core Graphics，唯一用到UIKit的就是通过textfield来显示滑块的值。</p>

<p><code>提醒</code>：此处需要用到一些<code>Core Graphics</code>知识，如果你不懂也没多大关系，我会尽量把代码做详细的讲解。</p>

<p>我们先来看看控件的不同组成部分，这样更有利于后面的学习。</p>

<p>首先，是用一个<code>黑色的圆环</code>当做滑块的背景。</p>

<p><img src="/images/2014/01/13.png" alt="" /></p>

<p><code>可操作区域(active area)</code>是一个从蓝色到紫色的梯度渐变效果。</p>

<p><img src="/images/2014/01/14.png" alt="" /></p>

<p>用户通过拖拽下面的这个手柄按钮来选择值：</p>

<p><img src="/images/2014/01/15.png" alt="" /></p>

<p>最后，用于显示选中值的<code>TextField</code>。在下一版中，我计划让用户可以通过键盘输入角度值。</p>

<p><img src="/images/2014/01/16.png" alt="" /></p>

<p>控件界面的绘制主要使用drawRect函数，首选我们需要获取到当前使用的图形上下文，如下代码所示：</p>

<p><code>objc
CGContextRef ctx = UIGraphicsGetCurrentContext();
</code></p>

<h5>1.1.1 绘制背景</h5>

<p>背景是360°的，所以只要用CGContextAddArc给图形上下文添加正确的path，并设置正确的stroke即可。</p>

<p>下面的代码可以就可以完成背景的绘制：</p>

<p>```objc
//Add the arc path
CGContextAddArc(ctx, self.frame.size.width/2, self.frame.size.height/2, radius, 0, M_PI *2, 0);</p>

<p>//Set the stroke colour
[[UIColor blackColor]setStroke];</p>

<p>//set Line width and cap
CGContextSetLineWidth(ctx, TB_BACKGROUND_WIDTH);
CGContextSetLineCap(ctx, kCGLineCapButt);</p>

<p>//draw it!
CGContextDrawPath(ctx, kCGPathStroke);
```</p>

<p><code>CGContextArc</code>函数的参数包括图形上下文，弧度的中心坐标点，以及半径(是一个私有变量)，接着是弧度开始和结束时的角度(在TBCircularSlider.m文件的头部可以看到一些关于数学计算的方法)，最后一个参数标示绘制的方向，0表示逆时针方向。</p>

<p>接下来的3行的代码是用来设置一些信息的，例如颜色和线条宽度等。最后使用<code>CGContextDrawPath</code>方法完成背景的绘制。</p>

<h5>1.1.2 绘制用户的可操作区域</h5>

<p>这部分需要利用一点小技巧才行。此处我们绘制一个线性渐变的掩码图片，下面看看原理：</p>

<p><img src="/images/2014/01/17.png" alt="" /></p>

<p>此处掩码图片的工作原理是可以看到原始渐变矩形框的一个孔。</p>

<p>在这里绘制的弧度有一个阴影，这是创建掩码图时使用了一点模糊的效果。</p>

<p>下面是创建掩码图的相关代码：</p>

<p><code>objc
UIGraphicsBeginImageContext(CGSizeMake(320,320));
CGContextRef imageCtx = UIGraphicsGetCurrentContext();
 
CGContextAddArc(imageCtx, self.frame.size.width/2  , self.frame.size.height/2, radius, 0, ToRad(self.angle), 0);
[[UIColor redColor]set];
 
//Use shadow to create the Blur effect
CGContextSetShadowWithColor(imageCtx, CGSizeMake(0, 0), self.angle/20, [UIColor blackColor].CGColor);
 
//define the path
CGContextSetLineWidth(imageCtx, TB_LINE_WIDTH);
CGContextDrawPath(imageCtx, kCGPathStroke);
 
//save the context content into the image mask
CGImageRef mask = CGBitmapContextCreateImage(UIGraphicsGetCurrentContext());
UIGraphicsEndImageContext();
</code></p>

<p>在上面的代码中首先创建了一个图形上下文，然后设置了一下阴影。通过<code>CGContextSetShadowWithColor</code>方法，我们可以设置如下内容：</p>

<ul>
<li>上下文</li>
<li>偏移量(此处不需要)</li>
<li>模糊值(该值是通过参数控制的：使用当前的角度除以20，当用户与此控件交互时，以此获得一个简单的动画模糊值)</li>
<li>颜色</li>
</ul>


<p>接着是根据当前的角度绘制一个相应的弧度。</p>

<p>例如，如果当前的角度变量是360°，那么就绘制一个圆弧，如果是90°，就绘制一个弧度为90°的一个弧。最后，利用<code>CGBitmapContextCreateImage</code>方法获取一张图片（刚刚绘制的弧）。这个图片就是我们所需要的掩码图了。</p>

<p>裁剪上下文：</p>

<p>现在我们已经有一个渐变的掩码图了。接着利用函数<code>CGContextClipToMask</code>对上下文进行裁剪——给该函数传入上面刚刚创建好的掩码图。代码如下所示：</p>

<p><code>objc
CGContextClipToMask(ctx, self.bounds, mask);
</code></p>

<p>最后我们来绘制渐变效果，代码如下所示：</p>

<p><code>objc
//Define the colour steps
CGFloat components[8] = {
    0.0, 0.0, 1.0, 1.0,     // Start color - Blue
    1.0, 0.0, 1.0, 1.0 };   // End color - Violet
 
CGColorSpaceRef baseSpace = CGColorSpaceCreateDeviceRGB();
CGGradientRef gradient = CGGradientCreateWithColorComponents(baseSpace, components, NULL, 2);
 
//Define the gradient direction
CGPoint startPoint = CGPointMake(CGRectGetMidX(rect), CGRectGetMinY(rect));
CGPoint endPoint = CGPointMake(CGRectGetMidX(rect), CGRectGetMaxY(rect));
 
    //Choose a colour space
CGColorSpaceRelease(baseSpace), baseSpace = NULL;   
 
//Create and Draw the gradient
CGContextDrawLinearGradient(ctx, gradient, startPoint, endPoint, 0);
CGGradientRelease(gradient), gradient = NULL;
</code></p>

<p>绘制渐变效果需要很多处理，不过我们可以将其分为4部分：</p>

<ul>
<li>定义颜色的变化范围</li>
<li>定义渐变的方向</li>
<li>选择颜色空间</li>
<li>创建并绘制渐变</li>
</ul>


<p>最终的显示效果(看到渐变矩形框的一部分)要归功于之前创建的掩码图。</p>

<p>另外，为了在背景边框模拟光线反射，我添加了一些灯光效果。</p>

<h5>1.1.3 绘制手柄</h5>

<p>下面我们根据当前的角度值，在的正确位置绘制出手柄。</p>

<p>实际上，在绘制过程中，这一步非常简单，复杂一点的就是计算一下手柄所在的位置。</p>

<p>这里我们需要使用三角函数将一个<code>标量值(scalar number)</code>转换为<code>CGPoint</code>。不要担心有多复杂，只需要使用Sin和Cos函数就可以完成。代码如下所示：</p>

<p><code>objc
-(CGPoint)pointFromAngle:(int)angleInt{
     
    //Define the Circle center
    CGPoint centerPoint = CGPointMake(self.frame.size.width/2 - TB_LINE_WIDTH/2, self.frame.size.height/2 - TB_LINE_WIDTH/2);
     
    //Define The point position on the circumference
    CGPoint result;
    result.y = round(centerPoint.y + radius * sin(ToRad(-angleInt))) ;
    result.x = round(centerPoint.x + radius * cos(ToRad(-angleInt)));
     
    return result;
}
</code></p>

<p>上面的代码中，指定一个角度值，然后计算出在圆周上面的位置，当然，这里需要圆周的中心点和半径。</p>

<p>使用sin函数在使用sin函数时，需要一个Y坐标值，而cos函数则需要X坐标值。</p>

<p>需要注意的是此处每个函数返回的值都认为半径为1，所以需要将所得结果乘以我们指定的半径大小，并相对于圆周的中心做计算。</p>

<p>希望下面的公式对你的理解有所帮助：</p>

<p><code>objc
point.y = center.y + (radius * sin(angle));
point.x = center.x + (radius * cos(angle));
</code></p>

<p>通过上面的计算，现在我们已经知道手柄的具体位置了，所以，接下来就直接将手柄绘制到指定位置即可，如下代码所示：</p>

<p><code>objc
-(void) drawTheHandle:(CGContextRef)ctx{
     
    CGContextSaveGState(ctx);
     
    //I Love shadows
    CGContextSetShadowWithColor(ctx, CGSizeMake(0, 0), 3, [UIColor blackColor].CGColor);
     
    //Get the handle position!
    CGPoint handleCenter =  [self pointFromAngle: self.angle];
     
    //Draw It!
    [[UIColor colorWithWhite:1.0 alpha:0.7]set];
    CGContextFillEllipseInRect(ctx, CGRectMake(handleCenter.x, handleCenter.y, TB_LINE_WIDTH, TB_LINE_WIDTH));
     
    CGContextRestoreGState(ctx);
}
</code></p>

<p>具体操作步骤如下：</p>

<ul>
<li>保存当前的上下文(当在一个单独的函数中进行绘制任务时，将上下文的状态进行保存是编程的一个好习惯)。</li>
<li>给手柄设置一些阴影效果</li>
<li>定义手柄的颜色，然后利用<code>CGContextFillEllipseInRect</code>将其绘制出来。</li>
</ul>


<p>我们在drawRect函数的最后调用上面这个方法：</p>

<p><code>objc
[self drawTheHandle:ctx];
</code></p>

<p>至此，我们就完成了绘制部分的任务。</p>

<h4>1.2 跟踪用户的操作</h4>

<p>在UIControl的子类中，我们可以<code>override</code>3个特殊的方法来提供一个自定义的跟踪行为</p>

<h5>1.2.1 开始跟踪</h5>

<p>当在控件的bound内发生了一个触摸事件，首先会调用控件的<code>beginTrackingWithTouch</code>方法。</p>

<p>我们就看看如何<code>override</code>这个方法吧：</p>

<p><code>objc
-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{
    [super beginTrackingWithTouch:touch withEvent:event];
 
    //We need to track continuously
    return YES;
}
</code></p>

<p>该函数返回的BOOl值决定着：当触摸事件是dragged时，是否需要响应。在我们这里的自定义控件中，是需要跟踪用户的dragging，所以返回YES。</p>

<p>上面这个函数有两个参数：touch对象和事件。</p>

<h5>1.2.2 持续跟踪</h5>

<p>在上一个方法中我们指定了这里的自定义控件需要跟踪一个持续的事件，所以当用户进行drag时，会调用一个特殊的方法：<code>continueTrackingWithTouch</code>：</p>

<p><code>objc
-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event
</code></p>

<p>该方法返回的BOOL值标示是否继续跟踪touch事件。</p>

<p>通过该方法我们可以根据touch位置对用户的操作进行过滤。例如，我们可以：仅当touch位置与手柄位置相交的时候才激活控件(activate control)。不过在这里我们的控制逻辑并不是这样的，我们希望用户点击任何位置都能对手柄做出相应的位置处理。</p>

<p>本文的该方法负责更新手柄的位置(在后面的一节中会看到我们把该位置信息传递给对应的target上)。</p>

<p>对上面这个方法的override代码如下所示：</p>

<p><code>objc
-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{
    [super continueTrackingWithTouch:touch withEvent:event];
 
    //Get touch location
    CGPoint lastPoint = [touch locationInView:self];
 
    //Use the location to design the Handle
    [self movehandle:lastPoint];
 
        //We'll see this function in the next section:
    [self sendActionsForControlEvents:UIControlEventValueChanged];
 
    return YES;
}
</code></p>

<p>上面的代码中，首先利用<code>locationInView</code>获取到touch的位置，然后将该位置传递给<code>moveHandle</code>方法，该方法会将传入的值转换为一个有效的手柄位置(a valid handle position)。</p>

<p>此处“a valid position”的意思是什么呢？</p>

<p>此控件的手柄只能在背景圆弧定义的边界范围内做移动，但是我们不希望强制要求用户必须在很小的圆弧内才可以移动手柄，如果非要这样的话，用户体验会非常的糟糕。</p>

<p><code>moveHandle</code>的任务就是负责把任意的位置值转变为手柄可移动的值，另外，另外，在该函数中，还对指定的滑块角度值做了转换，代码如下所示：</p>

<p><code>objc
-(void)movehandle:(CGPoint)lastPoint{
     
    //Get the center
    CGPoint centerPoint = CGPointMake(self.frame.size.width/2,
                                                                            self.frame.size.height/2);
     
    //Calculate the direction from the center point to an arbitrary position.
    float currentAngle = AngleFromNorth(centerPoint,
                                                                                lastPoint,
                                                                                NO);
    int angleInt = floor(currentAngle);
     
    //Store the new angle
    self.angle = 360 - angleInt;
 
    //Update the textfield
    _textField.text =  [NSString stringWithFormat:@"%d",
                                                                                                    self.angle];
     
    //Redraw
    [self setNeedsDisplay];
}
</code></p>

<p>上面代码中，实际上主要任务都是在<code>AngleFromNorth</code>方法中处理的：根据两个point，就会返回一个连接这两点对应的一个角度关系，<code>AngleFromNorth</code>方法的实现如下所示：</p>

<p><code>objc
static inline float AngleFromNorth(CGPoint p1, CGPoint p2, BOOL flipped) {
    CGPoint v = CGPointMake(p2.x-p1.x,p2.y-p1.y);
    float vmag = sqrt(SQR(v.x) + SQR(v.y)), result = 0;
    v.x /= vmag;
    v.y /= vmag;
    double radians = atan2(v.y,v.x);
    result = ToDeg(radians);
    return (result &gt;=0  ? result : result + 360.0);
}
</code></p>

<p>提醒：<code>angleFromNorth</code>方法并不是我的原创，我是直接从苹果提供的OSX示例clockControl中拿过来用的。</p>

<p>在上面的代码中，获得了角度值以后，将其存储到<code>angle</code>中，然后更新一下textfield的值。</p>

<p>接着调用的<code>setNeedDisplay</code>是为了确保<code>drawRect</code>被调用，以尽快在界面上做出相应的更新。</p>

<h5>1.2.3 结束跟踪</h5>

<p>当跟踪结束的时候，会调用下面这个方法：</p>

<p><code>objc
-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{
    [super endTrackingWithTouch:touch withEvent:event];
}
</code></p>

<p>在本文中，我们并不需要override该方法。如果当用户完成控件的界面操作时，你希望做一些处理，那么该方法会非常有用。</p>

<h4>1.3 Target-Action模式</h4>

<p>至此，圆形滑块控件可以工作了，你可以drag手柄，并能看到textfield中值的改变。</p>

<p>发送action——控件事件</p>

<p>如果希望自己定制的控件与UIControl行为保持一致，那么当控件的值发生变化时，需要进行通知处理：使用<code>sendActionsForControlEvents</code>方法，并制定特定的事件类型，值改变对应的事件一般是<code>UIControlEventValueChanged</code>。</p>

<p>苹果已经预定义了许多事件类型(Xcode中，在UIControlEventValueChanged上<code>cmd + 鼠标单击</code>)。如果你的控件是继承自UITextField，那么你可能会对<code>UIControlEventEdigitingDidBegin</code>感兴趣，如果你要做一个touch Up action，那么可以使用UIControlTouchUpInside。</p>

<p>如果你注意的话，在本文前部分的continueTrackingWithTouch方法里面，我们调用了<code>sendActionsForControlEvents</code>方法：</p>

<p><code>objc
[self sendActionsForControlEvents:UIControlEventValueChanged];
</code></p>

<p>这样处理之后，当控件值发生变化时，每一个对象(观察者——注册该事件)都会收到响应的通知。</p>

<h3>2. 如何使用自定义控件</h3>

<p>到这里，我们的控件定制完毕，下面介绍如何在程序中使用自定义的控件。</p>

<p>打开文件<code>TBViewController.m</code>，看看<code>viewDidLoad</code>方法里面的代码：</p>

<p><code>objc
- (void)viewDidLoad
{
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor colorWithRed:0.1 green:0.1 blue:0.1 alpha:1];
     
    //Create the Circular Slider
    TBCircularSlider *slider = [[TBCircularSlider alloc]initWithFrame:CGRectMake(0, 60, TB_SLIDER_SIZE, TB_SLIDER_SIZE)];
     
    //Define Target-Action behaviour
    [slider addTarget:self action:@selector(newValue:) forControlEvents:UIControlEventValueChanged];
     
    [self.view addSubview:slider];
}
</code></p>

<p>在上面的代码中，给view设置了一个背景色，并通过调用<code>initWithFrame</code>方法实例化了一个圆形滑块(自定义的控件)。</p>

<p>注意：UIControl继承自UIView，所以它继承了UIView的所有方法。</p>

<p>接着定义了如何与该控件进行交互：使用<code>addTarget:action:forControlEvent:</code>方法。</p>

<p>该方法只是给控件的特定事件设置一下target-action。如果你还记得的话，上面层介绍过，每当用户移动手柄时，圆形滑块都会发送一个UIControlEventValueChanged事件。所以我们可以通过下面的代码为该事件注册一个action：</p>

<p><code>objc
[slider addTarget:self action:@selector(newValue:) forControlEvents:UIControlEventValueChanged];
</code></p>

<p>这样我们就可以创建一个<code>**newValue**</code>方法来处理值发生改变时的一些事情：</p>

<p><code>objc
-(void)newValue:(TBCircularSlider*)slider{
    NSLog(@"Slider Value %d",slider.angle);
}
</code></p>

<p>结合Target-Action，所以函数会受到action的发送者，此处是slider，通过这个slider，就能直接获取到角度值。</p>

<h3>3. 总结</h3>

<p>根据本文的具体步骤，你可以构建<code>任意你想要的控件</code>。</p>

<p>当然，也有其它一些方法来构建自定控件，不过本文基本上是按照苹果的建议来做的。</p>

<p>点击下图，下载代码</p>

<h3>4. 代码下载</h3>

<p><a href="https://github.com/ariok/TB_CircularSlider"><img src="/images/2013/11/34.jpg" alt="" /></a></p>

<p>本文由破船译自<a href="http://www.thinkandbuild.it/how-to-build-a-custom-control-in-ios/">How to build a custom control in iOS</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker">twitter</a>上联系原作者，当然也可以在下面的评论中回复我。</p>
]]></content>
  </entry>
  
</feed>
