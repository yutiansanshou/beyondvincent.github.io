
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>破船之家</title>
	<meta name="author" content="破船(BeyondVincent)">

	
	<meta name="description" content="Jul 8th, 2013 iOS, iOS翻译 初识block 本文由破船译自rypress转载请注明出处！ 小引 本周末微博上朋友发了一个关于block的MV，只能说老外太逗了。大家也可以去看看怎么回事： Cocoa Got Blocks。虽然之前也有接触过block， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="破船之家" type="application/atom+xml">
	
	<link rel="canonical" href="http://BeyondVincent.github.io/blog/page/5/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='http://www.gravatar.com/avatar/" + MD5("beyondvincent@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">破船之家</a></h1>
<p class="subtitle">宠辱不惊，闲看庭前花开花落<br>去留无意，漫随天外云卷云舒<br>不妄取，不妄予，不妄想，不妄求<br>与人方便，随遇而安</p>
<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
  <li><a href="/about">关于我</a></li>
</ul>
</nav>
欢迎关注我的微信公众账号<br>
<div align=center><img width="100" height="100" src="http://beyondvincent.com/images/2013/12/qrcode_bv.jpg"></div>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/beyondvincent" title="Weibo">Weibo</a>
		
		
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-07-08T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jul 8<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>, <a class='category' href='/blog/categories/iosfan-yi/'>iOS翻译</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/07/08/98/" itemprop="url">初识block</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>本文由<strong><span style="color: #339966;">破船</span></strong>译自<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://rypress.com/tutorials/objective-c/blocks.html" target="_blank"><span style="color: #339966; text-decoration: underline;">rypress</span></a></span></span></strong>转载请注明出处！</p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>本周末微博上朋友发了一个关于block的MV，只能说老外太逗了。大家也可以去看看怎么回事：<a href="http://blog.bignerdranch.com/3001-cocoa-got-blocks/" target="_blank"> <strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;">Cocoa Got Blocks</span></span></strong></a>。虽然之前也有接触过block，不过没有深入完整的学习过，借此机会来学习一下，顺便翻译几篇block相关的文章，本文是第一篇，算是block的入门。本文的最后延伸阅读给出了4篇相关文章，不出意外的话，本周大家能看到对应的中文版。</p>


		
		<a href="/blog/2013/07/08/98/" class="more-link">继续阅读 &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-07-05T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jul 5<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>, <a class='category' href='/blog/categories/iosfan-yi/'>iOS翻译</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/07/05/97/" itemprop="url">打造轻量化的View Controller</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/JC4Yc.png"><img class="alignnone size-full wp-image-1538" alt="JC4Yc" src="http://beyondvincent.com/wp-content/uploads/2013/07/JC4Yc.png" width="800" height="322" /></a></p>

<p>&nbsp;</p>

<p>本文由<strong><span style="color: #339966;">破船</span></strong>译自<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://www.objc.io/issue-1/lighter-view-controllers.html" target="_blank"><span style="color: #339966; text-decoration: underline;">objc</span></a></span></strong></span>转载请注明出处！</p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>很早以前就看到了这篇文章，该文是<strong><span style="color: #339966;">Lighter View Controllers</span></strong>中比较重要的一篇，来自<strong><span style="color: #339966;"><a href="http://www.objc.io/%EF%BC%8C">http://www.objc.io/%EF%BC%8C</a></span></strong>该站点的目标是致力于介绍Objective-C中最佳的实践技能和高级技术，以期刊的形式发表，每期一个主题，第一期就是以Lighter View Controllers为主。共有5篇文章，由于老破船精力有限，可能不会全部翻译，感兴趣的读者可以前往官方站点，进行阅读，千万别苦等破船进港时，万一等到花谢草枯了，可不好哟。</p>

<p><strong><span style="color: #339966;">友情提醒</span></strong>：大家平常除了写代码，会有锻炼身体吗？明天就是周末了，记得少加班，多锻炼身体哟，这周我只打了一次篮球，运动量有点少了，计划明天早上去跑10公里。</p>

<h2><span style="color: #ff0000;"><strong>本文目录如下：</strong></span></h2>

<ul>
<li><strong><span style="color: #339966;">简介</span></strong></li>
<li><strong><span style="color: #339966;">剥离Data Source和其它Protocols</span></strong></li>
<li><strong><span style="color: #339966;">将业务逻辑移至Model Layer</span></strong></li>
<li><strong><span style="color: #339966;">创建Store类</span></strong></li>
<li><strong><span style="color: #339966;">将Web Service逻辑移至Model Layer</span></strong></li>
<li><strong><span style="color: #339966;">将View代码移至View Layer</span></strong></li>
<li><strong><span style="color: #339966;">与别的对象进行通讯</span></strong></li>
<li><strong><span style="color: #339966;">小结</span></strong></li>
<li><strong><span style="color: #339966;">延伸阅读</span></strong></li>
</ul>


<h2><strong><span style="color: #339966;">简介</span></strong></h2>

<p>在iOS工程中，view controllers经常是最大的文件，引起这样的主要原因是开发者在view controllers中编写了大量非必须代码，实际上，view controllers可以重用其中的许多代码。下面我们就来看看，有什么好的办法可以对view controllers进行瘦身，加强代码的可重用性(reusable)，并将代码放到适当的地方。<br/>
提醒：本文涉及到的<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="https://github.com/objcio/issue-1-lighter-view-controllers" target="_blank"><span style="color: #339966; text-decoration: underline;">示例工程</span></a></span></strong></span>已经放到GitHub上了。</p>

<h2><strong><span style="color: #339966;">剥离Data Source和其它Protocols</span></strong></h2>

<p>对view controllers瘦身最佳的方法之一就是将UITableViewDataSource涉及到的代码从view controllers中抽取出来，并封装到自己的一个类中。如果不止在一个view controllers中使用到UITableViewDataSource，那么会提高封装出来这个类的可重用性。<br/>
译者注：此处有一个前提条件原作者没有说明，我们需要注意一下——这里的view controllers是使用到了UITableView。</p>

<p>下面我们来看一个例子，在上面给出的示例工程中，有一个类PhotosViewController，里面原本有如下3个方法：</p>

<pre class="wp-code-highlight prettyprint linenums:1"># pragma mark Pragma

- (Photo*)photoAtIndexPath:(NSIndexPath*)indexPath {
return photos[(NSUInteger)indexPath.row];
}

- (NSInteger)tableView:(UITableView*)tableView
numberOfRowsInSection:(NSInteger)section {
return photos.count;
}

- (UITableViewCell*)tableView:(UITableView*)tableView
cellForRowAtIndexPath:(NSIndexPath*)indexPath {
PhotoCell* cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier
forIndexPath:indexPath];
Photo* photo = [self photoAtIndexPath:indexPath];
cell.label.text = photo.name;
return cell;
}</pre>


<p>上面3个方法中都涉及到了数组，并且在最后一个方法中利用索引(indexPatha)给UITableViewCell指定了相应的图片(view controllers管理着这些图片资源)。下面我们就来试着把与数组相关的代码封装到我们自己的<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="https://github.com/objcio/issue-1-lighter-view-controllers/blob/master/PhotoData/ArrayDataSource.h" target="_blank"><span style="color: #339966; text-decoration: underline;">一个类</span></a></span></span></strong>中。<br/>
如下代码所示，这里通过一个block来配置UITableViewCell，当然，也可以使用delegate对UITableViewCell进行配置，这主要取决于开发者。</p>

<pre class="wp-code-highlight prettyprint linenums:1">@implementation ArrayDataSource

- (id)itemAtIndexPath:(NSIndexPath*)indexPath {
return items[(NSUInteger)indexPath.row];
}

- (NSInteger)tableView:(UITableView*)tableView
numberOfRowsInSection:(NSInteger)section {
return items.count;
}

- (UITableViewCell*)tableView:(UITableView*)tableView
cellForRowAtIndexPath:(NSIndexPath*)indexPath {
id cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier
forIndexPath:indexPath];
id item = [self itemAtIndexPath:indexPath];
configureCellBlock(cell,item);
return cell;
}

@end</pre>


<p>有了上面这个自定义的类，我们就可以把view controllers中的那3个方法移除掉，并创建自定义类的一个示例对象，然后将其设置为table view的data source，如下代码所示。</p>

<pre class="wp-code-highlight prettyprint linenums:1">void (^configureCell)(PhotoCell*, Photo*) = ^(PhotoCell* cell, Photo* photo) {
cell.label.text = photo.name;
};
photosArrayDataSource = [[ArrayDataSource alloc] initWithItems:photos
cellIdentifier:PhotoCellIdentifier
configureCellBlock:configureCell];
self.tableView.dataSource = photosArrayDataSource;</pre>


<p>现在，当每次希望将数组中的内容显示到table view中时，不必再考虑如何将index path映射到数组中的准确位置了，只需要重新上面的代码即可。另外，我们也可以在自定义类中，实现另外的一些方法(例如tableView:commitEditingStyle:forRowAtIndexPath:)，以共享给所有的table view controllers。</p>

<p>这也会带来一个好处：可以单独的对自定义的这个类进行测试，而不用担心要重新写一些测试代码。其实，如果我们写的代码跟这里的情况类似，那么也可以这样做。</p>

<p>今年我在工作中写的一个应用程序，大量使用了Core Data。我也创建了类似的类。该类实现了动画更新的所有逻辑，section header处理，以及相关删除操作等。你可以创建该类的一个示例，然后设置一下对其调用的方法，以及配置cell的一个block，剩下的任务就能自动处理了。</p>

<p>此外，上面介绍的这种方法可以延伸到别的protocols，这能够给程序开发中带来很大的灵活性。例如UICollectionViewDataSource，在开发过程中，如果希望用UICollectionView替换已有的UITableView，我们几乎不需要对view controllers做很大的改动，甚至还能使我们的data source同时支持两种protocols(UITableViewDataSource和UICollectionViewDataSource)。</p>

<h2><strong><span style="color: #339966;">将业务逻辑移至Model Layer</span></strong></h2>

<p>下面的示例代码(另外一个工程)位于view controller，作用是找出针对用户active priority的一个列表。</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)loadPriorities {
NSDate* now = [NSDate date];
NSString* formatString = @"startDate &lt;= %@ AND endDate &gt;= %@";
NSPredicate* predicate = [NSPredicate predicateWithFormat:formatString, now, now];
NSSet* priorities = [self.user.priorities filteredSetUsingPredicate:predicate];
self.priorities = [priorities allObjects];
}</pre>


<p>实际上，如果把这个方法移至User类的一个category中，会让代码更加清晰。此时，在View Controller.m文件中看起来应该是这样的：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)loadPriorities {
self.priorities = [user currentPriorities];
}

而在User+Extensions.m中则如下代码：
- (NSArray*)currentPriorities {
NSDate* now = [NSDate date];
NSString* formatString = @"startDate &lt;= %@ AND endDate &gt;= %@";
NSPredicate* predicate = [NSPredicate predicateWithFormat:formatString, now, now];
return [[self.priorities filteredSetUsingPredicate:predicate] allObjects];
}</pre>


<p>实际开发中，有一些代码很难将其移至model对象中，但是，很明显这些代码与model是相关的，针对这样的情况，我们可以单独为其写一个类，例如下面的store类。</p>

<h2><strong><span style="color: #339966;">创建Store类</span></strong></h2>

<p>本文给出示例工程的第一版代码中，有一部分代码是用来从文件中加载数据，并对其进行解析的，这些代码是在view controller中：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)readArchive {
NSBundle* bundle = [NSBundle bundleForClass:[self class]];
NSURL *archiveURL = [bundle URLForResource:@"photodata"
withExtension:@"bin"];
NSAssert(archiveURL != nil, @"Unable to find archive in bundle.");
NSData *data = [NSData dataWithContentsOfURL:archiveURL
options:0
error:NULL];
NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
_users = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@"users"];
_photos = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@"photos"];
[unarchiver finishDecoding];
}</pre>


<p>实际上，view controller不应该关心这些事情的。在示例工程中，我创建了一个Store类来做这些事情——通过将这些代码从view controller中剥离出来，不仅可以对其重用和单独测试，另外还能对view controller瘦身。Store类专注于数据的加载、缓存，以及对数据库进行配置。这里的Store也经常叫做service layer或者repository。</p>

<h2><strong><span style="color: #339966;">将Web Service逻辑移至Model Layer</span></strong></h2>

<p>这里的方法实际上跟上面介绍的非常类似：不要在view controller中做web service逻辑处理，而是将相关的逻辑处理封装到不同的类中。然后我们的view controller通过callback handler(例如一个completion block)来调用这些类的方法。<br/>
这样做带来的一个好处就是我们可以方便在这些封装类中做缓存和错误处理。</p>

<h2><strong><span style="color: #339966;">将View代码移至View Layer</span></strong></h2>

<p>切记不要在view controller中构建复杂的view结构。可选方案是：要么利用interface builder，或者就是将view的构建封装到一个UIView子类中。例如，如果你要构建一个date picker控件，可以基于DatePickerView类来构建，而不要把所有构建逻辑都放入view controller中。这样不仅能增加控件的可重用性，还能让代码简单化。<br/>
如果你喜欢用interface builder，那么也同样可以在interface builder中做这些事情。我们的一些开发者可能认为只有view controller才能在interface builder中使用，其实我们可以通过加载一个单独的nib文件，来加载我们在nib文件中定制的view。在本文给出的示例工程中，我创建了一个PhotoCell.xib文件，该文件中定制了一个photo cell：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/photocell.png"><img class="alignnone size-full wp-image-1539" alt="photocell" src="http://beyondvincent.com/wp-content/uploads/2013/07/photocell.png" width="1168" height="838" /></a></p>

<p>如上图所示，我在这个view中创建了两个属性：photoDateLable和photoTitleLable(注意：在这里的xib文件中没有使用File&#8217;s Owner object)，并将这两个属性连接到制定的subview中。<br/>
上面介绍的技巧同样可以方便的用于别的一些custom view。</p>

<h2><strong><span style="color: #339966;">与别的对象进行通讯</span></strong></h2>

<p>在view controller中与别的view controller、model和view通讯是非常频繁的。虽然这确实是由controller负责的，不过，我们还是希望用最少的代码来完成相关的事情。<br/>
目前已经有许多技术可以用于view controller和model对象之间的通讯(例如KVO)，不过view controller之间通讯的技术貌似不太明朗。<br/>
我们可能会经常遇到这样的问题：一个view controller有许多状态需要与其它多个view controller进行勾兑。通常，需要把这些状态封装到一个单独的对象中，然后将其传送到对应的view controller中，在这些view controller中对这些状态进行观察并修改即可——这样带来的优点是所有的状态都在一个地方，开发者不用纠结于delegate的callback。<br/>
实际上，关于对象间的通讯是一个复杂的topic，在今后的文章中，我们可能会对其进行深度分析。<span style="color: #339966;"><br /> </span></p>

<h2><strong><span style="color: #339966;">小结</span></strong></h2>

<p>上面我们学习了一些对view controller瘦身的技巧。这些技巧并不强求用与所有的地方，其实只有一个目标：编写可维护的代码。大家通过了解这些方法，可以知道有更多的方法来应对复杂的view controller，让其看起来更加清晰。</p>

<h2><strong><span style="color: #339966;">延伸阅读</span></strong></h2>

<ul>
<li><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://developer.apple.com/library/ios/#featuredarticles/ViewControllerPGforiPhoneOS/BasicViewControllers/BasicViewControllers.html"><span style="color: #339966; text-decoration: underline;">View Controller Programming Guide for iOS</span></a></span></span></li>
<li><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/DevPedia-CocoaCore/ControllerObject.html"><span style="color: #339966; text-decoration: underline;">Cocoa Core Competencies: Controller Object</span></a></span></span></li>
<li><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://subjective-objective-c.blogspot.de/2011/08/writing-high-quality-view-controller.html"><span style="color: #339966; text-decoration: underline;">Writing high quality view controllers</span></a></span></span></li>
<li><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://programmers.stackexchange.com/questions/184396/mvcs-model-view-controller-store"><span style="color: #339966; text-decoration: underline;">Stack Overflow: Model View Controller Store</span></a></span></span></li>
<li><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://speakerdeck.com/trianglecocoa/unburdened-viewcontrollers-by-jay-thrash"><span style="color: #339966; text-decoration: underline;">Unburdened View Controllers</span></a></span></span></li>
<li><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://programmers.stackexchange.com/questions/177668/how-to-avoid-big-and-clumsy-uitableviewcontroller-on-ios"><span style="color: #339966; text-decoration: underline;">Stack Overflow: How to avoid big and clumsy UITableViewControllers on iOS</span></a></span></span></li>
</ul>


<p>&nbsp;</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-05</time></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-07-03T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jul 3<span>rd</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/windows-8-kai-fa-31ri/'>Windows 8 开发31日</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/07/03/96/" itemprop="url">Windows 8开发31日</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1>关于Windows 8开发31日翻译</h1>

<p>Windows 8 开发31日(31 Days of Windows 8)是由Jeff Blankenburg和Clark Sell原创的。</p>

<p>官方站点：<a href="http://31daysofwindows8.com/">http://31daysofwindows8.com/</a></p>

<p>涉及到两个版本： XAML/C#（由Jeff Blankenburg撰写） HTML5/JS （由Clark Sell撰写）</p>

<p>其中涉及到的资源和相关代码请到这里下载： <a href="https://github.com/csell5/31DaysOfWindows8">https://github.com/csell5/31DaysOfWindows8</a></p>

<p>在这里，由于破船对HTML5/JS不熟悉，所以只翻译XAML/C#相关主题。建议大家前往看原创内容，如果看不明白，再来这里看我翻译的相关内容。如果翻译不正确的地方，可以通过下面的联系方式告诉破船。</p>

<p>&nbsp;</p>

<h1>译文下载地址：<span style="text-decoration: underline;"><strong><span style="color: #ff0000; text-decoration: underline;"><a href="https://github.com/BeyondVincent/31-Days-of-Windows-8" target="_blank"><span style="color: #ff0000; text-decoration: underline;">第二版</span></a><span style="font-size: 13px;"><br /> </span></span></strong></span></h1>

<h1><span style="font-size: 13px;">2012年曾在</span><a style="font-size: 13px;" href="http://www.devdiv.com/forum.php"><a href="http://www.devdiv.com/forum.php">http://www.devdiv.com/forum.php</a></a><span style="font-size: 13px;"> 社区发布过第一版。根据读者的反馈，对第一版中的内容做了一些更新修正。</span></h1>

<h1>联系破船</h1>

<p>你可以发邮件与破船取得联系: <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x42;&#x65;&#x79;&#x6f;&#110;&#x64;&#86;&#x69;&#110;&#x63;&#101;&#x6e;&#116;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#x42;&#101;&#x79;&#x6f;&#110;&#100;&#x56;&#105;&#x6e;&#99;&#x65;&#x6e;&#116;&#x40;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;</a></p>

<p>还可以关注破船的微博: 新浪微博:<a href="http://www.weibo.com/beyondvincent">www.weibo.com/beyondvincent</a></p>

<p>这里是破船的个人博客，欢迎光临：<a href="http://beyondvincent.com/">http://beyondvincent.com/</a></p>

<p>破船祝你阅读愉快！</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-07-03T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jul 3<span>rd</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios7xin-te-zheng/'>iOS7新特征</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/07/03/95/" itemprop="url">iOS7新特征汇总[06]What&#8217;s New in Cocoa Touch学习笔记</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>提醒：这里是新特征汇总博文链接：<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/2013/06/11/ios7%E6%96%B0%E7%89%B9%E5%BE%81%E6%B1%87%E6%80%BB/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总</span></a></strong></span></span></p>

<p>今晚看了一下WWDC2013的session：<strong><span style="color: #ff0000;">What&#8217;s New in Cocoa Touch</span></strong></p>

<p>该session介绍了iOS 7中Cocoa Touch里面新增的许多内容。</p>

<p>下面是一些学习笔记，供大家参考一下（<strong><span style="color: #339966;">由于是边看边记录，如有文字录入错误，还请见谅</span></strong>）：</p>

<h2><strong><span style="color: #339966;">1、Multitasking</span></strong></h2>

<p><span style="color: #339966;">Background fetching</span><br/>
you must call this at launch<br/>
<span style="color: #339966;">Remote notification</span><br/>
Method: didReceiveRemoteNotification<br/>
call the completion handler when fetch is complete<br/>
<span style="color: #339966;">Background transfers</span><br/>
Method: handleEventsForBackgroundURLSession<br/>
NSURLSession replace API for NSURLConnection<br/>
Data upload download task<br/>
session have identifiers</p>

<h2><strong><span style="color: #339966;">2、view and image</span></strong></h2>

<p><span style="color: #339966;"> Image Rendering Modes</span><br/>
Creating image with redering mode<br/>
method: imageWithRenderingMode:<br/>
param: UIImageRenderingMode<br/>
<span style="color: #339966;">Tint</span><br/>
New UIView property<br/>
@property (nonatomic, retain) UIColor *tintColor;<br/>
Dimming adjustment behavior<br/>
@property (nonatomic) UIViewTintAdjustmentMode tintAdjustmentMode;<br/>
Finding out about changes<br/>
&ndash;(void) intColorDidChange;<br/>
<span style="color: #339966;">View Animation</span><br/>
No animations!<br/>
+(void)performWithoutAnimation:<br/>
Keyframes<br/>
+(void)animationKeyframesWithDuration<br/>
+(void)addKeyframeWithRelativeStartTime:<br/>
UIViewKeyframeAnimationOptions</p>

<h2><strong><span style="color: #339966;">3、Motion Effects</span></strong></h2>

<p>Applies relative values to key paths of a target view<br/>
Affected by device &#8220;pose&#8221; or position<br/>
Affects animatable properties only</p>

<p>class: UIInterpolatingMotionEffect<br/>
initialization——initWithKeyPath:<br/>
UIMotionEffect<br/>
abstract superclass<br/>
one method<br/>
keyPathsAndRelativeValuesForViewerOffset:<br/>
UIOffset: CGFloat horizontal, vertical;<br/>
<span style="color: #339966;">UIView</span><br/>
adding and removing motion effects<br/>
addMotionEffect:<br/>
removeMotionEffect:<br/>
@property (copy, nonatomic) NSArray *motionEffects;</p>

<h2><strong><span style="color: #339966;">4、Collection Views</span></strong></h2>

<p><span style="color: #339966;"> Transitions between layouts</span><br/>
method: setCollectionViewLayout: animated: completion<br/>
<span style="color: #339966;">UICollectionViewTransitionLayout</span></p>

<h2><strong><span style="color: #339966;">5、View Controllers</span></strong></h2>

<p><span style="color: #339966;"> Layout</span><br/>
wantsFullScreenLayout<br/>
deprecated in iOS 7.0<br/>
extended edges<br/>
content size<br/>
@property (nonatomic) CGSize preferredContentSize;<br/>
status bar appearance<br/>
new behavior for the status bar<br/>
new status bar style<br/>
UIStatusBarStyleDefault<br/>
UIStatusBarStyleLightContent (new)<br/>
// UIStatusBarStyleBlackTranslucent<br/>
// UIStatusBarStyleBlackOpaque</p>

<h2><strong><span style="color: #339966;">6、Custom Transitions</span></strong></h2>

<p>bounded &#8220;canned&#8221; transition<br/>
interactive, user-driven transition<br/>
new delegate method on UIViewController<br/>
UIViewControllerTransitioningDelegate<br/>
UIViewControllerAnimatedTransitioning<br/>
UIViewControllerInteractiveTransitioning<br/>
UIViewControllerContextTransitioning<br/>
ref: WWDC2013 Custom Transitions Using View Controllers</p>

<h2><strong><span style="color: #339966;">7、State Restoration</span></strong></h2>

<p><span style="color: #339966;"> Ignoring Snapshots</span><br/>
&ndash;(void)ignoreSnapshotOnNextApplicationLaunch;<br/>
<span style="color: #339966;">Other Objects</span><br/>
Non-view and non-view controller can now participate<br/>
method: registerObjectForStateRestoration:<br/>
<span style="color: #339966;">Bluetooth State Restoration</span></p>

<h2><strong><span style="color: #339966;">8、AirDrop</span></strong></h2>

<p>Adopt <span style="color: #339966;">UIActivityItemSourceProtocol</span><br/>
Update application&#8217;s info.plist to create, register, and export UTI for custom document formats<br/>
New Documents/Inbox directory</p>

<p><strong style="font-size: 1.5em;"><span style="color: #339966;">9、Dynamics</span></strong></p>

<p><span style="color: #339966;"><span style="color: #333333;">Fluid, responsive animations</span></span></p>

<p>Enhances the interactions in you application<br/>
Concentration on behaviors</p>

<p>class: UIDynamicAnimator<br/>
UIDynamicBehavior<br/>
UIDynamicItem</p>

<p><span style="color: #339966;">supported behaviors</span><br/>
UIAttachmentBehavior<br/>
UICollisionBehavior<br/>
UIGravityBehavior<br/>
UIPushBehavior<br/>
UISnapBehavior<br/>
UDynamicItemBehavior</p>

<h2><strong><span style="color: #339966;">10、Text</span></strong></h2>

<p><span style="color: #339966;"> Dynamic type sizing</span><br/>
@property(nonatomic, readonly) NSString * preferredContentSizeCategory;<br/>
<span style="color: #339966;">UIFont</span><br/>
Font scaling based on content size category<br/>
preferredFontForTextStyle:<br/>
<span style="color: #339966;">Text Kit</span><br/>
Objective-C API<br/>
class: NSTextStorage<br/>
NSLayoutManager<br/>
NSTextContainer<br/>
UITextView UITextField UILable<br/>
additional class<br/>
NSTextAttachment</p>

<h2><strong><span style="color: #339966;">11、More New Feathures</span></strong></h2>

<p><span style="color: #339966;"> Multipeer Connectivity</span><br/>
Local network discovery<br/>
seesion management<br/>
encryptyed sessions<br/>
file transfers<br/>
<span style="color: #339966;">SpriteKit</span><br/>
iOS 、OS X<br/>
High-performance sprite-based game framework<br/>
image atlas support<br/>
UIKit and AppKit integration<br/>
<span style="color: #339966;">Game Controller</span><br/>
Buttons<br/>
Analog joysticks<br/>
Multiple controllers<br/>
<span style="color: #339966;">MapKit</span><br/>
Directions<br/>
3D cameras<br/>
Map tile overlays<br/>
Map snapshots<br/>
Geodesic polylines</p>

<p><span style="color: #339966;">CoreLocation</span><br/>
Bluetooth LE beacons<br/>
advertising<br/>
ranging<br/>
New region types<br/>
Region monitoring<br/>
<span style="color: #339966;">Accessibility</span><br/>
Guided Access API<br/>
<span style="color: #339966;">GameCenter</span><br/>
new turn-based game API<br/>
turns tabs<br/>
mode for bidding<br/>
leader board improvements<br/>
system integrity features</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-03</time></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-07-02T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jul 2<span>nd</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>, <a class='category' href='/blog/categories/iosfan-yi/'>iOS翻译</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/07/02/94/" itemprop="url">让UIViewController中的viewDidLoad和viewWillAppear各司其责</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>注：本文由破船译自：<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://thejoeconwayblog.wordpress.com/2013/06/25/uiviewcontroller-viewdidload-vs-viewwillappear/" target="_blank"><span style="color: #339966; text-decoration: underline;">thejoeconwayblog</span></a></span></strong></span></p>

<p>你是否有过这样的感觉：有时某些代码是放到<strong><span style="color: #339966;">viewDidLoad</span></strong>还是<span style="color: #339966;"><strong>viewWillAppear</strong></span>:中，这很容易让人混淆。在Stack Overflow上经常会遇到这样的问题：<strong><span style="color: #339966;">viewDidLoad和viewWillAppear到底哪个方法先被调用？</span></strong>实际上，理解这些方法的去向，以及为什么会这样并不重要，重要的是需要知道这些方法的作用，以及它们是如何与程序协调分工的。</p>

<p>我们知道，一般iOS应用程序都是由多个view controller构成的，每个view controller代表一个屏幕的信息。而当程序与用户交互时，根据程序中不同的状态，显示不同的view controller。例如，如果用户需要注册一个账号时，屏幕上应该显示出允许用户输入个人信息的界面，当用户完成注册之后，应该能够看到相应的主页面。</p>

<p><strong><span style="color: #339966;">viewWillAppear:方法的作用是与屏幕中改变的内容进行交互。</span></strong>告诉view controller将对应的界面内容显示到屏幕最前端：确保view controller中所有的文本控件显示出最新的信息、必要的数据是可访问的、并对适当的通知(notification)进行观察等。当viewWillAppear:被触发时，说明对应的view controller变为&#8221;active&#8221;状态。</p>

<p><strong><span style="color: #339966;">那么viewDidLoad方法存在的理由又是什么呢？</span></strong>唯一的原因——有时无法或者不能有效的在XIB文件中对用户界面进行100%的配置。例如，有时希望给view设置一个特殊的属性(该属性在XIB中不可用)、有时在给一个button设置背景图片之前，希望能先对该图片进行修改、再比如，在使用auto layout时，有时你可能会意识到在XIB中进行相关操作还不如用代码来写auto layout相关的代码。</p>

<p>我们不能根据viewDidLoad方法的调用情况，来推断出应用程序的状态相关信息。viewDidLoad方法实际上就是简单的一个文件加载后处理机制。换句话说，作为开发者，应该<span style="color: #339966;"><strong>把viewDidLoad方法当做XIB文件的一个有效扩展</strong></span>，而不要理解为应用程序运转流程中的一部分。</p>

<p>这到底是什么意思呢？——我们应该在viewWillAppear:方法中对view中显示的内容进行变更，而不是在viewDidLoad中。view中的内容是程序实际运行时由controller传递给view来显示的数据(模型对象)。</p>

<p>下面我们来看一个示例：一个银行应用程序，可以显示用户当前的余额。当用户点击一个按钮时，可以在一个modal view controller中显示一个列表：该列表列出了用户附近的ATM机。在此，为了获得附近的ATM机列表信息，程序必须使用core location已经web service请求。在上面这种情况下，如果程序员把从服务器请求用户附近ATM列表的操作放到viewDidLoad中。此时，由于view controller只显示一次(viewDidLoad和viewWillAppear都只会被调用一次)，所以，从服务器请求用户附近ATM列表的操作，放到viewDidLoad与viewWillAppear中，对程序的效果都是一样的。</p>

<p>但是这样做法是不好的。想一下，如果把这个ATM view controller移到tab bar controller中，会是什么情况。现在，ATM view controller——在viewDidLoad中获取ATM信息的代码只会获取一次。所以，如果你周二在亚特兰大打开该程序查找ATM，然后查询一下余额。接着周三你去了纽约，再次打开该程序时，只能看到亚特兰大的ATM信息——view已经加载过了，所以不会再调用viewDidLoad方法。<br/>
<strong><span style="color: #ff0000;">注意：在这里应该有这样的前提条件：程序没有退出。</span></strong></p>

<p>实际上，在这种情况下，写代码时犯下了一个最大的错误：<strong><span style="color: #339966;">the easiest way is the easiest way</span></strong>。应用程序是会发生变化的，而用户界面也会发生改变。刚开始使用简单的方法，可能会在以后引发各种问题。</p>

<div style="text-align: left;">
  <span style="color: #808080;">本文由<strong><span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></strong>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-02</time></span>
</div>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-07-01T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jul 1<span>st</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/iosfan-yi/'>iOS翻译</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/07/01/93/" itemprop="url">Xcode中断点的威力</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>注：本文由破船译自：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.albertopasca.it/whiletrue/2013/06/xcode-power-of-breakpoints/" target="_blank"><span style="color: #339966; text-decoration: underline;">albertopasca</span></a></span></strong></span><br/>
本文由<strong><span style="color: #339966;">HoNooD</span></strong>在<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://iosfeed.com/view/76" target="_blank"><span style="color: #339966; text-decoration: underline;">iosfeed</span></a></span></span></strong>站点上做了推荐。</p>

<p>这里先推荐两篇Xcode相关的文章：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/2013/05/31/xcode-code-snippets/" target="_blank"><span style="color: #339966; text-decoration: underline;">Xcode Code Snippets</span></a></span></span></strong><br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"> <a href="http://beyondvincent.com/2013/05/16/ios%E4%B8%AD%E8%B0%83%E8%AF%95-%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS调试 — 基本技巧</span></a></span></span></strong></p>

<p>本文目录：</p>

<p><strong><span style="color: #339966;">1、添加一个特殊的断点</span></strong><br/>
<strong><span style="color: #339966;">    异常断点(Exception breakpoint)</span></strong><br/>
<strong><span style="color: #339966;">    符号断点(Symbolic breakpoint)</span></strong><br/>
<strong><span style="color: #339966;">2、打印到控制台</span></strong><br/>
<strong><span style="color: #339966;">    使用NSLog打印字符串</span></strong><br/>
<strong><span style="color: #339966;">    使用NSLog打印对象(po)</span></strong><br/>
<strong><span style="color: #339966;">    带条件的打印</span></strong><br/>
<strong><span style="color: #339966;">    在循环里面打印一些东西</span></strong><br/>
<strong><span style="color: #339966;">3、运行时设置断点</span></strong><br/>
<strong><span style="color: #339966;">4、调试中播放声音</span></strong><br/>
<strong><span style="color: #339966;">5、LLDB中有用的一些命令</span></strong><br/>
<strong><span style="color: #339966;">    打印帮助</span></strong><br/>
<strong><span style="color: #339966;">    打印调用栈</span></strong><br/>
<strong><span style="color: #339966;">    打印最基本的内容 (p)</span></strong><br/>
<strong><span style="color: #339966;">    打印对象(po)</span></strong><br/>
<strong><span style="color: #339966;">    打印表达式(expr)</span></strong><br/>
<strong><span style="color: #339966;">    打印线程中的一些东西</span></strong></p>

<p>&nbsp;</p>

<p>正文</p>

<p>下面是非常有用的一些Xcode调试技术(使用断点和LLDB调试器)</p>

<p>1、添加一个特殊的断点</p>

<ul>
<li>异常断点(Exception breakpoint)</li>
</ul>


<p>如果添加了异常断点，当程序每次发生了异常，都会被中断。<strong><span style="color: #339966;">一般用来捕获未知异常</span></strong>。如下示例：</p>

<pre class="wp-code-highlight prettyprint linenums:1">*** Terminating app due to uncaught exception ’NSRangeException’, reason:
’-[__NSCFArray objectAtIndex:]: index (10) beyond bounds (3)</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-01.png"><img class="alignnone size-full wp-image-1497" alt="xcode-debug-01" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-01.png" width="1049" height="654" /></a></p>

<ul>
<li>符号断点(Symbolic breakpoint)</li>
</ul>


<p>符号断点可以中断某个函数的调用。</p>

<pre class="wp-code-highlight prettyprint linenums:1">- [UIViewController viewDidLoad]
- [__NSCFArray objectAtIndex:]</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-02.png"><img class="alignnone size-full wp-image-1498" alt="xcode-debug-02" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-02.png" width="1049" height="654" /></a></p>

<p>&nbsp;</p>

<p>2、打印到控制台</p>

<ul>
<li>使用NSLog打印字符串</li>
</ul>


<p>使用断点来替换NSLog代码(或者在运行时添加一个NSLog)——与代码写NSLog的效果相同。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-04.png"><img class="alignnone size-full wp-image-1499" alt="xcode-debug-04" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-04.png" width="1030" height="654" /></a></p>

<p>&nbsp;</p>

<ul>
<li>使用NSLog打印对象(po)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">NSLog(@"obj: %@", obj);</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-05.png"><img class="alignnone size-full wp-image-1500" alt="xcode-debug-05" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-05.png" width="1030" height="654" /></a></p>

<ul>
<li>带条件的打印</li>
</ul>


<p>例如：当aNumber大于10才打印出“str”的内容。</p>

<pre class="wp-code-highlight prettyprint linenums:1">expr (void)NSLog(@"Ok, print a log: %@", str)</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-07.png"><img class="alignnone size-full wp-image-1501" alt="xcode-debug-07" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-07.png" width="1030" height="681" /></a></p>

<p>&nbsp;</p>

<ul>
<li>在循环里面打印一些东西</li>
</ul>


<p>例如，在循环中希望i大于5才开始打印。</p>

<pre class="wp-code-highlight prettyprint linenums:1">for ( int i=0; i&lt;10; i++ )
{
[self self]; // something
}</pre>


<p>使用“ignore”值，并利用下面的代码进行打印：</p>

<pre class="wp-code-highlight prettyprint linenums:1">expr (void)NSLog(@"Ok, print a log: %@", str)</pre>


<p><img class="alignnone size-full wp-image-1502" alt="xcode-debug-08" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-08.png" width="1030" height="681" /></p>

<p>3、运行时设置断点</p>

<p>在运行的时候，根据条件设置断点有时候非常有用。</p>

<pre class="wp-code-highlight prettyprint linenums:1">breakpoint set -f APViewController.m -l 33</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-09.png"><img class="alignnone size-full wp-image-1503" alt="xcode-debug-09" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-09.png" width="1030" height="681" /></a></p>

<p>4、调试中播放声音</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/Schermata-06-2456470-alle-15.43.13.png"><img class="alignnone size-full wp-image-1504" alt="Schermata-06-2456470-alle-15.43.13" src="http://beyondvincent.com/wp-content/uploads/2013/07/Schermata-06-2456470-alle-15.43.13.png" width="475" height="304" /></a></p>

<p>5、LLDB中有用的一些命令</p>

<p>当Xcode停留在某个断点时，我们可以通过控制台(console)与<strong><span style="color: #339966;">lldb</span></strong>进行交互。</p>

<ul>
<li>打印帮助</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) help</pre>


<ul>
<li>打印调用栈(bt)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) bt
* thread #1: tid = 0x1c03, 0x00003146 Debug`-[APViewController callMe:andANumber:](self=0x07187e50, _cmd=0x000038b9, str=0x0715aa40, aNum=38) + 230 at APViewController.m:33, stop reason = breakpoint 3.1
frame #0: 0x00003146 Debug`-[APViewController callMe:andANumber:](self=0x07187e50, _cmd=0x000038b9, str=0x0715aa40, aNum=38) + 230 at APViewController.m:33
frame #1: 0x0000304a Debug`-[APViewController viewDidLoad](self=0x07187e50, _cmd=0x005c5a77) + 122 at APViewController.m:16
frame #2: 0x000f41c7 UIKit`-[UIViewController loadViewIfRequired] + 536
frame #3: 0x000f4232 UIKit`-[UIViewController view] + 33
frame #4: 0x000433d5 UIKit`-[UIWindow addRootViewControllerViewIfPossible] + 66
frame #5: 0x0004376f UIKit`-[UIWindow _setHidden:forced:] + 368
frame #6: 0x00043905 UIKit`-[UIWindow _orderFrontWithoutMakingKey] + 49
frame #7: 0x0004c917 UIKit`-[UIWindow makeKeyAndVisible] + 65
frame #8: 0x00002e1b Debug`-[APAppDelegate application:didFinishLaunchingWithOptions:](self=0x07560750, _cmd=0x005a9c21, application=0x0716a640, launchOptions=0x00000000) + 571 at APAppDelegate.m:28
frame #9: 0x00010157 UIKit`-[UIApplication _handleDelegateCallbacksWithOptions:isSuspended:restoreState:] + 266
frame #10: 0x00010747 UIKit`-[UIApplication _callInitializationDelegatesForURL:payload:suspended:] + 1248
frame #11: 0x0001194b UIKit`-[UIApplication _runWithURL:payload:launchOrientation:statusBarStyle:statusBarHidden:] + 805
frame #12: 0x00022cb5 UIKit`-[UIApplication handleEvent:withNewEvent:] + 1022
frame #13: 0x00023beb UIKit`-[UIApplication sendEvent:] + 85
frame #14: 0x00015698 UIKit`_UIApplicationHandleEvent + 9874
frame #15: 0x01becdf9 GraphicsServices`_PurpleEventCallback + 339
frame #16: 0x01becad0 GraphicsServices`PurpleEventCallback + 46
frame #17: 0x01c06bf5 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + 53
frame #18: 0x01c06962 CoreFoundation`__CFRunLoopDoSource1 + 146
frame #19: 0x01c37bb6 CoreFoundation`__CFRunLoopRun + 2118
frame #20: 0x01c36f44 CoreFoundation`CFRunLoopRunSpecific + 276
frame #21: 0x01c36e1b CoreFoundation`CFRunLoopRunInMode + 123
frame #22: 0x0001117a UIKit`-[UIApplication _run] + 774
frame #23: 0x00012ffc UIKit`UIApplicationMain + 1211
frame #24: 0x00002b22 Debug`main(argc=1, argv=0xbffff3a4) + 130 at main.m:16
frame #25: 0x00002a55 Debug`start + 53
(lldb)</pre>


<ul>
<li>打印最基本的内容 (p)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) print anInt</pre>


<ul>
<li>打印对象(po)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) po anObj
(lldb) po 0x0715aa40</pre>


<ul>
<li>打印表达式(expr)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) expr 5+2
(lldb) expr aString = @"aNewValue"</pre>


<ul>
<li>打印线程中的一些东西</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) help frame</pre>




<div style="text-align: left;">
  <span style="color: #808080;">本文由<strong><span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></strong>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-01</time></span>
</div>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-06-21T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jun 21<span>st</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/qi-ta/'>其它</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/06/21/92/" itemprop="url">记我的第二个马拉松—昆明高原国际半程马拉松</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>对于IT行业的从业人员，由于工作的性质，很多人的身体都缺乏有效的锻炼。实际上这是一个非常危险的信号，现如今，随着社会的进步，大家的生活质量也不断提高，但是人们的身体状况总是令人担忧，几乎每年都能听说在IT行业里面有关猝死的新闻！在这里，希望大家能够在工作之余，善待自己的身体——毕竟前人已经说过，身体是革命的本钱！相信现在对身体多一份投资，将来会得到更多的回报。</p>

<p>关于技术的分享改日再谈，今日就来跟大家分享一下我的第二个马拉松。</p>

<h2><strong><span style="color: #339966;">正文</span></strong></h2>

<p>细算我跑步也有些年头了，不过要算马拉松比赛，至今才参加了2个，第一个是2012年11月25日的<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://beyondvincent.com/2013/05/11/%E7%A0%B4%E8%88%B9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%97%E4%BA%AC%E9%A9%AC%E6%8B%89%E6%9D%BE/" target="_blank"><span style="color: #339966; text-decoration: underline;">北京国际马拉松</span></a></span></strong></span>，现在还记得，本应该10月中旬就举办的了，但是由于要召开十八大，所以北京马拉松被迫让路，被推延到11月25日举行，在北京生活过的同学们应该清楚，这时候的天气已经冷了，这给我的初马带来了不小的挑战，结果虽然完成了比赛，但是跟预期的时间要多了1小时30分钟左右。</p>

<p>今年(2013)回到了云南，从云南跑吧群里得知在5月25日将举办昆明高原国际半程马拉松，大家也没有盼来期望的全程，可能组委会考虑到近一年来马拉松赛场上出的那些事，为谨慎起见吧。虽然是半程，不过这是在高原，平均海拔在1800米，对于外省人来说估计也会有一些难度。刚好，目前全程对于我来说可以跑下来，不过身体会受伤，半程是我的最佳选择。</p>

<p>为了参加昆明的这个马拉松，我前前后后约准备了半年时间，当然，由于是半程，难度不是太大，不出意外，都能够完赛，所以在备战计划中，对自己的身体要求不是太苛刻，力争达到跑完比赛之后，身体还是舒服就好。因而在平常的训练中，每周平均跑步3.5次，每次跑步的距离也是随性，可能是8km，10km，有时也会只计算时间，速度和距离没有考虑太多。毕竟跑步的最终目的是锻炼身体，让疾病晚一点光顾，参加马拉松比赛对我而言只当做锦上添花罢了，也算是给平时的跑步生活增添一点乐趣。</p>

<p>2013年5约25日，我早早的就起床，赶往马拉松出发地点——昆明-呈贡新区。到达出发点时，已经有好多人了，也看到了好多张熟悉的面孔。由于排队上厕所耗费了一些时间，没能赶上云南跑吧的赛前大合影（来自跑吧风11的摄影），有点点遗憾。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb.jpeg"><img class="alignnone size-full wp-image-1476" alt="psb" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb.jpeg" width="5428" height="1469" /></a></p>

<p>早上9点，马拉松准备开始，刚开始，当然也是中国式的马拉松开幕式——领导发言，10分钟后准时鸣枪起跑。大家像挣脱缰绳的野马一样，无论是男女老少，都一波流的往前冲，我在想，照着么快的速度下去，很多人会中途跑崩了的。也或许没有全程，大家顾虑也会少了许多吧。</p>

<p>本次马拉松的一大特点应该就是赛道起伏坡度又大又长，这跟北京马拉松的赛道有明显的区别。这对平时不怎么跑坡的同学，也会增加一点难度。</p>

<p>在跑步途中，我主要以匀速跟随跑为主，为了控制好自己的速度，时不时的会问问周围跑友目前的配速。由于本次赛道是折返跑，所以开跑后大约在8km的地方，我遇到了已经折返的<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://blog.sina.com.cn/mlwdxlbk42195" target="_blank"><span style="color: #339966; text-decoration: underline;">马哥-千里马</span></a></span></strong></span>——马拉松业余爱好者中的佼佼者，也为云南跑吧的成长付出了很多。</p>

<div id="attachment_1477" class="wp-caption alignnone" style="width: 272px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130621-1.png"><img class="size-full wp-image-1477" alt="马哥-千里马" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130621-1.png" width="262" height="316" /></a><p class="wp-caption-text">
    马哥-千里马
  </p>
</div>


<p>大约跑了50分钟的时候，我开始从折返点往回跑，一路上遇到好多熟悉的，不熟悉的人，大家相互加油，共同奔跑。</p>

<div id="attachment_1478" class="wp-caption alignnone" style="width: 1610px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb-1.jpeg"><img class="size-full wp-image-1478" alt="psb (1)" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb-1.jpeg" width="1600" height="1060" /></a><p class="wp-caption-text">
    破船在折返途中
  </p>
</div>


<p>折返途中，也是有几个不小的坡，前几个都轻松搞定，就是最后一个坡，这个坡度虽然不大，但是太长了，在距离终点还有2km的时候，心里做了数次挣扎——跑不动就走走吧，但是又在鼓励自己，坚持住，跑过地狱就是天堂。就这样，坚持着，很快，拐过几个弯，终点处的计时牌已经映入眼帘，看看时间，能够跑进2小时。最后时刻，在观众的加油声中，肾上腺激素被激发，加快了脚下的速度，顺利冲过终点，而此时时间定格在1小时56分42秒，排名141名。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb.png"><img class="alignnone size-full wp-image-1479" alt="psb" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb.png" width="533" height="575" /></a></p>

<p>冲过终点，领取纪念奖品，然后跟云南跑吧一起合影</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb1.jpeg"><img class="alignnone size-full wp-image-1480" alt="psb" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb1.jpeg" width="1114" height="539" /></a></p>

<p>&nbsp;</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb-11.jpeg"><img class="alignnone size-full wp-image-1481" alt="psb (1)" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb-11.jpeg" width="665" height="492" /></a></p>

<p>&nbsp;</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb-2.jpeg"><img class="alignnone size-full wp-image-1482" alt="psb (2)" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb-2.jpeg" width="800" height="535" /></a></p>

<p>下一站：云南大理马拉松</p>

<div style="text-align: left;">
  <span style="color: #808080;">本文由<span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-21</time></span>
</div>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-06-20T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jun 20<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/06/20/91/" itemprop="url">iOS汇编教程：ARM(2)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>注：本文由破船译自：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.raywenderlich.com/37181/ios-assembly-tutorial" target="_blank"><span style="color: #339966; text-decoration: underline;">raywenderlich</span></a></span></strong></span><br/>
感谢<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://blog.devtang.com/" target="_blank"><span style="color: #339966; text-decoration: underline;">唐巧</span></a></strong></span></span>抽出时间对本文进行double-check。</p>

<p>本文是iOS汇编教程：ARM第二篇。</p>

<p>iOS汇编教程：ARM目录如下[共分为两篇]：</p>

<h2><span style="text-decoration: underline;"><a href="http://beyondvincent.com/?p=1398" target="_blank"><strong><span style="color: #339966; text-decoration: underline;">iOS汇编教程：ARM(1)</span></strong></a></span></h2>

<ul>
<li><strong><span style="color: #339966;">开始：什么是汇编</span></strong></li>
<li><strong><span style="color: #339966;">函数调用约定</span></strong></li>
<li><strong><span style="color: #339966;">创建工程</span></strong></li>
<li><strong><span style="color: #339966;">加法(addFunction)</span></strong></li>
</ul>


<h2><strong><span style="color: #339966;">iOS汇编教程：ARM(2)</span></strong></h2>

<ul>
<li><strong><span style="color: #339966;">函数的调用</span></strong></li>
<li><strong><span style="color: #339966;">Objective -C 汇编</span></strong></li>
<li><strong><span style="color: #339966;">Obj-C 消息发给了谁</span></strong></li>
<li><strong><span style="color: #339966;">你现在可以进行逆向工程了</span></strong></li>
<li><strong><span style="color: #339966;">何去何从</span></strong></li>
</ul>


<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&ndash;</p>

<h1><span style="color: #339966;"><strong>iOS汇编教程：ARM(2)</strong></span></h1>

<h2><strong><span style="color: #339966;">函数的调用</span></strong></h2>

<p>首先，给函数addFunction函数添加一个属性(<strong><span style="color: #339966;"><strong>attribute</strong></span></strong>) ，告诉编译器不要进行特定的优化处理。通过上一篇文章，你已经看到编译器可以对代码进行优化，移除掉不需要的指令，另外，编译器甚至可以移除掉函数的调用，直接把被调用函数的相关代码进行内嵌到调用函数中。</p>

<p>例如，编译器可能会在调用函数中适当的添加add指令，而不是调用addFunction本身。实际上，现如今的编译器已经非常的智能了，针对类似addFunction这样的函数，编译器本身就可以进行加法操作，而不用在代码中添加一条add指令。</p>

<p>本文中，我们不希望编译器对代码进行优化——把代码进行内嵌处理。现在回到工程的main.m文件中，并按照如下方式修改addFunction：</p>

<pre class="wp-code-highlight prettyprint linenums:1">__attribute__((noinline))
int addFunction(int a, int b) {
    int c = a + b;
    return c;
}</pre>


<p>紧接着，在该函数下面添加另外一个函数：</p>

<pre class="wp-code-highlight prettyprint linenums:1">void fooFunction() {
    int add = addFunction(12, 44);
    printf("add = %i", add);
}</pre>


<p>&nbsp;</p>

<p>如上代码所示，fooFunction通过调用addFunction来计算12+44，然后将结果打印出来。这里使用C函数printf进行打印，而没有使用Objective-C的NSLog(NSLog要稍微复杂一点)。</p>

<p>接着再次选择Xcode中的Product\Generate Output\Assembly File，并确保输出设置为Archiving。然后搜索_fooFunction，会看到如下一些内容：</p>

<p><span style="color: #993366;">提醒：在Scheme中一定要选择iOS Device，不要选择模拟器。</span></p>

<pre class="wp-code-highlight prettyprint linenums:1">_fooFunction:
@ 1:
    push    {r7, lr}
@ 2:
    movs    r0, #12
    movs    r1, #34
@ 3:
    mov r7, sp
@ 4:
    bl  _addFunction
@ 5:
    mov r1, r0
@ 6:
    movw    r0, :lower16:(L_.str-(LPC1_0+4))
    movt    r0, :upper16:(L_.str-(LPC1_0+4))
LPC1_0:
    add r0, pc
@ 7:
    blx _printf
@ 8:
    pop {r7, pc}</pre>


<p>上面的代码中，涉及到了一些还没有介绍过的指令，不用担心，它们都不复杂。下面我们就分别来看看上面代码中的指令都做了什么操作：</p>

<p>1、这里的指令作用跟之前介绍的<strong><span style="color: #339966;">add sp, #12</span></strong>类似——r7和lr被“pushed”到栈中，也就是说栈指针(sp)被减去8(因为r7和lr都是4个字节)。需要注意，通过这条指令，栈指针被递减，两个值也被存储到栈中！需要存储r7是因为在这个函数中，该寄存器会被覆盖，而之后又需要还原最初的值；而存储lr寄存器中的值是因为在函数结束时，要使用。</p>

<p><span style="color: #993366;">注意：lr是寄存器(Link Register, LR——R14寄存器)。</span></p>

<p>2、这两个指令属于<strong><span style="color: #339966;">move</span></strong>(mov)指令集中的一个。有时候你会看到movs，而有时候则会看到mov，或者其它类似的名称。它们都是把一个值装载到寄存器中。你可以把数据从一个寄存器“mov”到另外一个寄存器，例如<strong><span style="color: #339966;">mov ro, r1</span></strong>指令，将把r1中的数据装载到r0中，而r1中的数据不会改变。</p>

<p>上面的两行汇编指令中，会将定义在函数中的两个常量装载到r0和r1中。注意，需要将这两个常量装载到r0和r1中，才能够被addFunction正确的使用。</p>

<p>3、 在调用函数的时候，应该将栈指针保存起来，而这里使用r7来保存栈指针(r7是可以用来存储局部变量存储器中的一个)。可能你已经注意到，在该函数中剩下的代码里面并没有再次使用到栈指针或者r7，所以这条指令在这里是多余的——<strong><span style="color: #339966;">有时候，即使开启了编译器的优化，但还是不能做到最佳优化</span></strong>。</p>

<p>4、这条指令(<strong><span style="color: #339966;">bl</span></strong>)对函数进行调用。请记住被调用函数需要的参数已经存储到相关的寄存器中了(r0和r1)。这条指令的执行一般被当做一个分支(branch)。可以理解为<strong><span style="color: #339966;">执行带链接的分支</span></strong>，也就是说，在跳转到分支之前，会将lr(link register)的值设置为当前函数中将要执行的下一条指令，当从分支(被调函数)中返回时，通过lr中的值可以知道当前函数执行到哪里了。</p>

<p>5、当addFunction函数执行完毕，返回后，执行的第一条指令——将addFunction的返回值(存储在r0中)保存起来，以供后续的printf使用。也就是利用<strong><span style="color: #339966;">mov</span></strong>将r0中的值存储到r1中。</p>

<p>6、printf的的第一个参数是一个字符串。这里使用了3条指令将指向字符串首地址的指针装载到r0寄存器中。这个字符串存储在二进制文件的<strong><span style="color: #339966;">数据段“data segment”</span></strong>中，不过该字符串的准确位置在二进制文件被链接之前是不知道的。</p>

<p>字符串其实是在由main.m文件生成的目标文件(object file)中的数据段里。如果你在汇编代码中搜索<strong><span style="color: #339966;">L_.str</span></strong>，就能找到这个字符串。这三个指令中的前两个作用是装载这个常量的地址（减去本地标签加4后的地址）。</p>

<p>第三条指令中将程序计数器(pc)的值加到r0中。因此，现在r0已保存着字符串的地址，也不用考虑L_.str在二进制文件中的确切位置。</p>

<p>下面的这个图演示了内存的布局。其中<strong><span style="color: #339966;">L_.str &#8211; (LPC1_0 + 4)</span></strong>的改变并不用对r0进行改动。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/04-PC-relative-string-480x264.png"><img class="alignnone size-full wp-image-1442" alt="04-PC-relative-string-480x264" src="http://beyondvincent.com/wp-content/uploads/2013/06/04-PC-relative-string-480x264.png" width="480" height="264" /></a></p>

<p>7、这条指令(<strong><span style="color: #339966;">blx</span></strong>)调用printf函数。这跟<span style="color: #339966;"><strong>bl</strong></span>指令有明显的区别。<strong><span style="color: #339966;">blx</span></strong>中的<span style="color: #339966;"><strong>x</strong></span>标示交换“exchange”，意思是如果有必要，处理器将对指令集模式进行切换。</p>

<p>现在的ARM处理器有两种模式：<strong><span style="color: #339966;">ARM</span></strong>和<span style="color: #339966;"><strong>Thumb</strong></span>。Thumb指令是16位的宽度，而ARM指令是32位的宽度。Thumb指令比较少，不过使用Thumb指令意味着代码容量更小，以及更利于CPU缓存。</p>

<p>因此，使用Thumb尺寸得到的好处就是让你的代码更少。这里可以看到更多的Thumb信息：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="https://en.wikipedia.org/wiki/ARM_architecture#Thumb" target="_blank"><span style="color: #339966; text-decoration: underline;">Wikipedia</span></a></span></strong></span>。</p>

<p>8、最后一条指令是将在第一条指令中push到栈里面的值pop出来。这里列出来的寄存器将被从栈中pop出来的值填充，然后栈指针递增。回想一下第一条指令是这样的：r7和lr寄存器中的值被push到栈中，但是为什么这里的指令是将栈中的值pop到r7和pc寄存器中，而不是r7和lr寄存器中呢？</p>

<p>相信你还记得之前说过的：lr寄存器保存的是从一个函数返回时，下一条将被执行指令的地址。所以，如果将push到栈中的这个地址pop给pc(program counter)，那么将继续从函数被调用的地方执行——这也是从一个被调用函数返回调用函数的常规做法，而不是像调用addFunction一样返回到调用函数fooFunction中。</p>

<p>现在我们来看看ARM中的一些指令的简短总结。ARM中又许多指令，不过下面列出来的指令对于初步了解ARM指令非常重要。现在就通过伪代码(pseudo-code)和相关描述来快速的回顾一下这些指令都做有什么作用：</p>

<ul>
<li>mov r0, r1 => r0 = r1</li>
<li>mov r0, #10 => r0 = 10</li>
<li>ldr r0, [sp] => r0 = *sp</li>
<li>str r0, [sp] => *sp = r0</li>
<li>add r0, r1, r2 => r0 = r1 + r2</li>
<li>add r0, r1 => r0 = r0 + r1</li>
<li>push {r0, r1, r2} => 将 r0, r1 和 r2push到栈中.</li>
<li>pop {r0, r1, r2} => 将3个值从栈中pop出来，并存放到r0, r1 和 r2中.</li>
<li>b _label => pc = _label</li>
<li>bl _label => lr = pc + 4; pc = _label</li>
</ul>


<p><strong><span style="color: #ff0000;"> 现在是时候恭喜你了：你能够阅读一些ARM汇编代码了！</span></strong></p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/06-Read-ARM-meme.png"><img class="alignnone size-full wp-image-1446" alt="06-Read-ARM-meme" src="http://beyondvincent.com/wp-content/uploads/2013/06/06-Read-ARM-meme.png" width="552" height="414" /></a></p>

<p><strong style="font-size: 1.5em;"><span style="color: #339966;">Objective -C 汇编</span></strong></p>

<p>到现在为止，我们涉及到的函数都是用C语言来写的。Objective-C在C语言的基础上稍微增加了一点复杂度。下面我们就来看看用Objective-C代码编译出来的汇编指令。打开<strong><span style="color: #339966;">ViewController.m</span></strong>文件，然后将下面的方法添加到类的实现中：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (int)addValue:(int)a toValue:(int)b {
    int c = a + b;
    return c;
}</pre>


<p>同样，通过这样的步骤来查看汇编代码：<strong><span style="color: #339966;">Product\Generate Output\Assembly File</span></strong>。记得将output类型设置为Archiving，然后搜索<strong><span style="color: #339966;">addValue:toValue: </span></strong>，你会发现类似如下的汇编代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">"-[ViewController addValue:toValue:]":
    adds    r0, r3, r2
    bx  lr</pre>


<p>首先看到的是一个<strong><span style="color: #339966;">标签</span></strong>(label)名称——&#8221;&ndash;[ViewController addValue:toValue:]&#8220;，这个名称包含类名和完整的Objective-C方法名称。</p>

<p>把上面的汇编代码与之前的addFunction相关汇编代码进行比较，你会发现这里是将r2和r3进行加法运算，而不是r0与r1相加——这意味着传递给addValue:toValue:方法的参数使用了r2和r3寄存器(没有使用r0和r1)，这是为什么呢？</p>

<p>这是因为：在调用Objective-C方法时，除了传递明确指定的参数外，还会在明确参数之前传递两个隐含的参数(implicit parameter)。addValue:toValue:方法跟下面的C函数是等价的：</p>

<pre class="wp-code-highlight prettyprint linenums:1">int ViewController_addValue_toValue(id self, SEL _cmd, int a, int b) {
    int c = a + b;
    return c;
}</pre>


<p>这就是为什么a和b两个参数分别存储到r2和r3的原因。可能你之前已经听说过前两个参数了(经常使用self吧)。</p>

<p><strong><span style="color: #ff0000;">提醒：self和_cmd占用了r0和r1寄存器。</span></strong></p>

<p>可能之前你还没有见过<strong><span style="color: #339966;">_cmd</span></strong>。其实跟<strong><span style="color: #339966;">self</span></strong>一样，在Objective-C函数中，_cmd是可以直接使用的，它存储着当前执行方法的<strong><span style="color: #339966;">selector</span></strong>。一般来说，你并不需要使用_cmd(这也可能是为什么你从来没有听说过_cmd的原因)。</p>

<p>为了观察Objective-C方法是如何被调用的，现在将如下方法添加到ViewController中：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)foo {
    int add = [self addValue:12 toValue:34];
    NSLog(@"add = %i", add);
}</pre>


<p>重新生成汇编文件，然后寻找<strong><span style="color: #339966;">&#8220;&ndash;[ViewController foo]&#8220;:</span></strong>，应该能看到类似如下的代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">"-[ViewController foo]":
@ 1:
    push    {r7, lr}
@ 2:
    movw    r1, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))
    movt    r1, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))
LPC1_0:
    add r1, pc
@ 3:
    ldr r1, [r1]
@ 4:
    movs    r2, #12
    movs    r3, #34
@ 5:
    mov r7, sp
@ 6:
    blx _objc_msgSend
@ 7:
    mov r1, r0
@ 8:
    movw    r0, :lower16:(L__unnamed_cfstring_-(LPC1_1+4))
    movt    r0, :upper16:(L__unnamed_cfstring_-(LPC1_1+4))
LPC1_1:
    add r0, pc
@ 9:
    blx _NSLog
@ 10:
    pop {r7, pc}</pre>


<p>同样，这与之前C语言产生的汇编代码非常相似，我们也来看看具体都做了些什么：</p>

<p>1、将r7和lr push到栈中。</p>

<p>2、利用pc(program counter)将标签<strong><span style="color: #339966;">L_OBJC_SELECTOR_REFERENCES_</span></strong>对应的值装载到r1寄存器中。这个标签引用到一个selector。实际上selector就是一个字符串，并且存储在数据段中(data segment)。</p>

<p>3、如果在汇编文件中搜索L_OBJC_SELECTOR_REFERENCES_，会看到如下内容：</p>

<pre class="wp-code-highlight prettyprint linenums:1"> L_OBJC_SELECTOR_REFERENCES_:     .long   L_OBJC_METH_VAR_NAME_</pre>


<p>r1会指向这里(<strong><span style="color: #339966;">L_OBJC_SELECTOR_REFERENCES_</span></strong>)，这个标签包含了另外一个标签：<strong><span style="color: #339966;">L_OBJC_METH_VAR_NAME_</span></strong>。在文件中查找这个标签(<strong><span style="color: #339966;">L_OBJC_METH_VAR_NAME_</span></strong>)，会找到这样的字符串：addValue:toValue:。</p>

<p>而指令<strong><span style="color: #339966;">ldr r1, [r1]</span></strong>的作用：对r1中存储的地址进行解引用(dereferencing)，然后将得到的值放到r1中。如果用C伪代码看起来应该是这样的：r1 = *r1。仔细想想的话，可能你应该知道r1将会存储着指向字符串addValue:toValue: 的指针。</p>

<p>4、将常量装载到r2和r3中。</p>

<p>5、 将sp保持到r7寄存器中。</p>

<p>6、这是一个分支(branch)，<strong><span style="color: #339966;">以带链接跳转和根据情况切换指令集的模式</span></strong>来调用objc_msgSend方法。这是Objective-C runtime中非常重要的一个方法——它根据传递的参数找到并调用相关的函数。</p>

<p>该方法使用到了4个参数(r0-r3)。因此，在上面的代码中，将selector装载到r1中，另外两个参数(12和34)装载到r2和r3中。<strong><span style="color: #339966;">注意：在此并没有明确的装载r0，因为r0已经存储着self变量了。</span></strong></p>

<p>7、调用addValue:toValue:的返回值被存放在r0中。这里的指令将这个结果值保持到r1中。在接下来调用NSLog函数时会用到这个值。</p>

<p>8、将NSLog用到的第一个字符串参数装载到r0中。这跟之前介绍的用C函数里面调用printf一样。</p>

<p>9、这是一个分支(branch)，<strong>以<span style="color: #339966;">带链接跳转和根据情况切换指令集的模式</span></strong>来调用NSLog方法。</p>

<p>10、从栈中pop出两个值，并放入r7和pc寄存器中。这跟之前一样，从foo方法中返回。</p>

<p>如上所见，由C和Objective-C代码生成汇编指令，区别不是太大。只不过在Objective-C生成的汇编指令中，会隐示的给方法传递两个参数，以及使用到的selector以字符串的形式存放在数据段中(data segment)。</p>

<h2><strong><span style="color: #339966;">Obj-C 消息发给了谁</span></strong></h2>

<p>上面我们看到了<strong><span style="color: #339966;">objc_msgSend</span></strong>方法。可能你在crash log中已经看到过这个方法。该方法是Objective-C runtime中的一个核心方法。runtime包含了内存管理以及类的相关处理。</p>

<p>每次调用Objective-C方法时，都由objc_msgSend方法(这是一个C方法)处理消息的派送(dispatching)。该方法根据传递的消息类型在类的方法列表中查找被调用方法的实现。objc_msgSend方法的签名(signature)看起来是这样的：</p>

<pre class="wp-code-highlight prettyprint linenums:1">id objc_msgSend(id self, SEL _cmd, ...)</pre>


<p>在方法执行期间，第一个参数是self。在方法中写的一些代码，例如self.someProperty，其中self就是来自自objc_msgSend方法中的self参数。</p>

<p>第二个参数很少人会知道，这也是一个被隐藏的参数(hidden parameter)。如果在Objective-C方法中，写这类似这样的代码：<strong><span style="color: #339966;">NSLog(@&#8221;%@&#8221;, NSStringFromSelector(_cmd));</span></strong> ，会看到控制台输出了当前的selector。</p>

<p>剩下的参数一般就是开发者传递给该方法的参数了。所以如果一个方法携带两个参数，例如上面的<strong><span style="color: #339966;">addValue:toValue:</span></strong>，那么还会携带额外的两个参数。因此，我们也可以用下面的代码来代替通过Objective-C方式的调用：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)foo {
    int add = (int)objc_msgSend(self, NSSelectorFromString(@"addValue:toValue:", 12, 34);
    NSLog(@"add = %i", add);
}</pre>


<p><span style="color: #993366;">注意：虽然objc_msgSend的返回值类型是id，不过在上面的代码中将其转换为int类型了。因为它们 的size是相同的，所以转换为int不会有问题。如果该方法返回的是不同的size，那么实际上是别的函数被调用了，更多内容请看这里：<span style="text-decoration: underline; color: #339966;"><strong><a href="http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html"><span style="color: #339966; text-decoration: underline;">here</span></a></strong></span>。同样，如果返回的是一个floating指针，那么则是objc_msgSend的另一个变种被调用了，更多内容请看这里：<span style="text-decoration: underline; color: #339966;"><strong><a href="http://sealiesoftware.com/blog/archive/2008/11/16/objc_explain_objc_msgSend_fpret.html" target="_blank"><span style="color: #339966; text-decoration: underline;">here</span></a></strong></span>。</span></p>

<p>当一个Objective-C方法被编译的时候，上面用C写的等效方法签名应该是这样的：</p>

<pre class="wp-code-highlight prettyprint linenums:1">int ViewController_addValue_toValue(id self, SEL _cmd, int a, int b)</pre>


<p>对此为什么会这样，现在应该不会感觉到奇怪——这样的签名是为了与objc_msgSend相匹配！也就是说当objc_msgSend在查找并跳转到对应方法时，所有的这些参数都应该在正确的地方。</p>

<p>这里可以看到更多关于objc_msgSend相关内容：<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html" target="_blank"><span style="color: #339966; text-decoration: underline;">文章1</span></a></span></strong></span>，<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://sealiesoftware.com/blog/archive/2008/09/22/objc_explain_So_you_crashed_in_objc_msgSend.html" target="_blank"><span style="color: #339966; text-decoration: underline;">文章2</span></a></span></span></strong>。</p>

<h2><strong><span style="color: #339966;">你现在可以进行逆向工程了</span></strong></h2>

<p>根据上面对ARM汇编的介绍，你应该可以能够知道为什么有些代码被breaking、crashing或者没有正确的执行。</p>

<p>通过观察相关的汇编代码，可以更加清楚的获知到引起bug的详细步骤。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/interrogation.png"><img class="alignnone size-full wp-image-1465" alt="interrogation" src="http://beyondvincent.com/wp-content/uploads/2013/06/interrogation.png" width="651" height="241" /></a></p>

<p>有时候，你可能无法查看源代码——例如，你遇到的bug是发生在第三方库或者系统的framework中。此时，通过汇编指令进行分析可以帮助你迅速的找到问题。下面的目录存放着iOS SDK中所有的framework：</p>

<p>&lt;Path_to_Xcode>/Contents/Developer/Platforms/iPhoneOS.platform/Developer/ SDKs/iPhoneOS6.1.sdk/System/Library/Frameworks</p>

<p>我建议使用<strong><span style="color: #339966;"><a href="http://www.hopperapp.com/" target="_blank"><span style="color: #339966;">HopperApp</span></a></span></strong>对这些库进行分析。该软件能够对二进制文件进行反汇编——这样你就可以看库中的内容了——这样做是没有问题的！！！例如，打开UIKit，就可以看到每个方法都做了什么。如下图所示：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/05-HopperApp-1.png"><img class="alignnone size-full wp-image-1466" alt="05-HopperApp-1" src="http://beyondvincent.com/wp-content/uploads/2013/06/05-HopperApp-1.png" width="1015" height="231" /></a></p>

<p>上图中的汇编代码是<strong><span style="color: #339966;">[UINavigationController shouldAutorotateToInterfaceOrientation] </span></strong>方法相关的。结合之前介绍的ARM汇编知识，相信上面的汇编代码具体做了些什么你应该能看出来。</p>

<p>首先是将一个selector引用装载到ri寄存器中，以供后续调用objc_msgSend使用。然后可以看到，别的寄存器并没有做任何改动，所以我们可以知道传递给objc_msgSend方法的self指针(存储在r0中)，跟传递给<strong><span style="color: #339966;">shouldAutorotateToInterfaceOrientation</span></strong>方法的self是同一个。</p>

<p>同理，我们可以知道被调用方法携带一个参数(代码中有一列是用来显示相关名称的)。由于r2寄存器没有改动过，所以这个参数就是从shouldAutorotateToInterfaceOrientation方法传入的。</p>

<p>最后，函数调用之后，r0没有改动过，所以被调用函数的返回值就是调用函数的返回值。</p>

<p>这样一来，就可以推断出这个方法的实现应该是这样的了：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (BOOL)shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation)interfaceOrientation {
    return [self _doesTopViewControllerSupportInterfaceOrientation:interfaceOrientation];
}</pre>


<p>cool！很容易吧！虽然大多数方法都比上面的这个要复杂，不过你可以根据汇编指令拼凑出一些代码，进而快速的确定这些代码做了些什么。</p>

<p><strong style="font-size: 1.5em;"><span style="color: #339966;">何去何从</span></strong></p>

<p>这篇关于iOS汇编的教程向你介绍了一些运行在iOS设备中的ARM汇编指令核心概念。你应该学习到了C和Objective-C相关的一些调用约定。</p>

<p>通过本文介绍的知识，当你的程序在使用系统库crash时，你可以对所有能看到的随机代码进行分析。当然，你也可以通过汇编指令来准确的分析你自己写的方法。</p>

<p>如果你希望更加深入的了解ARM，请看这里：<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.raspberrypi.org/"><span style="color: #339966; text-decoration: underline;">Raspberry Pi</span></a></span></span></strong>。这里的涉及到的小型设备都拥有ARM处理器，跟iOS设备非常相似，同时也有许多教程可以教你如何对这些设备进行编程。</p>

<p>另外，NEON也值得去学习了解。这是另外扩展的一套指令集，自iPhone 3GS以来设备中的所有处理器，都支持NEON指令集。该指令集提供了SIMD(单指令，多数据——Single Instruction Multiple Data)指令，对数据的处理非常高效，例如，图片的处理。如果你需要对数据进行高效的处理，那么最好学习一下如何直接写NEON指令，并结合使用内联汇编(inline assembly)。这个指令集非常的先进！</p>

<p>这应该够你忙乎一阵了:]。</p>

<div style="text-align: left;">
  <span style="color: #808080;">本文由<span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-20</time></span>
</div>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-06-19T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jun 19<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/06/19/90/" itemprop="url">iOS汇编教程：ARM(1)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>注：本文由破船译自：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.raywenderlich.com/37181/ios-assembly-tutorial" target="_blank"><span style="color: #339966; text-decoration: underline;">raywenderlich</span></a></span></strong></span><br/>
感谢<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://blog.devtang.com/" target="_blank"><span style="color: #339966; text-decoration: underline;">唐巧</span></a></span></strong></span>抽出时间对本文进行double-check。</p>

<div id="attachment_1399" class="wp-caption alignright" style="width: 264px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/06/SpeakAssemblySmall.png"><img class="wp-image-1399 " alt="SpeakAssemblySmall" src="http://beyondvincent.com/wp-content/uploads/2013/06/SpeakAssemblySmall.png" width="254" height="254" /></a><p class="wp-caption-text">
    你说的是汇编吗？
  </p>
</div>


<p>我们写的Objective-C代码，最终会被转换为机器代码 —— 由ARM处理器能识别的1和0组成。实际上，在机器代码之间，还有一门人类可以阅读的语言 —— 汇编语言。</p>

<p>了解汇编，可以深入到你的代码里面进行调试和优化的探索，并有助于你对Objective-C运行时(runtime)的理解，同时也能满足你内心的好奇！</p>

<p>在这篇iOS汇编教程中，你能学到：</p>

<ul>
<li><strong><span style="color: #339966;">什么是汇编</span></strong> —— 以及为什么需要关注它。</li>
<li><strong><span style="color: #339966;">如何阅读汇编</span></strong> —— 特别是由Objective -C生成的汇编。</li>
<li><strong><span style="color: #339966;">在调试的时候如何使用assembly view</span></strong> —— 遇到一个bug或者crash，看看到底是怎么回事，这非常有用。</li>
</ul>


<p>为了有效吸收本文内容，建议本文的读者对象为已经熟悉Objective-C编程了。当然，你也应该要知道一些简单的计算机科学相关概念，例如栈、CPU以及它们是如何运行的。如果你对CPU不太熟悉，建议在阅读本文之前，先看看这里的内容：<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://www.howstuffworks.com/microprocessor.htm" target="_blank"><span style="color: #339966; text-decoration: underline;">微处理器的工作原理</span></a></span></span></strong>。</p>

<p>目录[分两篇文章翻译]：</p>

<h2><strong><span style="color: #339966;">iOS汇编教程：ARM(1)</span></strong></h2>

<ul>
<li><strong><span style="color: #339966;">开始：什么是汇编</span></strong></li>
<li><strong><span style="color: #339966;">函数调用约定</span></strong></li>
<li><strong><span style="color: #339966;">创建工程</span></strong></li>
<li><strong><span style="color: #339966;">加法(addFunction)</span></strong></li>
</ul>


<h2><span style="text-decoration: underline;"><a href="http://beyondvincent.com/?p=1434" target="_blank"><strong><span style="color: #339966; text-decoration: underline;">iOS汇编教程：ARM(2)</span></strong></a></span></h2>

<ul>
<li><strong><span style="color: #339966;">函数的调用</span></strong></li>
<li><strong><span style="color: #339966;">Objective -C 汇编</span></strong></li>
<li><strong><span style="color: #339966;">Obj-C 消息发给了谁</span></strong></li>
<li><strong><span style="color: #339966;">你现在可以进行逆向工程了</span></strong></li>
<li><strong><span style="color: #339966;">何去何从</span></strong></li>
</ul>


<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&ndash;</p>

<h1><span style="color: #339966;"><strong>iOS汇编教程：ARM(1)</strong></span></h1>

<h2><strong><span style="color: #339966;">开始：什么是汇编</span></strong></h2>

<p>Objective-C是一门高级语言。编译器会将你的Objective-C代码编译为汇编语言代码：一门低级语言，不过还不是最低级的语言。</p>

<p>这些汇编会被汇编器(assembler)组装为机器代码——CPU可以识别的0和1。好在一般开发者并没有必要考虑机器代码，不过有时候详细的了解汇编，会非常有用。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/SpeakAssembly.png"><img class="alignnone size-full wp-image-1403" alt="SpeakAssembly" src="http://beyondvincent.com/wp-content/uploads/2013/06/SpeakAssembly.png" width="651" height="241" /></a></p>

<p>每一个汇编指令都会告诉CPU执行一个相关任务，例如“对两个数字执行加(add)操作”，或“从某个内存地址加载数据”。</p>

<p>除了主存外 ——如 iPhone 5有1GB的主存、Mac电脑可能会有8GB —— CPU还有少许的存储部件，称之为<strong><span style="color: #339966;">寄存器</span></strong>，寄存器的访问速度非常快，一个寄存器就像一个变量一样，可以存储单个值。</p>

<p>所有的iOS设备(实际上，现如今，几乎所有的移动设备)使用的CPU都是基于<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/ARM_architecture" target="_blank"><span style="color: #339966; text-decoration: underline;">ARM架构</span></a></span></strong></span>。 ARM芯片使用的指令集是<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computing" target="_blank"><span style="color: #339966; text-decoration: underline;">RISC</span></a></span></span></strong>(精简指令集)，该指令集非常的精简，并且易读（比<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/X86" target="_blank"><span style="color: #339966; text-decoration: underline;">x86</span></a></span></span></strong>的指令集精简多了）。</p>

<p>一个汇编指令(或者语句)看起来如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">mov r0, #42</pre>


<p>上面的这行汇编指令，涉及到好多命令(或操作)。mov的作用是对数据进行移动。在ARM汇编指令中，目标是第一个，所以，上面的指令是将值42移动到寄存器r0中。再来看看下面的代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">ldr   r2, [r0]
ldr r3, [r1]
add r4, r2, r3</pre>


<p>上面汇编指令的作用是首先将寄存器r0和r1中的值装载到寄存器r2和r3中，然后对寄存器r2和r3中的值进行加(add)操作，加的结果存放到r4中。</p>

<p>很容易看懂吧！</p>

<h2><strong><span style="color: #339966;">函数调用约定</span></strong></h2>

<p>要想理解汇编代码，首先重要的事情就是理解代码之间的交互——意思是一个函数调用另一个函数的方式。这包括了参数如何传递以及如何从函数返回结果——称之为调用的约定。编译器必须严格的遵守相关标准进行代码编译，这样生成的代码，才能够相互兼容。</p>

<p>上面讨论过，寄存器是的存储空间非常少，并且靠近CPU——用来存储当前使用的一些值。ARM CPU有16个寄存器：r0到r15。每个寄存器为32bit。调用约定规定了这些寄存器的特定用途。如下：</p>

<ul>
<li> r0 &#8211; r3：存储传递给函数的参数值。</li>
<li> r4 &#8211; r11：存储函数的局部变量。</li>
<li>r12：是内部过程调用暂时寄存器（intra-procedure-call scratch register）。</li>
<li>r13：存储栈指针(sp)。在计算机中，栈非常重要。这个寄存器保存着栈顶的指针。这里可以看到更多关于栈的信息：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/Call_stack"><span style="color: #339966; text-decoration: underline;">Wikipedia</span></a></span></strong></span>。</li>
<li>r14：链接寄存器(link register)。存储着当被调用函数返回时，将要执行的下一条指令的地址。</li>
<li>r15：用作程序计数器(program counter)。存储着当前执行指令的地址。每条执行被执行后，该计数器会进行自增(+1)。</li>
</ul>


<p>这里可以看到更多相关ARM 调用约定的内容：<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf"><span style="color: #339966; text-decoration: underline;">this document from ARM</span></a></span></span></strong>。苹果公司也给出了一份文档详细介绍了在iOS开发中的调用约定： <span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/iPhoneOSABIReference.pdf"><span style="color: #339966; text-decoration: underline;">calling convention used for iOS development</span></a></span></span>。</p>

<p>下面我们就从代码上开始真正的认识汇编。</p>

<h2><strong><span style="color: #339966;">创建工程</span></strong></h2>

<p>打开Xcode，<strong><span style="color: #339966;">File\New\New Project</span></strong>，选择<strong><span style="color: #339966;">iOS\Application\Single View Application</span></strong>，然后点击<strong><span style="color: #339966;">Next</span></strong>，工程的配置如下：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/01-Create-the-project.png"><img class="alignnone size-full wp-image-1416" alt="01-Create-the-project" src="http://beyondvincent.com/wp-content/uploads/2013/06/01-Create-the-project.png" width="1394" height="841" /></a></p>

<ul>
<li><strong><span style="color: #339966;">Product name</span></strong>: ARMAssembly</li>
<li><strong><span style="color: #339966;">Company Identifier</span></strong>: 一般为反向的DNS标示</li>
<li><strong><span style="color: #339966;">Class Prefix</span></strong>: 空白</li>
<li><strong><span style="color: #339966;">Devices</span></strong>: iPhone</li>
<li><strong><span style="color: #339966;">Use Storyboards</span></strong>: No</li>
<li><strong><span style="color: #339966;">Use Automatic Reference Counting</span></strong>: Yes</li>
<li><strong><span style="color: #339966;">Include Unit Tests</span></strong>: No</li>
</ul>


<p>点击 Next 选择工程存储的位置——完成工程的创建。</p>

<h2><span style="color: #339966;">加法(addFunction)</span></h2>

<p>下面我们写一个加法函数：对两个数进行相加，然后返回结果。这里我们先用C语法写，后面再介绍用OC来写（OC稍微复杂一点）。在工程的Supporting Files目录中打开<strong><span style="color: #339966;">main.m</span></strong>文件，然后将下面的函数拷贝并粘贴到文件的顶部。</p>

<pre class="wp-code-highlight prettyprint linenums:1">int addFunction(int a, int b) {
    int c = a + b;
    return c;
}</pre>


<p>现在将Xcode中的scheme设置为为设备构建:选中iOS Device作为scheme target(如果你将设备连接到电脑中，会现实&lt;你的设备名称>，如“Matt Galloway的iPhone 5”)——这样选择之后，生成的汇编就是针对ARM的，而不是针对x86(模拟器使用)。Xcode的选择效果如下图所示：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/02-Select-iOS-Device-scheme.png"><img class="alignnone size-full wp-image-1420" alt="02-Select-iOS-Device-scheme" src="http://beyondvincent.com/wp-content/uploads/2013/06/02-Select-iOS-Device-scheme.png" width="291" height="49" /></a></p>

<p>&nbsp;</p>

<p>然后选择:<strong><span style="color: #339966;">Product\Generate Output\Assembly File</span></strong>。过一会之后，Xcode会生成一个文件，这个文件里面有很多行都有下划线__。在文件的顶部,好多行都是以<strong><span style="color: #339966;">.section</span></strong>开头。接着选中<strong><span style="color: #339966;">Show Assembly Output For</span></strong>中的<strong><span style="color: #339966;">Running</span></strong>。</p>

<p><span style="color: #993300;">  注意:默认情况下,使用的是debug scheme中的设置信息,所以默认选中的就是Running。在debug模式下，编译器对代码没有做优化处理——首先观察没有进过优化处理的汇编，更利于理解代码具体都发生了什么。</span></p>

<p>在生成的文件中搜索_addFunction,会看到类似如下的代码:</p>

<pre class="wp-code-highlight prettyprint linenums:1">.globl    _addFunction
    .align  2
    .code   16                      @ @addFunction
    .thumb_func _addFunction
_addFunction:
    .cfi_startproc
Lfunc_begin0:
    .loc    1 13 0                  @ main.m:13:0
@ BB#0:
    sub sp, #12
    str r0, [sp, #8]
    str r1, [sp, #4]
    .loc    1 14 18 prologue_end    @ main.m:14:18
Ltmp0:
    ldr r0, [sp, #8]
    ldr r1, [sp, #4]
    add r0, r1
    str r0, [sp]
    .loc    1 15 5                  @ main.m:15:5
    ldr r0, [sp]
    add sp, #12
    bx  lr
Ltmp1:
Lfunc_end0:
    .cfi_endproc</pre>


<p>上面的代码看起来有点凌乱,实际上也不难以读懂。我们来看看，首先，所有以&#8221;.&#8221;开头的代码行都不是汇编指令,我们可以忽略所有这些以&#8221;.&#8221;开头的代码行。</p>

<p>代码中以冒号结尾的的代码行(例如<strong><span style="color: #339966;">_addFunction</span></strong>:和<strong><span style="color: #339966;">Ltim0</span></strong>: )，我们称之为标签（<strong><span style="color: #339966;">label</span></strong>）。这些标签的作用是给汇编代码片段指定相关的名字.名为<strong><span style="color: #339966;">_addFunction</span></strong>:的标签,实际上是一个函数的入口点.</p>

<p>这个标签(<span style="color: #339966;"><strong>_addFunction</strong></span>: )是必须有的:别的代码调用addFunction函数时,并不需要知道该函数具体在什么地方,通过简单的一个符号或标签就可以进行调用.在最终生成程序二进制文件时,链接器会把这个标签转换到实际的地址.</p>

<p>我们需要注意的时,编译器总是会在函数名前面添加一个下划线——这仅仅是一个约定。另外，其他所有的标签都是以<strong><span style="color: #339966;">L</span></strong>开头——这些通常称为局部标签(local label)，只会在函数内部使用。在上面的代码中，虽然没有实际用到局部标签，不过编译器还是为我们生成了一些——之所以会生成这些没有被使用到的局部标签，是由于代码还没有做任何的优化处理。</p>

<p>注释是以<strong><span style="color: #339966;">@</span></strong>字符开头。通过上面的分析,这样一来，忽略掉注释和标签，代码看起来如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">_addFunction:
@ 1:
    sub sp, #12
@ 2:
    str r0, [sp, #8]
    str r1, [sp, #4]
@ 3:
    ldr r0, [sp, #8]
    ldr r1, [sp, #4]
@ 4:
    add r0, r1
@ 5:
    str r0, [sp]
    ldr r0, [sp]
@ 6:
    add sp, #12
@ 7:
    bx  lr</pre>


<p>下面我们来看看代码中每部分汇编都做了什么:</p>

<p>1、首先，在栈(stack)创建临时存储所需要的空间。栈提供了许多内存供函数使用。ARM中的栈是向下延伸的,也就是说,在栈上创建一些空间,需要从栈指针开始减去(subtract)一些空间。在这里，预留了12个字节。</p>

<p>2、r0和r1用来存储传递给调用函数的参数值。如果函数有4个参数，那么会把r2和r3当做第三个和第四个参数。如果函数的参数超过了4个，或者携带的参数不适合使用32位的寄存器（例如很大的数据结构），那么可以通过栈来传递这些参数。</p>

<p>在这里,两个参数被保存到栈中。这是由存储寄存器(str)指令完成的。</p>

<p>上面的指令可以指定一个偏移量,用来应用在某个值上面。所以[sp, #8]的意思是存储至“栈指针寄存器+8的地方”,因此,str r0, [sp, #8]的作用是：将寄存器r0中的内容存储到栈指针(加8)指向的内存地址.</p>

<p>3、将刚刚保存到栈中的值读取至相同的寄存器中(r0和r1)。这里，的ldr指令与str指令刚好相反，ldr(load register)会把指定内存位置中的的内容加载到寄存器中。ldr和str的语法非常相似：ldr r0, [sp, #8]的作用是“将栈指针加8后指向的地址内容加载到r0寄存器中”。</p>

<p>这里你可能会感觉到奇怪,为什么ro和r1寄存器中的值刚刚保存,马上又将其加载回来,答案是:这两行代码是冗余的,可以去掉!如果编译器做了优化处理,那么这些冗余的代码会被忽略掉.</p>

<p>4、这是该函数中最终的要一个指令:执行加操作。该执行的意思是：将r0和r1中的内容进行相加，然后把结果放到r0中。</p>

<p>add指令可以是两个参数,也可以是三个参数.如果指定三个参数,那么第一个参数就被当做目标寄存器,剩下的两个则为源寄存器.因此,这里的指令可以写成这样:add r0, r0, r1。</p>

<p>5、同样，编译器生成了一些冗余代码：将加的结果存储到栈中，接着立即从栈中读取回来。</p>

<p>6、终止函数的地方：将栈指针指向调用addFunction函数时的最初地方。addFunction开始于：sp减去12的地方：预留了12个字节。现在将12加回去即可。这里必须确保栈指针的正确操作，否则栈指针会指向错误的地方。</p>

<p>最后,执行bx指令会回到调用函数的地方.这里的寄存器lr是链接寄存器(link register)，该存储器存储着将要执行的下一条指令。注意,addFunction返回之后,r0寄存器会存储着该函数相加的结果值——这也是调用约定中的一部分：函数的返回值永远都被存储在r0寄存器中。除非一个寄存器不够存储，这是可以使用r1-r3。</p>

<p>上面就是所有相关addFunction的介绍,并不复杂吧?预知关于这些指令的更多内容,请看这里: <span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf"><span style="color: #339966; text-decoration: underline;">ARM website</span></a></span></strong></span>.</p>

<p>重申一下,上面的方法有好多冗余的地方:这是由于编译器处于debug模式,不会对代码做优化处理.如果对代码进行了优化处理,会看到生成的汇编代码非常的少。</p>

<p>选中<strong><span style="color: #339966;">Show Assembly Output For</span></strong>中的<strong><span style="color: #339966;">Archiving</span></strong>。然后搜索_addFunction:，会看到如下指令（只有这些）：</p>

<pre class="wp-code-highlight prettyprint linenums:1">_addFunction:
    add r0, r1
    bx  lr</pre>


<p>这看起来非常简洁:只需要两条指令就完成了addFunction函数的功能。当然，在实际开发中，一个函数一般都会有好多指令。</p>

<p>现在,这个addFunction已经返回到调用的函数那里了.下面我们就来看看关于调用的函数的相关信息.</p>

<p>下面的内容会在第二篇文章中翻译：</p>

<h1><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/?p=1434" target="_blank"><span style="color: #339966; text-decoration: underline;"><strong>iOS汇编教程：ARM(2)</strong></span></a></span></span></h1>

<ul>
<li><span style="color: #339966;"><strong>函数的调用</strong></span></li>
<li><span style="color: #339966;"><strong>Objective &#8211; C 汇编</strong></span></li>
<li><span style="color: #339966;"><strong>Obj-C 消息发给了谁</strong></span></li>
<li><span style="color: #339966;"><strong>你现在可以进行逆向工程了</strong></span></li>
<li><span style="color: #339966;"><strong>何去何从</strong></span></li>
</ul>


<div style="text-align: left;">
  <span style="color: #808080;">本文由<span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-19</time></span>
</div>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-06-17T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jun 17<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/qi-ta/'>其它</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/06/17/89/" itemprop="url">父爱天天有</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>2013年6月16日是父亲节，祝愿天下的父亲们都身体都健康！</p>

<p><strong><span style="color: #339966;">注1</span></strong>：首先感谢<span style="text-decoration: underline;"><a href="http://www.weibo.com/lancy1014" target="_blank"><span style="color: #339966; text-decoration: underline;">@晨钰Lancy</span></a></span>对我昨天文章<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a title="固定链接到 iOS7新特征汇总[05]初窥UIKit动力(UIKit Dynamics)" href="http://beyondvincent.com/2013/06/16/ios7%e6%96%b0%e7%89%b9%e5%be%81%e6%b1%87%e6%80%bb05%e5%88%9d%e7%aa%a5uikit%e5%8a%a8%e5%8a%9buikit-dynamics/" rel="bookmark"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总[05]初窥UIKit动力(UIKit Dynamics)</span></a></span></span>中的一个错误进行提醒：UIKit Dynamics中UIGravityBehavior的重力单位应该是UIKit Gravity。我已经对博文和相关代码进行了修改。另外，由于笔者才学疏浅，如果大家在看我博文的时候遇到不对的地方，请狠批我，我已经做好准备迎接大家手里的板砖、鸡蛋和手机啦。</p>

<p><strong><span style="color: #339966;">注2</span></strong>：最近几天连续的学习iOS7新东西（白天上班，晚上基本都是在看WWDC和iOS7相关的内容），一者会有点累，再者感觉对新知识点消化吸收效率不是太高，在写博文的时候，会容易出错，误导大家——为了身体能够健康的生产（身体是父母给的，至少要让父母少担心），文章能够准确的输出，在后面的文章中，不能确保一天出一篇，在时间和精力允许的情况下，我尽量！另外，大家也可以跟我反馈感兴趣的topic，我会优先考虑。</p>

<p><strong><span style="color: #339966;">注3</span></strong>：今天不会有新的技术与大家分享！大家如果对我的博文感兴趣，可以收藏我的博客站点：<span style="text-decoration: underline;"><a href="http://BeyondVincent.com" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://BeyondVincent.com">http://BeyondVincent.com</a></span></a></span>。也可以关注我的微博：<span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.weibo.com/beyondvincent" target="_blank"><span style="color: #339966; text-decoration: underline;">@BeyondVincent</span></a></span></span>。</p>

<h2><span style="color: #339966;">今天的正文</span></h2>

<p>2013年6月16日是父亲节。好久没有跟父亲联络了，还记得上一次联络是2周前父亲跟我打电话，我与父亲联络比较少，基本都是跟母亲联络。</p>

<p>还记得，刚毕业那会，从云南去北方(大连)工作的时候，父亲经常跟我说有空要去大连游玩一下，结果直到离开大连的时候，也没有完成父亲的这个小心愿，后来，在北京呆了一段时间，也希望有时间带上父亲，去首都转转，结果还是没能如愿。再后来，父亲没有再提游玩的事情。现如今，我人已回云南，想想父亲辛劳了好多年，自己却很难孝敬，心里时常会感觉内疚。现在唯一能孝敬父亲，并让父亲安心的就是做到让自己身体健康。也希望，尽快完成父亲的小心愿。</p>

<p>与父亲一起合影的次数并不太多，而单独与父亲合影，只有下面这张！</p>

<h1><span style="color: #339966;">在这里祝愿我的父亲身体健康！</span></h1>

<h1><span style="color: #339966;">也祝愿天下所有人的父亲身体健康！</span></h1>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/%E7%88%B6%E5%AD%90.jpg"><img class="alignnone size-full wp-image-1389" alt="父子" src="http://beyondvincent.com/wp-content/uploads/2013/06/父子.jpg" width="670" height="502" /></a></p>

<div>
  本文由<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-17</time>
</div>




		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="/blog/page/4/" class="prev">Prev</a>
    
    
        <a href="/blog/page/6/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">所有文章</a></div>
    
    <script type="text/javascript">
var duoshuoQuery = {short_name:"beyondvincent"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
</nav>

</div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2014 - 破船(BeyondVincent) -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'beyondvincent001';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-42893468-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>





<script type="text/javascript">
    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F1a3c98825a726bfbf68a83ba97e0b9be' type='text/javascript'%3E%3C/script%3E"));
    </script>

		</div>
	</div>
</body>
</html>
