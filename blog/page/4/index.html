
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>破船之家</title>
	<meta name="author" content="破船(BeyondVincent)">

	
	<meta name="description" content="Jul 3rd, 2013 iOS7新特征 iOS7新特征汇总[06]What&#8217;s New in Cocoa Touch学习笔记 提醒：这里是新特征汇总博文链接：iOS7新特征汇总 今晚看了一下WWDC2013的session：What&#8217;s New in Cocoa &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="破船之家" type="application/atom+xml">
	
	<link rel="canonical" href="http://BeyondVincent.github.io/blog/page/4/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='http://www.gravatar.com/avatar/" + MD5("beyondvincent@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">破船之家</a></h1>
<p class="subtitle">宠辱不惊，闲看庭前花开花落<br>去留无意，漫随天外云卷云舒<br>不妄取，不妄予，不妄想，不妄求<br>与人方便，随遇而安</p>
<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
  <li><a href="/about">关于我</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/beyondvincent" title="Weibo">Weibo</a>
		
		
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav></header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-07-03T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jul 3<span>rd</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios7xin-te-zheng/'>iOS7新特征</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/07/03/95/" itemprop="url">iOS7新特征汇总[06]What&#8217;s New in Cocoa Touch学习笔记</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>提醒：这里是新特征汇总博文链接：<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/2013/06/11/ios7%E6%96%B0%E7%89%B9%E5%BE%81%E6%B1%87%E6%80%BB/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总</span></a></strong></span></span></p>

<p>今晚看了一下WWDC2013的session：<strong><span style="color: #ff0000;">What&#8217;s New in Cocoa Touch</span></strong></p>

<p>该session介绍了iOS 7中Cocoa Touch里面新增的许多内容。</p>

<p>下面是一些学习笔记，供大家参考一下（<strong><span style="color: #339966;">由于是边看边记录，如有文字录入错误，还请见谅</span></strong>）：</p>

<h2><strong><span style="color: #339966;">1、Multitasking</span></strong></h2>

<p><span style="color: #339966;">Background fetching</span><br/>
you must call this at launch<br/>
<span style="color: #339966;">Remote notification</span><br/>
Method: didReceiveRemoteNotification<br/>
call the completion handler when fetch is complete<br/>
<span style="color: #339966;">Background transfers</span><br/>
Method: handleEventsForBackgroundURLSession<br/>
NSURLSession replace API for NSURLConnection<br/>
Data upload download task<br/>
session have identifiers</p>

<h2><strong><span style="color: #339966;">2、view and image</span></strong></h2>

<p><span style="color: #339966;"> Image Rendering Modes</span><br/>
Creating image with redering mode<br/>
method: imageWithRenderingMode:<br/>
param: UIImageRenderingMode<br/>
<span style="color: #339966;">Tint</span><br/>
New UIView property<br/>
@property (nonatomic, retain) UIColor *tintColor;<br/>
Dimming adjustment behavior<br/>
@property (nonatomic) UIViewTintAdjustmentMode tintAdjustmentMode;<br/>
Finding out about changes<br/>
&ndash;(void) intColorDidChange;<br/>
<span style="color: #339966;">View Animation</span><br/>
No animations!<br/>
+(void)performWithoutAnimation:<br/>
Keyframes<br/>
+(void)animationKeyframesWithDuration<br/>
+(void)addKeyframeWithRelativeStartTime:<br/>
UIViewKeyframeAnimationOptions</p>

<h2><strong><span style="color: #339966;">3、Motion Effects</span></strong></h2>

<p>Applies relative values to key paths of a target view<br/>
Affected by device &#8220;pose&#8221; or position<br/>
Affects animatable properties only</p>

<p>class: UIInterpolatingMotionEffect<br/>
initialization——initWithKeyPath:<br/>
UIMotionEffect<br/>
abstract superclass<br/>
one method<br/>
keyPathsAndRelativeValuesForViewerOffset:<br/>
UIOffset: CGFloat horizontal, vertical;<br/>
<span style="color: #339966;">UIView</span><br/>
adding and removing motion effects<br/>
addMotionEffect:<br/>
removeMotionEffect:<br/>
@property (copy, nonatomic) NSArray *motionEffects;</p>

<h2><strong><span style="color: #339966;">4、Collection Views</span></strong></h2>

<p><span style="color: #339966;"> Transitions between layouts</span><br/>
method: setCollectionViewLayout: animated: completion<br/>
<span style="color: #339966;">UICollectionViewTransitionLayout</span></p>

<h2><strong><span style="color: #339966;">5、View Controllers</span></strong></h2>

<p><span style="color: #339966;"> Layout</span><br/>
wantsFullScreenLayout<br/>
deprecated in iOS 7.0<br/>
extended edges<br/>
content size<br/>
@property (nonatomic) CGSize preferredContentSize;<br/>
status bar appearance<br/>
new behavior for the status bar<br/>
new status bar style<br/>
UIStatusBarStyleDefault<br/>
UIStatusBarStyleLightContent (new)<br/>
// UIStatusBarStyleBlackTranslucent<br/>
// UIStatusBarStyleBlackOpaque</p>

<h2><strong><span style="color: #339966;">6、Custom Transitions</span></strong></h2>

<p>bounded &#8220;canned&#8221; transition<br/>
interactive, user-driven transition<br/>
new delegate method on UIViewController<br/>
UIViewControllerTransitioningDelegate<br/>
UIViewControllerAnimatedTransitioning<br/>
UIViewControllerInteractiveTransitioning<br/>
UIViewControllerContextTransitioning<br/>
ref: WWDC2013 Custom Transitions Using View Controllers</p>

<h2><strong><span style="color: #339966;">7、State Restoration</span></strong></h2>

<p><span style="color: #339966;"> Ignoring Snapshots</span><br/>
&ndash;(void)ignoreSnapshotOnNextApplicationLaunch;<br/>
<span style="color: #339966;">Other Objects</span><br/>
Non-view and non-view controller can now participate<br/>
method: registerObjectForStateRestoration:<br/>
<span style="color: #339966;">Bluetooth State Restoration</span></p>

<h2><strong><span style="color: #339966;">8、AirDrop</span></strong></h2>

<p>Adopt <span style="color: #339966;">UIActivityItemSourceProtocol</span><br/>
Update application&#8217;s info.plist to create, register, and export UTI for custom document formats<br/>
New Documents/Inbox directory</p>

<p><strong style="font-size: 1.5em;"><span style="color: #339966;">9、Dynamics</span></strong></p>

<p><span style="color: #339966;"><span style="color: #333333;">Fluid, responsive animations</span></span></p>

<p>Enhances the interactions in you application<br/>
Concentration on behaviors</p>

<p>class: UIDynamicAnimator<br/>
UIDynamicBehavior<br/>
UIDynamicItem</p>

<p><span style="color: #339966;">supported behaviors</span><br/>
UIAttachmentBehavior<br/>
UICollisionBehavior<br/>
UIGravityBehavior<br/>
UIPushBehavior<br/>
UISnapBehavior<br/>
UDynamicItemBehavior</p>

<h2><strong><span style="color: #339966;">10、Text</span></strong></h2>

<p><span style="color: #339966;"> Dynamic type sizing</span><br/>
@property(nonatomic, readonly) NSString * preferredContentSizeCategory;<br/>
<span style="color: #339966;">UIFont</span><br/>
Font scaling based on content size category<br/>
preferredFontForTextStyle:<br/>
<span style="color: #339966;">Text Kit</span><br/>
Objective-C API<br/>
class: NSTextStorage<br/>
NSLayoutManager<br/>
NSTextContainer<br/>
UITextView UITextField UILable<br/>
additional class<br/>
NSTextAttachment</p>

<h2><strong><span style="color: #339966;">11、More New Feathures</span></strong></h2>

<p><span style="color: #339966;"> Multipeer Connectivity</span><br/>
Local network discovery<br/>
seesion management<br/>
encryptyed sessions<br/>
file transfers<br/>
<span style="color: #339966;">SpriteKit</span><br/>
iOS 、OS X<br/>
High-performance sprite-based game framework<br/>
image atlas support<br/>
UIKit and AppKit integration<br/>
<span style="color: #339966;">Game Controller</span><br/>
Buttons<br/>
Analog joysticks<br/>
Multiple controllers<br/>
<span style="color: #339966;">MapKit</span><br/>
Directions<br/>
3D cameras<br/>
Map tile overlays<br/>
Map snapshots<br/>
Geodesic polylines</p>

<p><span style="color: #339966;">CoreLocation</span><br/>
Bluetooth LE beacons<br/>
advertising<br/>
ranging<br/>
New region types<br/>
Region monitoring<br/>
<span style="color: #339966;">Accessibility</span><br/>
Guided Access API<br/>
<span style="color: #339966;">GameCenter</span><br/>
new turn-based game API<br/>
turns tabs<br/>
mode for bidding<br/>
leader board improvements<br/>
system integrity features</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-03</time></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-07-02T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jul 2<span>nd</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>, <a class='category' href='/blog/categories/iosfan-yi/'>iOS翻译</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/07/02/94/" itemprop="url">让UIViewController中的viewDidLoad和viewWillAppear各司其责</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>注：本文由破船译自：<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://thejoeconwayblog.wordpress.com/2013/06/25/uiviewcontroller-viewdidload-vs-viewwillappear/" target="_blank"><span style="color: #339966; text-decoration: underline;">thejoeconwayblog</span></a></span></strong></span></p>

<p>你是否有过这样的感觉：有时某些代码是放到<strong><span style="color: #339966;">viewDidLoad</span></strong>还是<span style="color: #339966;"><strong>viewWillAppear</strong></span>:中，这很容易让人混淆。在Stack Overflow上经常会遇到这样的问题：<strong><span style="color: #339966;">viewDidLoad和viewWillAppear到底哪个方法先被调用？</span></strong>实际上，理解这些方法的去向，以及为什么会这样并不重要，重要的是需要知道这些方法的作用，以及它们是如何与程序协调分工的。</p>

<p>我们知道，一般iOS应用程序都是由多个view controller构成的，每个view controller代表一个屏幕的信息。而当程序与用户交互时，根据程序中不同的状态，显示不同的view controller。例如，如果用户需要注册一个账号时，屏幕上应该显示出允许用户输入个人信息的界面，当用户完成注册之后，应该能够看到相应的主页面。</p>

<p><strong><span style="color: #339966;">viewWillAppear:方法的作用是与屏幕中改变的内容进行交互。</span></strong>告诉view controller将对应的界面内容显示到屏幕最前端：确保view controller中所有的文本控件显示出最新的信息、必要的数据是可访问的、并对适当的通知(notification)进行观察等。当viewWillAppear:被触发时，说明对应的view controller变为&#8221;active&#8221;状态。</p>

<p><strong><span style="color: #339966;">那么viewDidLoad方法存在的理由又是什么呢？</span></strong>唯一的原因——有时无法或者不能有效的在XIB文件中对用户界面进行100%的配置。例如，有时希望给view设置一个特殊的属性(该属性在XIB中不可用)、有时在给一个button设置背景图片之前，希望能先对该图片进行修改、再比如，在使用auto layout时，有时你可能会意识到在XIB中进行相关操作还不如用代码来写auto layout相关的代码。</p>

<p>我们不能根据viewDidLoad方法的调用情况，来推断出应用程序的状态相关信息。viewDidLoad方法实际上就是简单的一个文件加载后处理机制。换句话说，作为开发者，应该<span style="color: #339966;"><strong>把viewDidLoad方法当做XIB文件的一个有效扩展</strong></span>，而不要理解为应用程序运转流程中的一部分。</p>

<p>这到底是什么意思呢？——我们应该在viewWillAppear:方法中对view中显示的内容进行变更，而不是在viewDidLoad中。view中的内容是程序实际运行时由controller传递给view来显示的数据(模型对象)。</p>

<p>下面我们来看一个示例：一个银行应用程序，可以显示用户当前的余额。当用户点击一个按钮时，可以在一个modal view controller中显示一个列表：该列表列出了用户附近的ATM机。在此，为了获得附近的ATM机列表信息，程序必须使用core location已经web service请求。在上面这种情况下，如果程序员把从服务器请求用户附近ATM列表的操作放到viewDidLoad中。此时，由于view controller只显示一次(viewDidLoad和viewWillAppear都只会被调用一次)，所以，从服务器请求用户附近ATM列表的操作，放到viewDidLoad与viewWillAppear中，对程序的效果都是一样的。</p>

<p>但是这样做法是不好的。想一下，如果把这个ATM view controller移到tab bar controller中，会是什么情况。现在，ATM view controller——在viewDidLoad中获取ATM信息的代码只会获取一次。所以，如果你周二在亚特兰大打开该程序查找ATM，然后查询一下余额。接着周三你去了纽约，再次打开该程序时，只能看到亚特兰大的ATM信息——view已经加载过了，所以不会再调用viewDidLoad方法。<br/>
<strong><span style="color: #ff0000;">注意：在这里应该有这样的前提条件：程序没有退出。</span></strong></p>

<p>实际上，在这种情况下，写代码时犯下了一个最大的错误：<strong><span style="color: #339966;">the easiest way is the easiest way</span></strong>。应用程序是会发生变化的，而用户界面也会发生改变。刚开始使用简单的方法，可能会在以后引发各种问题。</p>

<div style="text-align: left;">
  <span style="color: #808080;">本文由<strong><span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></strong>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-02</time></span>
</div>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-07-01T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jul 1<span>st</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/iosfan-yi/'>iOS翻译</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/07/01/93/" itemprop="url">Xcode中断点的威力</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>注：本文由破船译自：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.albertopasca.it/whiletrue/2013/06/xcode-power-of-breakpoints/" target="_blank"><span style="color: #339966; text-decoration: underline;">albertopasca</span></a></span></strong></span><br/>
本文由<strong><span style="color: #339966;">HoNooD</span></strong>在<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://iosfeed.com/view/76" target="_blank"><span style="color: #339966; text-decoration: underline;">iosfeed</span></a></span></span></strong>站点上做了推荐。</p>

<p>这里先推荐两篇Xcode相关的文章：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/2013/05/31/xcode-code-snippets/" target="_blank"><span style="color: #339966; text-decoration: underline;">Xcode Code Snippets</span></a></span></span></strong><br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"> <a href="http://beyondvincent.com/2013/05/16/ios%E4%B8%AD%E8%B0%83%E8%AF%95-%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS调试 — 基本技巧</span></a></span></span></strong></p>

<p>本文目录：</p>

<p><strong><span style="color: #339966;">1、添加一个特殊的断点</span></strong><br/>
<strong><span style="color: #339966;">    异常断点(Exception breakpoint)</span></strong><br/>
<strong><span style="color: #339966;">    符号断点(Symbolic breakpoint)</span></strong><br/>
<strong><span style="color: #339966;">2、打印到控制台</span></strong><br/>
<strong><span style="color: #339966;">    使用NSLog打印字符串</span></strong><br/>
<strong><span style="color: #339966;">    使用NSLog打印对象(po)</span></strong><br/>
<strong><span style="color: #339966;">    带条件的打印</span></strong><br/>
<strong><span style="color: #339966;">    在循环里面打印一些东西</span></strong><br/>
<strong><span style="color: #339966;">3、运行时设置断点</span></strong><br/>
<strong><span style="color: #339966;">4、调试中播放声音</span></strong><br/>
<strong><span style="color: #339966;">5、LLDB中有用的一些命令</span></strong><br/>
<strong><span style="color: #339966;">    打印帮助</span></strong><br/>
<strong><span style="color: #339966;">    打印调用栈</span></strong><br/>
<strong><span style="color: #339966;">    打印最基本的内容 (p)</span></strong><br/>
<strong><span style="color: #339966;">    打印对象(po)</span></strong><br/>
<strong><span style="color: #339966;">    打印表达式(expr)</span></strong><br/>
<strong><span style="color: #339966;">    打印线程中的一些东西</span></strong></p>

<p>&nbsp;</p>

<p>正文</p>

<p>下面是非常有用的一些Xcode调试技术(使用断点和LLDB调试器)</p>

<p>1、添加一个特殊的断点</p>

<ul>
<li>异常断点(Exception breakpoint)</li>
</ul>


<p>如果添加了异常断点，当程序每次发生了异常，都会被中断。<strong><span style="color: #339966;">一般用来捕获未知异常</span></strong>。如下示例：</p>

<pre class="wp-code-highlight prettyprint linenums:1">*** Terminating app due to uncaught exception ’NSRangeException’, reason:
’-[__NSCFArray objectAtIndex:]: index (10) beyond bounds (3)</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-01.png"><img class="alignnone size-full wp-image-1497" alt="xcode-debug-01" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-01.png" width="1049" height="654" /></a></p>

<ul>
<li>符号断点(Symbolic breakpoint)</li>
</ul>


<p>符号断点可以中断某个函数的调用。</p>

<pre class="wp-code-highlight prettyprint linenums:1">- [UIViewController viewDidLoad]
- [__NSCFArray objectAtIndex:]</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-02.png"><img class="alignnone size-full wp-image-1498" alt="xcode-debug-02" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-02.png" width="1049" height="654" /></a></p>

<p>&nbsp;</p>

<p>2、打印到控制台</p>

<ul>
<li>使用NSLog打印字符串</li>
</ul>


<p>使用断点来替换NSLog代码(或者在运行时添加一个NSLog)——与代码写NSLog的效果相同。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-04.png"><img class="alignnone size-full wp-image-1499" alt="xcode-debug-04" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-04.png" width="1030" height="654" /></a></p>

<p>&nbsp;</p>

<ul>
<li>使用NSLog打印对象(po)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">NSLog(@"obj: %@", obj);</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-05.png"><img class="alignnone size-full wp-image-1500" alt="xcode-debug-05" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-05.png" width="1030" height="654" /></a></p>

<ul>
<li>带条件的打印</li>
</ul>


<p>例如：当aNumber大于10才打印出“str”的内容。</p>

<pre class="wp-code-highlight prettyprint linenums:1">expr (void)NSLog(@"Ok, print a log: %@", str)</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-07.png"><img class="alignnone size-full wp-image-1501" alt="xcode-debug-07" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-07.png" width="1030" height="681" /></a></p>

<p>&nbsp;</p>

<ul>
<li>在循环里面打印一些东西</li>
</ul>


<p>例如，在循环中希望i大于5才开始打印。</p>

<pre class="wp-code-highlight prettyprint linenums:1">for ( int i=0; i&lt;10; i++ )
{
[self self]; // something
}</pre>


<p>使用“ignore”值，并利用下面的代码进行打印：</p>

<pre class="wp-code-highlight prettyprint linenums:1">expr (void)NSLog(@"Ok, print a log: %@", str)</pre>


<p><img class="alignnone size-full wp-image-1502" alt="xcode-debug-08" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-08.png" width="1030" height="681" /></p>

<p>3、运行时设置断点</p>

<p>在运行的时候，根据条件设置断点有时候非常有用。</p>

<pre class="wp-code-highlight prettyprint linenums:1">breakpoint set -f APViewController.m -l 33</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-09.png"><img class="alignnone size-full wp-image-1503" alt="xcode-debug-09" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-09.png" width="1030" height="681" /></a></p>

<p>4、调试中播放声音</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/Schermata-06-2456470-alle-15.43.13.png"><img class="alignnone size-full wp-image-1504" alt="Schermata-06-2456470-alle-15.43.13" src="http://beyondvincent.com/wp-content/uploads/2013/07/Schermata-06-2456470-alle-15.43.13.png" width="475" height="304" /></a></p>

<p>5、LLDB中有用的一些命令</p>

<p>当Xcode停留在某个断点时，我们可以通过控制台(console)与<strong><span style="color: #339966;">lldb</span></strong>进行交互。</p>

<ul>
<li>打印帮助</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) help</pre>


<ul>
<li>打印调用栈(bt)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) bt
* thread #1: tid = 0x1c03, 0x00003146 Debug`-[APViewController callMe:andANumber:](self=0x07187e50, _cmd=0x000038b9, str=0x0715aa40, aNum=38) + 230 at APViewController.m:33, stop reason = breakpoint 3.1
frame #0: 0x00003146 Debug`-[APViewController callMe:andANumber:](self=0x07187e50, _cmd=0x000038b9, str=0x0715aa40, aNum=38) + 230 at APViewController.m:33
frame #1: 0x0000304a Debug`-[APViewController viewDidLoad](self=0x07187e50, _cmd=0x005c5a77) + 122 at APViewController.m:16
frame #2: 0x000f41c7 UIKit`-[UIViewController loadViewIfRequired] + 536
frame #3: 0x000f4232 UIKit`-[UIViewController view] + 33
frame #4: 0x000433d5 UIKit`-[UIWindow addRootViewControllerViewIfPossible] + 66
frame #5: 0x0004376f UIKit`-[UIWindow _setHidden:forced:] + 368
frame #6: 0x00043905 UIKit`-[UIWindow _orderFrontWithoutMakingKey] + 49
frame #7: 0x0004c917 UIKit`-[UIWindow makeKeyAndVisible] + 65
frame #8: 0x00002e1b Debug`-[APAppDelegate application:didFinishLaunchingWithOptions:](self=0x07560750, _cmd=0x005a9c21, application=0x0716a640, launchOptions=0x00000000) + 571 at APAppDelegate.m:28
frame #9: 0x00010157 UIKit`-[UIApplication _handleDelegateCallbacksWithOptions:isSuspended:restoreState:] + 266
frame #10: 0x00010747 UIKit`-[UIApplication _callInitializationDelegatesForURL:payload:suspended:] + 1248
frame #11: 0x0001194b UIKit`-[UIApplication _runWithURL:payload:launchOrientation:statusBarStyle:statusBarHidden:] + 805
frame #12: 0x00022cb5 UIKit`-[UIApplication handleEvent:withNewEvent:] + 1022
frame #13: 0x00023beb UIKit`-[UIApplication sendEvent:] + 85
frame #14: 0x00015698 UIKit`_UIApplicationHandleEvent + 9874
frame #15: 0x01becdf9 GraphicsServices`_PurpleEventCallback + 339
frame #16: 0x01becad0 GraphicsServices`PurpleEventCallback + 46
frame #17: 0x01c06bf5 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + 53
frame #18: 0x01c06962 CoreFoundation`__CFRunLoopDoSource1 + 146
frame #19: 0x01c37bb6 CoreFoundation`__CFRunLoopRun + 2118
frame #20: 0x01c36f44 CoreFoundation`CFRunLoopRunSpecific + 276
frame #21: 0x01c36e1b CoreFoundation`CFRunLoopRunInMode + 123
frame #22: 0x0001117a UIKit`-[UIApplication _run] + 774
frame #23: 0x00012ffc UIKit`UIApplicationMain + 1211
frame #24: 0x00002b22 Debug`main(argc=1, argv=0xbffff3a4) + 130 at main.m:16
frame #25: 0x00002a55 Debug`start + 53
(lldb)</pre>


<ul>
<li>打印最基本的内容 (p)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) print anInt</pre>


<ul>
<li>打印对象(po)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) po anObj
(lldb) po 0x0715aa40</pre>


<ul>
<li>打印表达式(expr)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) expr 5+2
(lldb) expr aString = @"aNewValue"</pre>


<ul>
<li>打印线程中的一些东西</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) help frame</pre>




<div style="text-align: left;">
  <span style="color: #808080;">本文由<strong><span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></strong>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-01</time></span>
</div>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-06-21T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jun 21<span>st</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/qi-ta/'>其它</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/06/21/92/" itemprop="url">记我的第二个马拉松—昆明高原国际半程马拉松</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>对于IT行业的从业人员，由于工作的性质，很多人的身体都缺乏有效的锻炼。实际上这是一个非常危险的信号，现如今，随着社会的进步，大家的生活质量也不断提高，但是人们的身体状况总是令人担忧，几乎每年都能听说在IT行业里面有关猝死的新闻！在这里，希望大家能够在工作之余，善待自己的身体——毕竟前人已经说过，身体是革命的本钱！相信现在对身体多一份投资，将来会得到更多的回报。</p>

<p>关于技术的分享改日再谈，今日就来跟大家分享一下我的第二个马拉松。</p>

<h2><strong><span style="color: #339966;">正文</span></strong></h2>

<p>细算我跑步也有些年头了，不过要算马拉松比赛，至今才参加了2个，第一个是2012年11月25日的<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://beyondvincent.com/2013/05/11/%E7%A0%B4%E8%88%B9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%97%E4%BA%AC%E9%A9%AC%E6%8B%89%E6%9D%BE/" target="_blank"><span style="color: #339966; text-decoration: underline;">北京国际马拉松</span></a></span></strong></span>，现在还记得，本应该10月中旬就举办的了，但是由于要召开十八大，所以北京马拉松被迫让路，被推延到11月25日举行，在北京生活过的同学们应该清楚，这时候的天气已经冷了，这给我的初马带来了不小的挑战，结果虽然完成了比赛，但是跟预期的时间要多了1小时30分钟左右。</p>

<p>今年(2013)回到了云南，从云南跑吧群里得知在5月25日将举办昆明高原国际半程马拉松，大家也没有盼来期望的全程，可能组委会考虑到近一年来马拉松赛场上出的那些事，为谨慎起见吧。虽然是半程，不过这是在高原，平均海拔在1800米，对于外省人来说估计也会有一些难度。刚好，目前全程对于我来说可以跑下来，不过身体会受伤，半程是我的最佳选择。</p>

<p>为了参加昆明的这个马拉松，我前前后后约准备了半年时间，当然，由于是半程，难度不是太大，不出意外，都能够完赛，所以在备战计划中，对自己的身体要求不是太苛刻，力争达到跑完比赛之后，身体还是舒服就好。因而在平常的训练中，每周平均跑步3.5次，每次跑步的距离也是随性，可能是8km，10km，有时也会只计算时间，速度和距离没有考虑太多。毕竟跑步的最终目的是锻炼身体，让疾病晚一点光顾，参加马拉松比赛对我而言只当做锦上添花罢了，也算是给平时的跑步生活增添一点乐趣。</p>

<p>2013年5约25日，我早早的就起床，赶往马拉松出发地点——昆明-呈贡新区。到达出发点时，已经有好多人了，也看到了好多张熟悉的面孔。由于排队上厕所耗费了一些时间，没能赶上云南跑吧的赛前大合影（来自跑吧风11的摄影），有点点遗憾。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb.jpeg"><img class="alignnone size-full wp-image-1476" alt="psb" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb.jpeg" width="5428" height="1469" /></a></p>

<p>早上9点，马拉松准备开始，刚开始，当然也是中国式的马拉松开幕式——领导发言，10分钟后准时鸣枪起跑。大家像挣脱缰绳的野马一样，无论是男女老少，都一波流的往前冲，我在想，照着么快的速度下去，很多人会中途跑崩了的。也或许没有全程，大家顾虑也会少了许多吧。</p>

<p>本次马拉松的一大特点应该就是赛道起伏坡度又大又长，这跟北京马拉松的赛道有明显的区别。这对平时不怎么跑坡的同学，也会增加一点难度。</p>

<p>在跑步途中，我主要以匀速跟随跑为主，为了控制好自己的速度，时不时的会问问周围跑友目前的配速。由于本次赛道是折返跑，所以开跑后大约在8km的地方，我遇到了已经折返的<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://blog.sina.com.cn/mlwdxlbk42195" target="_blank"><span style="color: #339966; text-decoration: underline;">马哥-千里马</span></a></span></strong></span>——马拉松业余爱好者中的佼佼者，也为云南跑吧的成长付出了很多。</p>

<div id="attachment_1477" class="wp-caption alignnone" style="width: 272px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130621-1.png"><img class="size-full wp-image-1477" alt="马哥-千里马" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130621-1.png" width="262" height="316" /></a><p class="wp-caption-text">
    马哥-千里马
  </p>
</div>


<p>大约跑了50分钟的时候，我开始从折返点往回跑，一路上遇到好多熟悉的，不熟悉的人，大家相互加油，共同奔跑。</p>

<div id="attachment_1478" class="wp-caption alignnone" style="width: 1610px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb-1.jpeg"><img class="size-full wp-image-1478" alt="psb (1)" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb-1.jpeg" width="1600" height="1060" /></a><p class="wp-caption-text">
    破船在折返途中
  </p>
</div>


<p>折返途中，也是有几个不小的坡，前几个都轻松搞定，就是最后一个坡，这个坡度虽然不大，但是太长了，在距离终点还有2km的时候，心里做了数次挣扎——跑不动就走走吧，但是又在鼓励自己，坚持住，跑过地狱就是天堂。就这样，坚持着，很快，拐过几个弯，终点处的计时牌已经映入眼帘，看看时间，能够跑进2小时。最后时刻，在观众的加油声中，肾上腺激素被激发，加快了脚下的速度，顺利冲过终点，而此时时间定格在1小时56分42秒，排名141名。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb.png"><img class="alignnone size-full wp-image-1479" alt="psb" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb.png" width="533" height="575" /></a></p>

<p>冲过终点，领取纪念奖品，然后跟云南跑吧一起合影</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb1.jpeg"><img class="alignnone size-full wp-image-1480" alt="psb" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb1.jpeg" width="1114" height="539" /></a></p>

<p>&nbsp;</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb-11.jpeg"><img class="alignnone size-full wp-image-1481" alt="psb (1)" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb-11.jpeg" width="665" height="492" /></a></p>

<p>&nbsp;</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb-2.jpeg"><img class="alignnone size-full wp-image-1482" alt="psb (2)" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb-2.jpeg" width="800" height="535" /></a></p>

<p>下一站：云南大理马拉松</p>

<div style="text-align: left;">
  <span style="color: #808080;">本文由<span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-21</time></span>
</div>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-06-20T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jun 20<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/06/20/91/" itemprop="url">iOS汇编教程：ARM(2)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>注：本文由破船译自：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.raywenderlich.com/37181/ios-assembly-tutorial" target="_blank"><span style="color: #339966; text-decoration: underline;">raywenderlich</span></a></span></strong></span><br/>
感谢<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://blog.devtang.com/" target="_blank"><span style="color: #339966; text-decoration: underline;">唐巧</span></a></strong></span></span>抽出时间对本文进行double-check。</p>

<p>本文是iOS汇编教程：ARM第二篇。</p>

<p>iOS汇编教程：ARM目录如下[共分为两篇]：</p>

<h2><span style="text-decoration: underline;"><a href="http://beyondvincent.com/?p=1398" target="_blank"><strong><span style="color: #339966; text-decoration: underline;">iOS汇编教程：ARM(1)</span></strong></a></span></h2>

<ul>
<li><strong><span style="color: #339966;">开始：什么是汇编</span></strong></li>
<li><strong><span style="color: #339966;">函数调用约定</span></strong></li>
<li><strong><span style="color: #339966;">创建工程</span></strong></li>
<li><strong><span style="color: #339966;">加法(addFunction)</span></strong></li>
</ul>


<h2><strong><span style="color: #339966;">iOS汇编教程：ARM(2)</span></strong></h2>

<ul>
<li><strong><span style="color: #339966;">函数的调用</span></strong></li>
<li><strong><span style="color: #339966;">Objective -C 汇编</span></strong></li>
<li><strong><span style="color: #339966;">Obj-C 消息发给了谁</span></strong></li>
<li><strong><span style="color: #339966;">你现在可以进行逆向工程了</span></strong></li>
<li><strong><span style="color: #339966;">何去何从</span></strong></li>
</ul>


<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&ndash;</p>

<h1><span style="color: #339966;"><strong>iOS汇编教程：ARM(2)</strong></span></h1>

<h2><strong><span style="color: #339966;">函数的调用</span></strong></h2>

<p>首先，给函数addFunction函数添加一个属性(<strong><span style="color: #339966;"><strong>attribute</strong></span></strong>) ，告诉编译器不要进行特定的优化处理。通过上一篇文章，你已经看到编译器可以对代码进行优化，移除掉不需要的指令，另外，编译器甚至可以移除掉函数的调用，直接把被调用函数的相关代码进行内嵌到调用函数中。</p>

<p>例如，编译器可能会在调用函数中适当的添加add指令，而不是调用addFunction本身。实际上，现如今的编译器已经非常的智能了，针对类似addFunction这样的函数，编译器本身就可以进行加法操作，而不用在代码中添加一条add指令。</p>

<p>本文中，我们不希望编译器对代码进行优化——把代码进行内嵌处理。现在回到工程的main.m文件中，并按照如下方式修改addFunction：</p>

<pre class="wp-code-highlight prettyprint linenums:1">__attribute__((noinline))
int addFunction(int a, int b) {
    int c = a + b;
    return c;
}</pre>


<p>紧接着，在该函数下面添加另外一个函数：</p>

<pre class="wp-code-highlight prettyprint linenums:1">void fooFunction() {
    int add = addFunction(12, 44);
    printf("add = %i", add);
}</pre>


<p>&nbsp;</p>

<p>如上代码所示，fooFunction通过调用addFunction来计算12+44，然后将结果打印出来。这里使用C函数printf进行打印，而没有使用Objective-C的NSLog(NSLog要稍微复杂一点)。</p>

<p>接着再次选择Xcode中的Product\Generate Output\Assembly File，并确保输出设置为Archiving。然后搜索_fooFunction，会看到如下一些内容：</p>

<p><span style="color: #993366;">提醒：在Scheme中一定要选择iOS Device，不要选择模拟器。</span></p>

<pre class="wp-code-highlight prettyprint linenums:1">_fooFunction:
@ 1:
    push    {r7, lr}
@ 2:
    movs    r0, #12
    movs    r1, #34
@ 3:
    mov r7, sp
@ 4:
    bl  _addFunction
@ 5:
    mov r1, r0
@ 6:
    movw    r0, :lower16:(L_.str-(LPC1_0+4))
    movt    r0, :upper16:(L_.str-(LPC1_0+4))
LPC1_0:
    add r0, pc
@ 7:
    blx _printf
@ 8:
    pop {r7, pc}</pre>


<p>上面的代码中，涉及到了一些还没有介绍过的指令，不用担心，它们都不复杂。下面我们就分别来看看上面代码中的指令都做了什么操作：</p>

<p>1、这里的指令作用跟之前介绍的<strong><span style="color: #339966;">add sp, #12</span></strong>类似——r7和lr被“pushed”到栈中，也就是说栈指针(sp)被减去8(因为r7和lr都是4个字节)。需要注意，通过这条指令，栈指针被递减，两个值也被存储到栈中！需要存储r7是因为在这个函数中，该寄存器会被覆盖，而之后又需要还原最初的值；而存储lr寄存器中的值是因为在函数结束时，要使用。</p>

<p><span style="color: #993366;">注意：lr是寄存器(Link Register, LR——R14寄存器)。</span></p>

<p>2、这两个指令属于<strong><span style="color: #339966;">move</span></strong>(mov)指令集中的一个。有时候你会看到movs，而有时候则会看到mov，或者其它类似的名称。它们都是把一个值装载到寄存器中。你可以把数据从一个寄存器“mov”到另外一个寄存器，例如<strong><span style="color: #339966;">mov ro, r1</span></strong>指令，将把r1中的数据装载到r0中，而r1中的数据不会改变。</p>

<p>上面的两行汇编指令中，会将定义在函数中的两个常量装载到r0和r1中。注意，需要将这两个常量装载到r0和r1中，才能够被addFunction正确的使用。</p>

<p>3、 在调用函数的时候，应该将栈指针保存起来，而这里使用r7来保存栈指针(r7是可以用来存储局部变量存储器中的一个)。可能你已经注意到，在该函数中剩下的代码里面并没有再次使用到栈指针或者r7，所以这条指令在这里是多余的——<strong><span style="color: #339966;">有时候，即使开启了编译器的优化，但还是不能做到最佳优化</span></strong>。</p>

<p>4、这条指令(<strong><span style="color: #339966;">bl</span></strong>)对函数进行调用。请记住被调用函数需要的参数已经存储到相关的寄存器中了(r0和r1)。这条指令的执行一般被当做一个分支(branch)。可以理解为<strong><span style="color: #339966;">执行带链接的分支</span></strong>，也就是说，在跳转到分支之前，会将lr(link register)的值设置为当前函数中将要执行的下一条指令，当从分支(被调函数)中返回时，通过lr中的值可以知道当前函数执行到哪里了。</p>

<p>5、当addFunction函数执行完毕，返回后，执行的第一条指令——将addFunction的返回值(存储在r0中)保存起来，以供后续的printf使用。也就是利用<strong><span style="color: #339966;">mov</span></strong>将r0中的值存储到r1中。</p>

<p>6、printf的的第一个参数是一个字符串。这里使用了3条指令将指向字符串首地址的指针装载到r0寄存器中。这个字符串存储在二进制文件的<strong><span style="color: #339966;">数据段“data segment”</span></strong>中，不过该字符串的准确位置在二进制文件被链接之前是不知道的。</p>

<p>字符串其实是在由main.m文件生成的目标文件(object file)中的数据段里。如果你在汇编代码中搜索<strong><span style="color: #339966;">L_.str</span></strong>，就能找到这个字符串。这三个指令中的前两个作用是装载这个常量的地址（减去本地标签加4后的地址）。</p>

<p>第三条指令中将程序计数器(pc)的值加到r0中。因此，现在r0已保存着字符串的地址，也不用考虑L_.str在二进制文件中的确切位置。</p>

<p>下面的这个图演示了内存的布局。其中<strong><span style="color: #339966;">L_.str &#8211; (LPC1_0 + 4)</span></strong>的改变并不用对r0进行改动。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/04-PC-relative-string-480x264.png"><img class="alignnone size-full wp-image-1442" alt="04-PC-relative-string-480x264" src="http://beyondvincent.com/wp-content/uploads/2013/06/04-PC-relative-string-480x264.png" width="480" height="264" /></a></p>

<p>7、这条指令(<strong><span style="color: #339966;">blx</span></strong>)调用printf函数。这跟<span style="color: #339966;"><strong>bl</strong></span>指令有明显的区别。<strong><span style="color: #339966;">blx</span></strong>中的<span style="color: #339966;"><strong>x</strong></span>标示交换“exchange”，意思是如果有必要，处理器将对指令集模式进行切换。</p>

<p>现在的ARM处理器有两种模式：<strong><span style="color: #339966;">ARM</span></strong>和<span style="color: #339966;"><strong>Thumb</strong></span>。Thumb指令是16位的宽度，而ARM指令是32位的宽度。Thumb指令比较少，不过使用Thumb指令意味着代码容量更小，以及更利于CPU缓存。</p>

<p>因此，使用Thumb尺寸得到的好处就是让你的代码更少。这里可以看到更多的Thumb信息：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="https://en.wikipedia.org/wiki/ARM_architecture#Thumb" target="_blank"><span style="color: #339966; text-decoration: underline;">Wikipedia</span></a></span></strong></span>。</p>

<p>8、最后一条指令是将在第一条指令中push到栈里面的值pop出来。这里列出来的寄存器将被从栈中pop出来的值填充，然后栈指针递增。回想一下第一条指令是这样的：r7和lr寄存器中的值被push到栈中，但是为什么这里的指令是将栈中的值pop到r7和pc寄存器中，而不是r7和lr寄存器中呢？</p>

<p>相信你还记得之前说过的：lr寄存器保存的是从一个函数返回时，下一条将被执行指令的地址。所以，如果将push到栈中的这个地址pop给pc(program counter)，那么将继续从函数被调用的地方执行——这也是从一个被调用函数返回调用函数的常规做法，而不是像调用addFunction一样返回到调用函数fooFunction中。</p>

<p>现在我们来看看ARM中的一些指令的简短总结。ARM中又许多指令，不过下面列出来的指令对于初步了解ARM指令非常重要。现在就通过伪代码(pseudo-code)和相关描述来快速的回顾一下这些指令都做有什么作用：</p>

<ul>
<li>mov r0, r1 => r0 = r1</li>
<li>mov r0, #10 => r0 = 10</li>
<li>ldr r0, [sp] => r0 = *sp</li>
<li>str r0, [sp] => *sp = r0</li>
<li>add r0, r1, r2 => r0 = r1 + r2</li>
<li>add r0, r1 => r0 = r0 + r1</li>
<li>push {r0, r1, r2} => 将 r0, r1 和 r2push到栈中.</li>
<li>pop {r0, r1, r2} => 将3个值从栈中pop出来，并存放到r0, r1 和 r2中.</li>
<li>b _label => pc = _label</li>
<li>bl _label => lr = pc + 4; pc = _label</li>
</ul>


<p><strong><span style="color: #ff0000;"> 现在是时候恭喜你了：你能够阅读一些ARM汇编代码了！</span></strong></p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/06-Read-ARM-meme.png"><img class="alignnone size-full wp-image-1446" alt="06-Read-ARM-meme" src="http://beyondvincent.com/wp-content/uploads/2013/06/06-Read-ARM-meme.png" width="552" height="414" /></a></p>

<p><strong style="font-size: 1.5em;"><span style="color: #339966;">Objective -C 汇编</span></strong></p>

<p>到现在为止，我们涉及到的函数都是用C语言来写的。Objective-C在C语言的基础上稍微增加了一点复杂度。下面我们就来看看用Objective-C代码编译出来的汇编指令。打开<strong><span style="color: #339966;">ViewController.m</span></strong>文件，然后将下面的方法添加到类的实现中：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (int)addValue:(int)a toValue:(int)b {
    int c = a + b;
    return c;
}</pre>


<p>同样，通过这样的步骤来查看汇编代码：<strong><span style="color: #339966;">Product\Generate Output\Assembly File</span></strong>。记得将output类型设置为Archiving，然后搜索<strong><span style="color: #339966;">addValue:toValue: </span></strong>，你会发现类似如下的汇编代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">"-[ViewController addValue:toValue:]":
    adds    r0, r3, r2
    bx  lr</pre>


<p>首先看到的是一个<strong><span style="color: #339966;">标签</span></strong>(label)名称——&#8221;&ndash;[ViewController addValue:toValue:]&#8220;，这个名称包含类名和完整的Objective-C方法名称。</p>

<p>把上面的汇编代码与之前的addFunction相关汇编代码进行比较，你会发现这里是将r2和r3进行加法运算，而不是r0与r1相加——这意味着传递给addValue:toValue:方法的参数使用了r2和r3寄存器(没有使用r0和r1)，这是为什么呢？</p>

<p>这是因为：在调用Objective-C方法时，除了传递明确指定的参数外，还会在明确参数之前传递两个隐含的参数(implicit parameter)。addValue:toValue:方法跟下面的C函数是等价的：</p>

<pre class="wp-code-highlight prettyprint linenums:1">int ViewController_addValue_toValue(id self, SEL _cmd, int a, int b) {
    int c = a + b;
    return c;
}</pre>


<p>这就是为什么a和b两个参数分别存储到r2和r3的原因。可能你之前已经听说过前两个参数了(经常使用self吧)。</p>

<p><strong><span style="color: #ff0000;">提醒：self和_cmd占用了r0和r1寄存器。</span></strong></p>

<p>可能之前你还没有见过<strong><span style="color: #339966;">_cmd</span></strong>。其实跟<strong><span style="color: #339966;">self</span></strong>一样，在Objective-C函数中，_cmd是可以直接使用的，它存储着当前执行方法的<strong><span style="color: #339966;">selector</span></strong>。一般来说，你并不需要使用_cmd(这也可能是为什么你从来没有听说过_cmd的原因)。</p>

<p>为了观察Objective-C方法是如何被调用的，现在将如下方法添加到ViewController中：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)foo {
    int add = [self addValue:12 toValue:34];
    NSLog(@"add = %i", add);
}</pre>


<p>重新生成汇编文件，然后寻找<strong><span style="color: #339966;">&#8220;&ndash;[ViewController foo]&#8220;:</span></strong>，应该能看到类似如下的代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">"-[ViewController foo]":
@ 1:
    push    {r7, lr}
@ 2:
    movw    r1, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))
    movt    r1, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))
LPC1_0:
    add r1, pc
@ 3:
    ldr r1, [r1]
@ 4:
    movs    r2, #12
    movs    r3, #34
@ 5:
    mov r7, sp
@ 6:
    blx _objc_msgSend
@ 7:
    mov r1, r0
@ 8:
    movw    r0, :lower16:(L__unnamed_cfstring_-(LPC1_1+4))
    movt    r0, :upper16:(L__unnamed_cfstring_-(LPC1_1+4))
LPC1_1:
    add r0, pc
@ 9:
    blx _NSLog
@ 10:
    pop {r7, pc}</pre>


<p>同样，这与之前C语言产生的汇编代码非常相似，我们也来看看具体都做了些什么：</p>

<p>1、将r7和lr push到栈中。</p>

<p>2、利用pc(program counter)将标签<strong><span style="color: #339966;">L_OBJC_SELECTOR_REFERENCES_</span></strong>对应的值装载到r1寄存器中。这个标签引用到一个selector。实际上selector就是一个字符串，并且存储在数据段中(data segment)。</p>

<p>3、如果在汇编文件中搜索L_OBJC_SELECTOR_REFERENCES_，会看到如下内容：</p>

<pre class="wp-code-highlight prettyprint linenums:1"> L_OBJC_SELECTOR_REFERENCES_:     .long   L_OBJC_METH_VAR_NAME_</pre>


<p>r1会指向这里(<strong><span style="color: #339966;">L_OBJC_SELECTOR_REFERENCES_</span></strong>)，这个标签包含了另外一个标签：<strong><span style="color: #339966;">L_OBJC_METH_VAR_NAME_</span></strong>。在文件中查找这个标签(<strong><span style="color: #339966;">L_OBJC_METH_VAR_NAME_</span></strong>)，会找到这样的字符串：addValue:toValue:。</p>

<p>而指令<strong><span style="color: #339966;">ldr r1, [r1]</span></strong>的作用：对r1中存储的地址进行解引用(dereferencing)，然后将得到的值放到r1中。如果用C伪代码看起来应该是这样的：r1 = *r1。仔细想想的话，可能你应该知道r1将会存储着指向字符串addValue:toValue: 的指针。</p>

<p>4、将常量装载到r2和r3中。</p>

<p>5、 将sp保持到r7寄存器中。</p>

<p>6、这是一个分支(branch)，<strong><span style="color: #339966;">以带链接跳转和根据情况切换指令集的模式</span></strong>来调用objc_msgSend方法。这是Objective-C runtime中非常重要的一个方法——它根据传递的参数找到并调用相关的函数。</p>

<p>该方法使用到了4个参数(r0-r3)。因此，在上面的代码中，将selector装载到r1中，另外两个参数(12和34)装载到r2和r3中。<strong><span style="color: #339966;">注意：在此并没有明确的装载r0，因为r0已经存储着self变量了。</span></strong></p>

<p>7、调用addValue:toValue:的返回值被存放在r0中。这里的指令将这个结果值保持到r1中。在接下来调用NSLog函数时会用到这个值。</p>

<p>8、将NSLog用到的第一个字符串参数装载到r0中。这跟之前介绍的用C函数里面调用printf一样。</p>

<p>9、这是一个分支(branch)，<strong>以<span style="color: #339966;">带链接跳转和根据情况切换指令集的模式</span></strong>来调用NSLog方法。</p>

<p>10、从栈中pop出两个值，并放入r7和pc寄存器中。这跟之前一样，从foo方法中返回。</p>

<p>如上所见，由C和Objective-C代码生成汇编指令，区别不是太大。只不过在Objective-C生成的汇编指令中，会隐示的给方法传递两个参数，以及使用到的selector以字符串的形式存放在数据段中(data segment)。</p>

<h2><strong><span style="color: #339966;">Obj-C 消息发给了谁</span></strong></h2>

<p>上面我们看到了<strong><span style="color: #339966;">objc_msgSend</span></strong>方法。可能你在crash log中已经看到过这个方法。该方法是Objective-C runtime中的一个核心方法。runtime包含了内存管理以及类的相关处理。</p>

<p>每次调用Objective-C方法时，都由objc_msgSend方法(这是一个C方法)处理消息的派送(dispatching)。该方法根据传递的消息类型在类的方法列表中查找被调用方法的实现。objc_msgSend方法的签名(signature)看起来是这样的：</p>

<pre class="wp-code-highlight prettyprint linenums:1">id objc_msgSend(id self, SEL _cmd, ...)</pre>


<p>在方法执行期间，第一个参数是self。在方法中写的一些代码，例如self.someProperty，其中self就是来自自objc_msgSend方法中的self参数。</p>

<p>第二个参数很少人会知道，这也是一个被隐藏的参数(hidden parameter)。如果在Objective-C方法中，写这类似这样的代码：<strong><span style="color: #339966;">NSLog(@&#8221;%@&#8221;, NSStringFromSelector(_cmd));</span></strong> ，会看到控制台输出了当前的selector。</p>

<p>剩下的参数一般就是开发者传递给该方法的参数了。所以如果一个方法携带两个参数，例如上面的<strong><span style="color: #339966;">addValue:toValue:</span></strong>，那么还会携带额外的两个参数。因此，我们也可以用下面的代码来代替通过Objective-C方式的调用：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)foo {
    int add = (int)objc_msgSend(self, NSSelectorFromString(@"addValue:toValue:", 12, 34);
    NSLog(@"add = %i", add);
}</pre>


<p><span style="color: #993366;">注意：虽然objc_msgSend的返回值类型是id，不过在上面的代码中将其转换为int类型了。因为它们 的size是相同的，所以转换为int不会有问题。如果该方法返回的是不同的size，那么实际上是别的函数被调用了，更多内容请看这里：<span style="text-decoration: underline; color: #339966;"><strong><a href="http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html"><span style="color: #339966; text-decoration: underline;">here</span></a></strong></span>。同样，如果返回的是一个floating指针，那么则是objc_msgSend的另一个变种被调用了，更多内容请看这里：<span style="text-decoration: underline; color: #339966;"><strong><a href="http://sealiesoftware.com/blog/archive/2008/11/16/objc_explain_objc_msgSend_fpret.html" target="_blank"><span style="color: #339966; text-decoration: underline;">here</span></a></strong></span>。</span></p>

<p>当一个Objective-C方法被编译的时候，上面用C写的等效方法签名应该是这样的：</p>

<pre class="wp-code-highlight prettyprint linenums:1">int ViewController_addValue_toValue(id self, SEL _cmd, int a, int b)</pre>


<p>对此为什么会这样，现在应该不会感觉到奇怪——这样的签名是为了与objc_msgSend相匹配！也就是说当objc_msgSend在查找并跳转到对应方法时，所有的这些参数都应该在正确的地方。</p>

<p>这里可以看到更多关于objc_msgSend相关内容：<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html" target="_blank"><span style="color: #339966; text-decoration: underline;">文章1</span></a></span></strong></span>，<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://sealiesoftware.com/blog/archive/2008/09/22/objc_explain_So_you_crashed_in_objc_msgSend.html" target="_blank"><span style="color: #339966; text-decoration: underline;">文章2</span></a></span></span></strong>。</p>

<h2><strong><span style="color: #339966;">你现在可以进行逆向工程了</span></strong></h2>

<p>根据上面对ARM汇编的介绍，你应该可以能够知道为什么有些代码被breaking、crashing或者没有正确的执行。</p>

<p>通过观察相关的汇编代码，可以更加清楚的获知到引起bug的详细步骤。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/interrogation.png"><img class="alignnone size-full wp-image-1465" alt="interrogation" src="http://beyondvincent.com/wp-content/uploads/2013/06/interrogation.png" width="651" height="241" /></a></p>

<p>有时候，你可能无法查看源代码——例如，你遇到的bug是发生在第三方库或者系统的framework中。此时，通过汇编指令进行分析可以帮助你迅速的找到问题。下面的目录存放着iOS SDK中所有的framework：</p>

<p>&lt;Path_to_Xcode>/Contents/Developer/Platforms/iPhoneOS.platform/Developer/ SDKs/iPhoneOS6.1.sdk/System/Library/Frameworks</p>

<p>我建议使用<strong><span style="color: #339966;"><a href="http://www.hopperapp.com/" target="_blank"><span style="color: #339966;">HopperApp</span></a></span></strong>对这些库进行分析。该软件能够对二进制文件进行反汇编——这样你就可以看库中的内容了——这样做是没有问题的！！！例如，打开UIKit，就可以看到每个方法都做了什么。如下图所示：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/05-HopperApp-1.png"><img class="alignnone size-full wp-image-1466" alt="05-HopperApp-1" src="http://beyondvincent.com/wp-content/uploads/2013/06/05-HopperApp-1.png" width="1015" height="231" /></a></p>

<p>上图中的汇编代码是<strong><span style="color: #339966;">[UINavigationController shouldAutorotateToInterfaceOrientation] </span></strong>方法相关的。结合之前介绍的ARM汇编知识，相信上面的汇编代码具体做了些什么你应该能看出来。</p>

<p>首先是将一个selector引用装载到ri寄存器中，以供后续调用objc_msgSend使用。然后可以看到，别的寄存器并没有做任何改动，所以我们可以知道传递给objc_msgSend方法的self指针(存储在r0中)，跟传递给<strong><span style="color: #339966;">shouldAutorotateToInterfaceOrientation</span></strong>方法的self是同一个。</p>

<p>同理，我们可以知道被调用方法携带一个参数(代码中有一列是用来显示相关名称的)。由于r2寄存器没有改动过，所以这个参数就是从shouldAutorotateToInterfaceOrientation方法传入的。</p>

<p>最后，函数调用之后，r0没有改动过，所以被调用函数的返回值就是调用函数的返回值。</p>

<p>这样一来，就可以推断出这个方法的实现应该是这样的了：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (BOOL)shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation)interfaceOrientation {
    return [self _doesTopViewControllerSupportInterfaceOrientation:interfaceOrientation];
}</pre>


<p>cool！很容易吧！虽然大多数方法都比上面的这个要复杂，不过你可以根据汇编指令拼凑出一些代码，进而快速的确定这些代码做了些什么。</p>

<p><strong style="font-size: 1.5em;"><span style="color: #339966;">何去何从</span></strong></p>

<p>这篇关于iOS汇编的教程向你介绍了一些运行在iOS设备中的ARM汇编指令核心概念。你应该学习到了C和Objective-C相关的一些调用约定。</p>

<p>通过本文介绍的知识，当你的程序在使用系统库crash时，你可以对所有能看到的随机代码进行分析。当然，你也可以通过汇编指令来准确的分析你自己写的方法。</p>

<p>如果你希望更加深入的了解ARM，请看这里：<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.raspberrypi.org/"><span style="color: #339966; text-decoration: underline;">Raspberry Pi</span></a></span></span></strong>。这里的涉及到的小型设备都拥有ARM处理器，跟iOS设备非常相似，同时也有许多教程可以教你如何对这些设备进行编程。</p>

<p>另外，NEON也值得去学习了解。这是另外扩展的一套指令集，自iPhone 3GS以来设备中的所有处理器，都支持NEON指令集。该指令集提供了SIMD(单指令，多数据——Single Instruction Multiple Data)指令，对数据的处理非常高效，例如，图片的处理。如果你需要对数据进行高效的处理，那么最好学习一下如何直接写NEON指令，并结合使用内联汇编(inline assembly)。这个指令集非常的先进！</p>

<p>这应该够你忙乎一阵了:]。</p>

<div style="text-align: left;">
  <span style="color: #808080;">本文由<span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-20</time></span>
</div>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-06-19T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jun 19<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/06/19/90/" itemprop="url">iOS汇编教程：ARM(1)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>注：本文由破船译自：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.raywenderlich.com/37181/ios-assembly-tutorial" target="_blank"><span style="color: #339966; text-decoration: underline;">raywenderlich</span></a></span></strong></span><br/>
感谢<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://blog.devtang.com/" target="_blank"><span style="color: #339966; text-decoration: underline;">唐巧</span></a></span></strong></span>抽出时间对本文进行double-check。</p>

<div id="attachment_1399" class="wp-caption alignright" style="width: 264px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/06/SpeakAssemblySmall.png"><img class="wp-image-1399 " alt="SpeakAssemblySmall" src="http://beyondvincent.com/wp-content/uploads/2013/06/SpeakAssemblySmall.png" width="254" height="254" /></a><p class="wp-caption-text">
    你说的是汇编吗？
  </p>
</div>


<p>我们写的Objective-C代码，最终会被转换为机器代码 —— 由ARM处理器能识别的1和0组成。实际上，在机器代码之间，还有一门人类可以阅读的语言 —— 汇编语言。</p>

<p>了解汇编，可以深入到你的代码里面进行调试和优化的探索，并有助于你对Objective-C运行时(runtime)的理解，同时也能满足你内心的好奇！</p>

<p>在这篇iOS汇编教程中，你能学到：</p>

<ul>
<li><strong><span style="color: #339966;">什么是汇编</span></strong> —— 以及为什么需要关注它。</li>
<li><strong><span style="color: #339966;">如何阅读汇编</span></strong> —— 特别是由Objective -C生成的汇编。</li>
<li><strong><span style="color: #339966;">在调试的时候如何使用assembly view</span></strong> —— 遇到一个bug或者crash，看看到底是怎么回事，这非常有用。</li>
</ul>


<p>为了有效吸收本文内容，建议本文的读者对象为已经熟悉Objective-C编程了。当然，你也应该要知道一些简单的计算机科学相关概念，例如栈、CPU以及它们是如何运行的。如果你对CPU不太熟悉，建议在阅读本文之前，先看看这里的内容：<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://www.howstuffworks.com/microprocessor.htm" target="_blank"><span style="color: #339966; text-decoration: underline;">微处理器的工作原理</span></a></span></span></strong>。</p>

<p>目录[分两篇文章翻译]：</p>

<h2><strong><span style="color: #339966;">iOS汇编教程：ARM(1)</span></strong></h2>

<ul>
<li><strong><span style="color: #339966;">开始：什么是汇编</span></strong></li>
<li><strong><span style="color: #339966;">函数调用约定</span></strong></li>
<li><strong><span style="color: #339966;">创建工程</span></strong></li>
<li><strong><span style="color: #339966;">加法(addFunction)</span></strong></li>
</ul>


<h2><span style="text-decoration: underline;"><a href="http://beyondvincent.com/?p=1434" target="_blank"><strong><span style="color: #339966; text-decoration: underline;">iOS汇编教程：ARM(2)</span></strong></a></span></h2>

<ul>
<li><strong><span style="color: #339966;">函数的调用</span></strong></li>
<li><strong><span style="color: #339966;">Objective -C 汇编</span></strong></li>
<li><strong><span style="color: #339966;">Obj-C 消息发给了谁</span></strong></li>
<li><strong><span style="color: #339966;">你现在可以进行逆向工程了</span></strong></li>
<li><strong><span style="color: #339966;">何去何从</span></strong></li>
</ul>


<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&ndash;</p>

<h1><span style="color: #339966;"><strong>iOS汇编教程：ARM(1)</strong></span></h1>

<h2><strong><span style="color: #339966;">开始：什么是汇编</span></strong></h2>

<p>Objective-C是一门高级语言。编译器会将你的Objective-C代码编译为汇编语言代码：一门低级语言，不过还不是最低级的语言。</p>

<p>这些汇编会被汇编器(assembler)组装为机器代码——CPU可以识别的0和1。好在一般开发者并没有必要考虑机器代码，不过有时候详细的了解汇编，会非常有用。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/SpeakAssembly.png"><img class="alignnone size-full wp-image-1403" alt="SpeakAssembly" src="http://beyondvincent.com/wp-content/uploads/2013/06/SpeakAssembly.png" width="651" height="241" /></a></p>

<p>每一个汇编指令都会告诉CPU执行一个相关任务，例如“对两个数字执行加(add)操作”，或“从某个内存地址加载数据”。</p>

<p>除了主存外 ——如 iPhone 5有1GB的主存、Mac电脑可能会有8GB —— CPU还有少许的存储部件，称之为<strong><span style="color: #339966;">寄存器</span></strong>，寄存器的访问速度非常快，一个寄存器就像一个变量一样，可以存储单个值。</p>

<p>所有的iOS设备(实际上，现如今，几乎所有的移动设备)使用的CPU都是基于<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/ARM_architecture" target="_blank"><span style="color: #339966; text-decoration: underline;">ARM架构</span></a></span></strong></span>。 ARM芯片使用的指令集是<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computing" target="_blank"><span style="color: #339966; text-decoration: underline;">RISC</span></a></span></span></strong>(精简指令集)，该指令集非常的精简，并且易读（比<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/X86" target="_blank"><span style="color: #339966; text-decoration: underline;">x86</span></a></span></span></strong>的指令集精简多了）。</p>

<p>一个汇编指令(或者语句)看起来如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">mov r0, #42</pre>


<p>上面的这行汇编指令，涉及到好多命令(或操作)。mov的作用是对数据进行移动。在ARM汇编指令中，目标是第一个，所以，上面的指令是将值42移动到寄存器r0中。再来看看下面的代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">ldr   r2, [r0]
ldr r3, [r1]
add r4, r2, r3</pre>


<p>上面汇编指令的作用是首先将寄存器r0和r1中的值装载到寄存器r2和r3中，然后对寄存器r2和r3中的值进行加(add)操作，加的结果存放到r4中。</p>

<p>很容易看懂吧！</p>

<h2><strong><span style="color: #339966;">函数调用约定</span></strong></h2>

<p>要想理解汇编代码，首先重要的事情就是理解代码之间的交互——意思是一个函数调用另一个函数的方式。这包括了参数如何传递以及如何从函数返回结果——称之为调用的约定。编译器必须严格的遵守相关标准进行代码编译，这样生成的代码，才能够相互兼容。</p>

<p>上面讨论过，寄存器是的存储空间非常少，并且靠近CPU——用来存储当前使用的一些值。ARM CPU有16个寄存器：r0到r15。每个寄存器为32bit。调用约定规定了这些寄存器的特定用途。如下：</p>

<ul>
<li> r0 &#8211; r3：存储传递给函数的参数值。</li>
<li> r4 &#8211; r11：存储函数的局部变量。</li>
<li>r12：是内部过程调用暂时寄存器（intra-procedure-call scratch register）。</li>
<li>r13：存储栈指针(sp)。在计算机中，栈非常重要。这个寄存器保存着栈顶的指针。这里可以看到更多关于栈的信息：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/Call_stack"><span style="color: #339966; text-decoration: underline;">Wikipedia</span></a></span></strong></span>。</li>
<li>r14：链接寄存器(link register)。存储着当被调用函数返回时，将要执行的下一条指令的地址。</li>
<li>r15：用作程序计数器(program counter)。存储着当前执行指令的地址。每条执行被执行后，该计数器会进行自增(+1)。</li>
</ul>


<p>这里可以看到更多相关ARM 调用约定的内容：<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf"><span style="color: #339966; text-decoration: underline;">this document from ARM</span></a></span></span></strong>。苹果公司也给出了一份文档详细介绍了在iOS开发中的调用约定： <span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/iPhoneOSABIReference.pdf"><span style="color: #339966; text-decoration: underline;">calling convention used for iOS development</span></a></span></span>。</p>

<p>下面我们就从代码上开始真正的认识汇编。</p>

<h2><strong><span style="color: #339966;">创建工程</span></strong></h2>

<p>打开Xcode，<strong><span style="color: #339966;">File\New\New Project</span></strong>，选择<strong><span style="color: #339966;">iOS\Application\Single View Application</span></strong>，然后点击<strong><span style="color: #339966;">Next</span></strong>，工程的配置如下：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/01-Create-the-project.png"><img class="alignnone size-full wp-image-1416" alt="01-Create-the-project" src="http://beyondvincent.com/wp-content/uploads/2013/06/01-Create-the-project.png" width="1394" height="841" /></a></p>

<ul>
<li><strong><span style="color: #339966;">Product name</span></strong>: ARMAssembly</li>
<li><strong><span style="color: #339966;">Company Identifier</span></strong>: 一般为反向的DNS标示</li>
<li><strong><span style="color: #339966;">Class Prefix</span></strong>: 空白</li>
<li><strong><span style="color: #339966;">Devices</span></strong>: iPhone</li>
<li><strong><span style="color: #339966;">Use Storyboards</span></strong>: No</li>
<li><strong><span style="color: #339966;">Use Automatic Reference Counting</span></strong>: Yes</li>
<li><strong><span style="color: #339966;">Include Unit Tests</span></strong>: No</li>
</ul>


<p>点击 Next 选择工程存储的位置——完成工程的创建。</p>

<h2><span style="color: #339966;">加法(addFunction)</span></h2>

<p>下面我们写一个加法函数：对两个数进行相加，然后返回结果。这里我们先用C语法写，后面再介绍用OC来写（OC稍微复杂一点）。在工程的Supporting Files目录中打开<strong><span style="color: #339966;">main.m</span></strong>文件，然后将下面的函数拷贝并粘贴到文件的顶部。</p>

<pre class="wp-code-highlight prettyprint linenums:1">int addFunction(int a, int b) {
    int c = a + b;
    return c;
}</pre>


<p>现在将Xcode中的scheme设置为为设备构建:选中iOS Device作为scheme target(如果你将设备连接到电脑中，会现实&lt;你的设备名称>，如“Matt Galloway的iPhone 5”)——这样选择之后，生成的汇编就是针对ARM的，而不是针对x86(模拟器使用)。Xcode的选择效果如下图所示：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/02-Select-iOS-Device-scheme.png"><img class="alignnone size-full wp-image-1420" alt="02-Select-iOS-Device-scheme" src="http://beyondvincent.com/wp-content/uploads/2013/06/02-Select-iOS-Device-scheme.png" width="291" height="49" /></a></p>

<p>&nbsp;</p>

<p>然后选择:<strong><span style="color: #339966;">Product\Generate Output\Assembly File</span></strong>。过一会之后，Xcode会生成一个文件，这个文件里面有很多行都有下划线__。在文件的顶部,好多行都是以<strong><span style="color: #339966;">.section</span></strong>开头。接着选中<strong><span style="color: #339966;">Show Assembly Output For</span></strong>中的<strong><span style="color: #339966;">Running</span></strong>。</p>

<p><span style="color: #993300;">  注意:默认情况下,使用的是debug scheme中的设置信息,所以默认选中的就是Running。在debug模式下，编译器对代码没有做优化处理——首先观察没有进过优化处理的汇编，更利于理解代码具体都发生了什么。</span></p>

<p>在生成的文件中搜索_addFunction,会看到类似如下的代码:</p>

<pre class="wp-code-highlight prettyprint linenums:1">.globl    _addFunction
    .align  2
    .code   16                      @ @addFunction
    .thumb_func _addFunction
_addFunction:
    .cfi_startproc
Lfunc_begin0:
    .loc    1 13 0                  @ main.m:13:0
@ BB#0:
    sub sp, #12
    str r0, [sp, #8]
    str r1, [sp, #4]
    .loc    1 14 18 prologue_end    @ main.m:14:18
Ltmp0:
    ldr r0, [sp, #8]
    ldr r1, [sp, #4]
    add r0, r1
    str r0, [sp]
    .loc    1 15 5                  @ main.m:15:5
    ldr r0, [sp]
    add sp, #12
    bx  lr
Ltmp1:
Lfunc_end0:
    .cfi_endproc</pre>


<p>上面的代码看起来有点凌乱,实际上也不难以读懂。我们来看看，首先，所有以&#8221;.&#8221;开头的代码行都不是汇编指令,我们可以忽略所有这些以&#8221;.&#8221;开头的代码行。</p>

<p>代码中以冒号结尾的的代码行(例如<strong><span style="color: #339966;">_addFunction</span></strong>:和<strong><span style="color: #339966;">Ltim0</span></strong>: )，我们称之为标签（<strong><span style="color: #339966;">label</span></strong>）。这些标签的作用是给汇编代码片段指定相关的名字.名为<strong><span style="color: #339966;">_addFunction</span></strong>:的标签,实际上是一个函数的入口点.</p>

<p>这个标签(<span style="color: #339966;"><strong>_addFunction</strong></span>: )是必须有的:别的代码调用addFunction函数时,并不需要知道该函数具体在什么地方,通过简单的一个符号或标签就可以进行调用.在最终生成程序二进制文件时,链接器会把这个标签转换到实际的地址.</p>

<p>我们需要注意的时,编译器总是会在函数名前面添加一个下划线——这仅仅是一个约定。另外，其他所有的标签都是以<strong><span style="color: #339966;">L</span></strong>开头——这些通常称为局部标签(local label)，只会在函数内部使用。在上面的代码中，虽然没有实际用到局部标签，不过编译器还是为我们生成了一些——之所以会生成这些没有被使用到的局部标签，是由于代码还没有做任何的优化处理。</p>

<p>注释是以<strong><span style="color: #339966;">@</span></strong>字符开头。通过上面的分析,这样一来，忽略掉注释和标签，代码看起来如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">_addFunction:
@ 1:
    sub sp, #12
@ 2:
    str r0, [sp, #8]
    str r1, [sp, #4]
@ 3:
    ldr r0, [sp, #8]
    ldr r1, [sp, #4]
@ 4:
    add r0, r1
@ 5:
    str r0, [sp]
    ldr r0, [sp]
@ 6:
    add sp, #12
@ 7:
    bx  lr</pre>


<p>下面我们来看看代码中每部分汇编都做了什么:</p>

<p>1、首先，在栈(stack)创建临时存储所需要的空间。栈提供了许多内存供函数使用。ARM中的栈是向下延伸的,也就是说,在栈上创建一些空间,需要从栈指针开始减去(subtract)一些空间。在这里，预留了12个字节。</p>

<p>2、r0和r1用来存储传递给调用函数的参数值。如果函数有4个参数，那么会把r2和r3当做第三个和第四个参数。如果函数的参数超过了4个，或者携带的参数不适合使用32位的寄存器（例如很大的数据结构），那么可以通过栈来传递这些参数。</p>

<p>在这里,两个参数被保存到栈中。这是由存储寄存器(str)指令完成的。</p>

<p>上面的指令可以指定一个偏移量,用来应用在某个值上面。所以[sp, #8]的意思是存储至“栈指针寄存器+8的地方”,因此,str r0, [sp, #8]的作用是：将寄存器r0中的内容存储到栈指针(加8)指向的内存地址.</p>

<p>3、将刚刚保存到栈中的值读取至相同的寄存器中(r0和r1)。这里，的ldr指令与str指令刚好相反，ldr(load register)会把指定内存位置中的的内容加载到寄存器中。ldr和str的语法非常相似：ldr r0, [sp, #8]的作用是“将栈指针加8后指向的地址内容加载到r0寄存器中”。</p>

<p>这里你可能会感觉到奇怪,为什么ro和r1寄存器中的值刚刚保存,马上又将其加载回来,答案是:这两行代码是冗余的,可以去掉!如果编译器做了优化处理,那么这些冗余的代码会被忽略掉.</p>

<p>4、这是该函数中最终的要一个指令:执行加操作。该执行的意思是：将r0和r1中的内容进行相加，然后把结果放到r0中。</p>

<p>add指令可以是两个参数,也可以是三个参数.如果指定三个参数,那么第一个参数就被当做目标寄存器,剩下的两个则为源寄存器.因此,这里的指令可以写成这样:add r0, r0, r1。</p>

<p>5、同样，编译器生成了一些冗余代码：将加的结果存储到栈中，接着立即从栈中读取回来。</p>

<p>6、终止函数的地方：将栈指针指向调用addFunction函数时的最初地方。addFunction开始于：sp减去12的地方：预留了12个字节。现在将12加回去即可。这里必须确保栈指针的正确操作，否则栈指针会指向错误的地方。</p>

<p>最后,执行bx指令会回到调用函数的地方.这里的寄存器lr是链接寄存器(link register)，该存储器存储着将要执行的下一条指令。注意,addFunction返回之后,r0寄存器会存储着该函数相加的结果值——这也是调用约定中的一部分：函数的返回值永远都被存储在r0寄存器中。除非一个寄存器不够存储，这是可以使用r1-r3。</p>

<p>上面就是所有相关addFunction的介绍,并不复杂吧?预知关于这些指令的更多内容,请看这里: <span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf"><span style="color: #339966; text-decoration: underline;">ARM website</span></a></span></strong></span>.</p>

<p>重申一下,上面的方法有好多冗余的地方:这是由于编译器处于debug模式,不会对代码做优化处理.如果对代码进行了优化处理,会看到生成的汇编代码非常的少。</p>

<p>选中<strong><span style="color: #339966;">Show Assembly Output For</span></strong>中的<strong><span style="color: #339966;">Archiving</span></strong>。然后搜索_addFunction:，会看到如下指令（只有这些）：</p>

<pre class="wp-code-highlight prettyprint linenums:1">_addFunction:
    add r0, r1
    bx  lr</pre>


<p>这看起来非常简洁:只需要两条指令就完成了addFunction函数的功能。当然，在实际开发中，一个函数一般都会有好多指令。</p>

<p>现在,这个addFunction已经返回到调用的函数那里了.下面我们就来看看关于调用的函数的相关信息.</p>

<p>下面的内容会在第二篇文章中翻译：</p>

<h1><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/?p=1434" target="_blank"><span style="color: #339966; text-decoration: underline;"><strong>iOS汇编教程：ARM(2)</strong></span></a></span></span></h1>

<ul>
<li><span style="color: #339966;"><strong>函数的调用</strong></span></li>
<li><span style="color: #339966;"><strong>Objective &#8211; C 汇编</strong></span></li>
<li><span style="color: #339966;"><strong>Obj-C 消息发给了谁</strong></span></li>
<li><span style="color: #339966;"><strong>你现在可以进行逆向工程了</strong></span></li>
<li><span style="color: #339966;"><strong>何去何从</strong></span></li>
</ul>


<div style="text-align: left;">
  <span style="color: #808080;">本文由<span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-19</time></span>
</div>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-06-17T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jun 17<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/qi-ta/'>其它</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/06/17/89/" itemprop="url">父爱天天有</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>2013年6月16日是父亲节，祝愿天下的父亲们都身体都健康！</p>

<p><strong><span style="color: #339966;">注1</span></strong>：首先感谢<span style="text-decoration: underline;"><a href="http://www.weibo.com/lancy1014" target="_blank"><span style="color: #339966; text-decoration: underline;">@晨钰Lancy</span></a></span>对我昨天文章<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a title="固定链接到 iOS7新特征汇总[05]初窥UIKit动力(UIKit Dynamics)" href="http://beyondvincent.com/2013/06/16/ios7%e6%96%b0%e7%89%b9%e5%be%81%e6%b1%87%e6%80%bb05%e5%88%9d%e7%aa%a5uikit%e5%8a%a8%e5%8a%9buikit-dynamics/" rel="bookmark"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总[05]初窥UIKit动力(UIKit Dynamics)</span></a></span></span>中的一个错误进行提醒：UIKit Dynamics中UIGravityBehavior的重力单位应该是UIKit Gravity。我已经对博文和相关代码进行了修改。另外，由于笔者才学疏浅，如果大家在看我博文的时候遇到不对的地方，请狠批我，我已经做好准备迎接大家手里的板砖、鸡蛋和手机啦。</p>

<p><strong><span style="color: #339966;">注2</span></strong>：最近几天连续的学习iOS7新东西（白天上班，晚上基本都是在看WWDC和iOS7相关的内容），一者会有点累，再者感觉对新知识点消化吸收效率不是太高，在写博文的时候，会容易出错，误导大家——为了身体能够健康的生产（身体是父母给的，至少要让父母少担心），文章能够准确的输出，在后面的文章中，不能确保一天出一篇，在时间和精力允许的情况下，我尽量！另外，大家也可以跟我反馈感兴趣的topic，我会优先考虑。</p>

<p><strong><span style="color: #339966;">注3</span></strong>：今天不会有新的技术与大家分享！大家如果对我的博文感兴趣，可以收藏我的博客站点：<span style="text-decoration: underline;"><a href="http://BeyondVincent.com" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://BeyondVincent.com">http://BeyondVincent.com</a></span></a></span>。也可以关注我的微博：<span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.weibo.com/beyondvincent" target="_blank"><span style="color: #339966; text-decoration: underline;">@BeyondVincent</span></a></span></span>。</p>

<h2><span style="color: #339966;">今天的正文</span></h2>

<p>2013年6月16日是父亲节。好久没有跟父亲联络了，还记得上一次联络是2周前父亲跟我打电话，我与父亲联络比较少，基本都是跟母亲联络。</p>

<p>还记得，刚毕业那会，从云南去北方(大连)工作的时候，父亲经常跟我说有空要去大连游玩一下，结果直到离开大连的时候，也没有完成父亲的这个小心愿，后来，在北京呆了一段时间，也希望有时间带上父亲，去首都转转，结果还是没能如愿。再后来，父亲没有再提游玩的事情。现如今，我人已回云南，想想父亲辛劳了好多年，自己却很难孝敬，心里时常会感觉内疚。现在唯一能孝敬父亲，并让父亲安心的就是做到让自己身体健康。也希望，尽快完成父亲的小心愿。</p>

<p>与父亲一起合影的次数并不太多，而单独与父亲合影，只有下面这张！</p>

<h1><span style="color: #339966;">在这里祝愿我的父亲身体健康！</span></h1>

<h1><span style="color: #339966;">也祝愿天下所有人的父亲身体健康！</span></h1>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/%E7%88%B6%E5%AD%90.jpg"><img class="alignnone size-full wp-image-1389" alt="父子" src="http://beyondvincent.com/wp-content/uploads/2013/06/父子.jpg" width="670" height="502" /></a></p>

<div>
  本文由<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-17</time>
</div>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-06-16T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jun 16<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>, <a class='category' href='/blog/categories/ios7xin-te-zheng/'>iOS7新特征</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/06/16/88/" itemprop="url">iOS7新特征汇总[05]初窥UIKit动力(UIKit Dynamics)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>提醒：这里是新特征汇总博文链接：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://beyondvincent.com/2013/06/11/ios7%E6%96%B0%E7%89%B9%E5%BE%81%E6%B1%87%E6%80%BB/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总</span></a></strong></span></span></p>

<div id="attachment_1359" class="wp-caption alignnone" style="width: 1141px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130615-6.png"><img class="size-full wp-image-1359" alt="QQ20130615-6" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130615-6.png" width="1131" height="564" /></a><p class="wp-caption-text">
    此图来此WWDC视频
  </p>
</div>


<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>通过之前的4篇文章，笔者把iOS7中的涉及到的一些新特征做了一个简单的介绍。本文将带领大家初窥新特征里面的一个topic：UIKit动力(<span style="color: #339966;">UIKit Dynamics</span>)。</p>

<p><strong><span style="color: #339966;">注1</span></strong>：关于UIKit Dynamics的中文名称：我在这里叫做UIKit动力，也有人叫UIKit动力模型和UIKit动态，总感觉怪怪的——所以大家在看到的时候不要在意即可。<br/>
<strong><span style="color: #339966;">注2</span></strong>：今天有开发者提起iOS7 beta还处于苹果的<span style="color: #339966;">NDA</span>(Non-Disclosure Agreement)状态，也就是说目前关于iOS7 beta的任何内容除了官方公开发表的信息外，作为开发者最多只能在苹果的开发者论坛上进行讨论交流，禁止在公开场合谈论关于iOS7 beta的信息。关于NDA感觉国外的意识比较好，就跟版权意识一样。由此笔者也在这里友情提醒一下：读者单纯的看本系列文章即可，在iOS7 release之前，<span style="color: #339966;">保持沉默状态</span>。<br/>
<strong><span style="color: #339966;">注3</span></strong>：本文在写作的时候参考了如下一些内容(具体内容请登录苹果开发者网站查阅)：</p>

<ol>
<li>WWDC 2013 session 206 — Getting Started with UIKit Dynamics</li>
<li>UIDynamicAnimator Class Reference</li>
<li>UIDynamicAnimatorDelegate Protocol Reference</li>
<li>UIDynamicBehavior Class Reference</li>
<li>UIDynamicItem Protocol Reference</li>
<li>UIDynamicItemBehavior Class Reference</li>
<li>UIKit Dynamics Catalog(Sample Code)</li>
</ol>


<h2><strong><span style="color: #339966;">UIKit动力简介</span></strong></h2>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130615-5.png"><img alt="QQ20130615-5" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130615-5.png" width="1101" height="338" /></a></p>

<p><img class=" wp-image-1360 alignright" alt="code" src="http://beyondvincent.com/wp-content/uploads/2013/06/code.png" width="115" height="115" /></p>

<p>什么是UIKit动力？—— 一句话：<span style="color: #339966;">UIKit动力提供了一个模拟真实世界中力学相关的动画和交互系统</span>。比如重力、碰撞和吸附等。UIKit动力具有可组合、可重用和声明式的特点。</p>

<p>在程序中利用UIKit提供的接口来实现力学行为，可以减少80%的代码量。</p>

<p>&nbsp;</p>

<h2><span style="color: #339966;"><strong>UIKit动力架构</strong></span></h2>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130616-8.png"><img class="alignnone size-full wp-image-1363" alt="QQ20130616-8" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130616-8.png" width="1031" height="459" /></a></p>

<p>如上图所示，UIKit动力系统中，涉及到如下4个内容：<span style="color: #339966;"><br /> </span></p>

<div title="Page 49">
  <img class=" wp-image-1365 alignright" alt="QQ20130616-9" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130616-9.png" width="240" height="165" /><span style="color: #339966;">UIDynamicAnimator：<span style="color: #333333;">UIDynamicAnimator介于iOS图形引擎和动力项(View)之间，</span></span><span style="color: #339966;"><span style="color: #333333;">具有如下功效</span>：<br /> </span></p> <ul>
    <li>
      提供动力行为的上下文
    </li>
    <li>
      根据ref view确定坐标系
    </li>
    <li>
      控制动力引擎
    </li>
    <li>
      维护着动力行为的状态
    </li>
  </ul>
  
  <p>
    UIDynamicAnimatorDelegate是与UIDynamicAnimator相关的一个delegate。主要用于动力行为被启动或者暂定时，做出的回应。也就是说，在动力行为运行期间，有两个事件（启动和暂定）可供我们使用。
  </p>
</div>


<p><span style="color: #339966;"><a href="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130616-10.png"><img class=" wp-image-1372 alignright" alt="QQ20130616-10" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130616-10.png" width="247" height="211" /></a>UIDynamicBehavior：<span style="color: #333333;">主要用来描述动力的行为。在iOS7中，默认提供了如下动力行为：</span></span></p>

<ul>
<li>UIAttachmentBehavior</li>
<li>UICollisionBehavior</li>
<li>UIDynamicItemBehavior</li>
<li>UIGravityBehavior</li>
<li>UIPushBehavior</li>
<li>UISnapBehavior objects</li>
</ul>


<p>动力行为可以在任意时间内进行添加或移除。另外动力行为可以是组合的，也可以被继承。</p>

<p>注意：这些动力行为是在二维空间进行的。</p>

<p><span style="color: #339966;">Reference View</span>：该用是用来初始化Animator用的，它的作用是给动力行为提供坐标系。</p>

<p><span style="color: #339966;">View</span>：在UIKit动力中，又称为动力项(dynamic item)。动力项是遵循UIDynamicItem协议的任意对象（可以是SDK中默认提供的，或者开发者自定义的）。在iOS7 beta中，View已经遵循了该协议，所以一般也会将View当做动力项——动力行为实际针对的对象。</p>

<h2><span style="color: #339966;"><strong>代码示例</strong></span></h2>

<p>下面笔者就通过一个例子，演示如何对一个view施加重力行为(UIGravityBehavior)。</p>

<p>上面介绍了一大堆，实际使用过程可能没那么复杂，不过原理才是最重要的。</p>

<p>新建一个Single View Application模板工程：BVGravityBehavior，在工程中，有如下属性：</p>

<pre class="wp-code-highlight prettyprint linenums:1">@property (nonatomic, weak) IBOutlet UIImageView *square1;
@property (nonatomic) UIDynamicAnimator* animator;</pre>


<p>另外还有两个方法：</p>

<pre class="wp-code-highlight prettyprint linenums:1">// 开始重力行为
- (IBAction)startGravity:(id)sender
{
    self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
    UIGravityBehavior* gravityBeahvior = [[UIGravityBehavior alloc] initWithItems:@[self.square1]];
    [self.animator addBehavior:gravityBeahvior];
}</pre>




<pre class="wp-code-highlight prettyprint linenums:1">// 停止重力行为
- (IBAction)stopGravity:(id)sender
{
    [self.animator removeAllBehaviors];
}</pre>


<p>运行程序，效果如下（如图没看到gif动画效果，点击下图，在新窗口中可以看到效果）：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/1.gif" target="_blank"><img class="alignnone size-full wp-image-1383" alt="1" src="http://beyondvincent.com/wp-content/uploads/2013/06/1.gif" width="570" height="700" /></a></p>

<p>&nbsp;</p>

<p>也可以停止当前的动力行为：在重力行为运行过程中，如果点击停止，就可以停止重力行为，view的状态为停止前的状态。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/2.gif" target="_blank"><img class="alignnone size-full wp-image-1384" alt="2" src="http://beyondvincent.com/wp-content/uploads/2013/06/2.gif" width="572" height="706" /></a></p>

<p>&nbsp;</p>

<h2><strong><span style="color: #339966;">代码下载</span></strong></h2>

<p><a href="https://github.com/BeyondVincent/iOS7-new-feature/tree/master/code/UIDynamic/BVGravityBehavior" target="_blank"><img class="alignnone size-full wp-image-561" alt="代码下载" src="http://beyondvincent.com/wp-content/uploads/2013/05/5555.png" width="150" height="150" /></a></p>

<p>&nbsp;</p>

<h2><span style="color: #339966;">小结</span></h2>

<p>本文对UIKit动力做了一个入门级别的介绍，并给出了一个小示例，演示了如何给view添加一个重力行为。在下一篇文章中，笔者将继续介绍UIKit动力。</p>

<p>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_</p>

<h2><span style="color: #339966;"><strong>强烈推荐</strong></span></h2>

<p>来自唐巧的一个微信公众账号：<span style="color: #339966;">iosDevTips</span>——基本每天都会有关于iOS开发的精彩内容分享。<br/>
来自唐巧的一个Google Group讨论组：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://groups.google.com/forum/#!forum/iosdevtips" target="_blank"><span style="color: #339966; text-decoration: underline;">iosDevTips</span></a></span></span></p>

<h2><span style="color: #339966;"><strong>新特征汇总更新通知方式</strong></span></h2>

<p>有新的内容我会通过下面的方式进行通知，欢迎关注：<br/>
新浪微博：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://www.weibo.com/beyondvincent" target="_blank"><span style="color: #339966; text-decoration: underline;">beyondvincent</span></a></strong></span></span><br/>
腾讯微博：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://t.qq.com/beyondvincent" target="_blank"><span style="color: #339966; text-decoration: underline;">beyondvincent</span></a></strong></span></span><br/>
微信公众账号：<strong>破船之家</strong><br/>
<a href="http://beyondvincent.com/wp-content/uploads/2013/03/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7-%E7%A0%B4%E8%88%B9%E4%B9%8B%E5%AE%B6.jpg"><img alt="微信公众账号-破船之家" src="http://beyondvincent.com/wp-content/uploads/2013/03/微信公众账号-破船之家-150x150.jpg" width="150" height="150" /></a></p>

<div>
</div>




<div>
  本文由<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-15</time>
</div>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-06-14T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jun 14<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>, <a class='category' href='/blog/categories/ios7xin-te-zheng/'>iOS7新特征</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/06/14/87/" itemprop="url">iOS7新特征汇总[04]新特征介绍4</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>提醒：这里是新特征汇总博文链接：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://beyondvincent.com/2013/06/11/ios7%E6%96%B0%E7%89%B9%E5%BE%81%E6%B1%87%E6%80%BB/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总</span></a></strong></span></span></p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/ios-7-logo.png"><img class="alignnone size-full wp-image-1345" alt="ios-7-logo" src="http://beyondvincent.com/wp-content/uploads/2013/06/ios-7-logo.png" width="1018" height="483" /></a></p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>上一篇文章（<a href="http://beyondvincent.com/?p=1321" target="_blank"><strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总[03]新特征介绍3</span></span></span></strong></a>）中，笔者介绍了在iOS7中关于程序间的音频（inter-App Audio）、点对点的连接、新增的Framework相关内容。本文将继续介绍iOS7中的新特征，包括：已有Framework的改进、Objective-C和已经过时的API。</p>

<p><strong><span style="color: #339966;">注1：本文是关于新特征介绍的最后一篇，随后的博文，以wwdc2013内容为主，欢迎大家关注！</span></strong></p>

<h2><strong><span style="color: #339966;">已有Framework的改进（19个）</span></strong></h2>

<p>下面我们来看看iOS7中有明显修改的一些framework。如果要查看完整的新接口，请查看iOS 7.0 API Diffs。本部分内容看起来可能稍显枯燥，并且我没有对其做配图，所以读者可以挑选自己感兴趣的部分进行阅读也不妨。</p>

<div title="Page 16">
  <ul>
    <li>
      <strong><span style="color: #339966;">UIKit</span> <span style="color: #339966;">Framework</span></strong>
    </li>
  </ul>
  
  <p>
    UIKit Framework(UIKit.framework)主要做了如下改进：<br /> 1、所有的用户界面控件都做了更新，以与iOS7相适应。<br /> 2、UIKit动力可以让开发者模拟现实世界中的一些效果，例如在动画中使用重力行为。<br /> 3、Text Kit提供了复杂的文字编辑和显示功能。<br /> 4、UIView类新增加了如下内容：<br /> tintColor属性：可以使用一个tint color，并对view和它的subview有影响。关于如何使用tint colors，请看iOS 7 UI Transition Guide。
  </p>
  
  <pre class="wp-code-highlight prettyprint linenums:1">/*
-tintColor always returns a color. The color returned is the first non-default value in the receiver&#039;s superview chain (starting with itself).
If no non-default value is found, a system-defined color is returned.
If this view&#039;s -tintAdjustmentMode returns Dimmed, then the color that is returned for -tintColor will automatically be dimmed.
If your view subclass uses tintColor in its rendering, override -tintColorDidChange in order to refresh the rendering if the color changes.
*/
@property(nonatomic,retain) UIColor *tintColor NS_AVAILABLE_IOS(7_0);

/*</pre>
  
  <p>
    通过view可以创建基于关键帧的动画。同样也可以对view做出改变——特别是阻止任意正在执行的动画。<br /> 5、UIViewController类新增了如下内容：<br /> View controller之间的切换(transition)可以自定义、驱动式交互(driven interactively)，或者完全根据自己指定的切换方式来替换。<br /> 可以通过编程的方式指定View controller的status bar和visibility。系统会根据提供的信息来管理status bar style。当然，在程序的info.plist文件中，设置UIViewControllerBasedStatusBarAppearance键值也是可以的。如下代码是iOS7中新增的几个用来指定status bar的方法
  </p>
  
  <pre class="wp-code-highlight prettyprint linenums:1">// These methods control the attributes of the status bar when this view controller is shown. They can be overridden in view controller subclasses to return the desired status bar attributes.
- (UIStatusBarStyle)preferredStatusBarStyle;
- (BOOL)prefersStatusBarHidden;

// This should be called whenever the return values for the view controller&#039;s status bar attributes have changed. If it is called from within an animation block, the changes will be animated along with the rest of the animation block.
- (void)setNeedsStatusBarAppearanceUpdate;</pre>
  
  <p>
    6、UIMotionEffect类为运动效果定义了一些基本的行为——定义了一个view如何响应基于设备的运动。<br /> 7、Collection view支持UIKit动力(UIKit Dynamic)——这样可以将一些行为对象(behavior object)应用到Collection view的layout attribute中，以对collection view中的item做出相应的动画。<br /> 8、UIImage的ImageNamed:方法可以把检索存储在asset目录中的图片，这就提供了一种方法——管理并优化具有多种尺寸和分辨率的资源。<br /> 9、UIView和UIScreen提供了一个新的方法：snapshot——返回一个view，可以用来显示程序的内容。
  </p>
  
  <pre class="wp-code-highlight prettyprint linenums:1">/* Creating snapshots from existing snapshots (as a method to duplicate, crop or create a resizable variant) is supported. In cases where many snapshots are needed, creating a snapshot from a common superview and making subsequent snapshots from it can be more performant.
*/
@interface UIView (UISnapshotting)
- (UIView *)snapshot NS_AVAILABLE_IOS(7_0);
- (UIView *)resizableSnapshotFromRect:(CGRect)rect withCapInsets:(UIEdgeInsets)capInsets NS_AVAILABLE_IOS(7_0); // Resizable snapshots will default to stretching the center
@end</pre>
  
  <pre class="wp-code-highlight prettyprint linenums:1">@interface UIScreen (UISnapshotting)
- (UIView *)snapshot NS_AVAILABLE_IOS(7_0);
@end</pre>
  
  <p>
    10、UIKeyCommand类封装了从外围硬件键盘接收到的键盘事件。这些事件会被分发(delivered)到程序的响应链(responder chain)中以被处理。<br /> 11、UIFontDescriptor对象使用一个属性字典来描述字体。通过font descriptor可以与其它平台相互交互。<br /> 12、UIFont和UIFontDescriptor类支持动态调整字体大小，这样可以增加程序中文字的易读性——用户可以控制所有程序的字体大小。<br /> 13、UIActivity类现在支持新的一些activity类型，包括通过AirDrop发送数据，给内容到Safari阅读列表中，把数据发送到Flickr、Tencent Weibo和Vimeo。<br /> 14、UIApplicationDelegate协议新增了处理后台获取数据的操作。
  </p>
  
  <pre class="wp-code-highlight prettyprint linenums:1">/*! This delegate method offers an opportunity for applications with the "remote-notification" background mode to fetch appropriate new data in response to an incoming remote notification. You should call the fetchCompletionHandler as soon as you&#039;re finished performing that operation, so the system can accurately estimate its power and data cost.

This method will be invoked even if the application was launched or resumed because of the remote notification. The respective delegate methods will be invoked first. Note that this behavior is in contrast to application:didReceiveRemoteNotification:, which is not called in those cases, and which will not be invoked if this method is implemented. !*/
- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler NS_AVAILABLE_IOS(7_0);

/// Applications with the "fetch" background mode may be given opportunities to fetch updated content in the background or when it is convenient for the system. This method will be called in these situations. You should call the fetchCompletionHandler as soon as you&#039;re finished performing that operation, so the system can accurately estimate its power and data cost.
- (void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler NS_AVAILABLE_IOS(7_0);

// Applications using an NSURLSession with a background configuration may be launched or resumed in the background in order to handle the
// completion of tasks in that session, or to handle authentication. This method will be called with the identifier of the session needing
// attention. Once a session has been created from a configuration object with that identifier, the session&#039;s delegate will begin receiving
// callbacks. If such a session has already been created (if the app is being resumed, for instance), then the delegate will start receiving
// callbacks without any action by the application. You should call the completionHandler as soon as you&#039;re finished handling the callbacks.
- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler NS_AVAILABLE_IOS(7_0);</pre>
  
  <p>
    15、UIKit新增了引导访问模式(guided-access mode)——运行程序自己锁定，以防止被用户修改。这样的功能主要是为一些机构设计的，例如在学校——学生虽然携带了他们的设备，但是需要运行由学校提供的程序。<br /> 16、State还原功能运行保存和还原任意的对象。遵循UIStateRestoring协议的对象，当程序被切换到后台(background)时，可以把状态信息保存起来 ，之后程序被启动时，这些状态可以被还原。<br /> 17、Table view支持对row或其他元素高度的评估(estimating)，这样可以提升Table view的滚动性能。<br /> 更多关于UIKit framework的内容，请阅读UIKit Framework Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Store Kit Framework</span></strong>
    </li>
  </ul>
  
  <p>
    Store Kit framework(StoreKit.framework)已经迁移到新的订单系统(receipt system)，这样一来，开发者可以在自己的设备上验证内购(in-app purchase)。同样也可以在服务器上进行程序购买订单的验证。<br /> 更多关于新订单系统的使用，请阅读：Receipt Validation Programming Guide。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Security Framework</span></strong>
    </li>
  </ul>
  
  <p>
    Security Framework(Security.framework)现在支持：通过iCloud，可以把密码在用户两台设备间进行同步。通过新的keychain属性((kSecAttrSyncronizable)，程序可以为iCloud标记它们的keychain item。<br /> 更多相关这个属性的内容，请看该framework的头文件。关于keychain更多信息，请看Keychain Services Programming Guide。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Pass Kit Framework</span></strong>
    </li>
  </ul>
  
  <p>
    Pass Kit Framework(PassKit.ramework)新增了一些API——针对同时添加多个通行证(pass)，通行证文件的格式也做了相应的调整：
  </p>
  
  <ol>
    <li>
      新的key指定通行证的截止日期
    </li>
    <li>
      可以指定通行证只与特定的蓝牙信号相关
    </li>
    <li>
      利用新的属性来控制通行证的显示。可以把通行证进行归类，并在通行证的背面显示自定义的文字内容，以及控制显示在通行证上的时间值
    </li>
    <li>
      可以给通行证附带一些额外的数据信息，在程序中可以使用这些数据，不过并直接显示给用户
    </li>
    <li>
      可以指定那些data detector用于通行证的字段中
    </li>
  </ol>
  
  <p>
    更多关于如何在程序中使用Pass Kit的信息，请阅读Passbook Programming Guide。关于通行证文件的格式，请阅读Passbook Package Format Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">OpenGL ES</span></strong>
    </li>
  </ul>
  
  <p>
    OpenGL ES做了如下新的扩展：
  </p>
  
  <ol>
    <li>
      <span style="color: #339966;">EXT_SRGB</span>支持sRBG帧缓冲区(framebuffer)操作
    </li>
    <li>
      <span style="color: #339966;">GL_APPLE_pvrtc_sRGB</span>支持将sRGB纹理数据压缩为PVRTC纹理格式
    </li>
    <li>
      <span style="color: #339966;">GL_APPLE_draw_instanced</span>和<span style="color: #339966;">GL_APPLE_draw_arrays</span>可以提升渲染的速度->当程序在绘制多个相同的实例对象时。
    </li>
  </ol>
  
  <p>
    现在可以在vertex shaders中访问纹理了；通过MAX_VERTEX_TEXTURE_IMAGE_UNITS属性决定你可以访问纹理的准确数目。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">MessageUI Framework</span></strong>
    </li>
  </ul>
  
  <p>
    在MessageUI framework中，<span style="color: #339966;">MFMessageComposeViewController</span>现在可以支持将附件添加到信息中。关于新接口内容，可以参看framework头文件。
  </p>
  
  <p>
    关于这个framework的类，请阅读Message UI Framework Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Media Player Framework</span></strong>
    </li>
  </ul>
  
  <p>
    在Media Player framework中，<span style="color: #339966;">MPVolumeView</span>类可以判断用户选择的无线路由(wireless route，例如AirPlay和Bluetooth)是否可用。你也可以判断无线路由当前是否可用。关于新接口信息，请参看framework的头文件。关于Media Player framework涉及到的类，请参看Media Player Framework Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Map Kit Framework</span></strong>
    </li>
  </ul>
  
  <p>
    关于Map Kit framework相关修改，笔者已经在这里介绍过：<span style="text-decoration: underline;"><span style="color: #339966;"><a title="固定链接到 iOS7新特征汇总[02]新特征介绍2" href="http://beyondvincent.com/2013/06/12/ios7%e6%96%b0%e7%89%b9%e5%be%81%e6%b1%87%e6%80%bb02%e6%96%b0%e7%89%b9%e5%be%81%e4%bb%8b%e7%bb%8d2/" target="_blank" rel="bookmark"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总[02]新特征介绍2</span></a></span></span>
  </p>
  
  <p>
    更多相关信息，请查阅Map Kit Framework Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Image I/O Framework</span></strong>
    </li>
  </ul>
  
  <p>
    Image I/O Framework(ImageIO.framework)现在提供了获取和设置image metadata的接口。
  </p>
  
  <p>
    更多相关接口信息，请看framework的头文件。关于framework类的介绍，请看Image I/O Reference Collection。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">iAd Framework</span></strong>
    </li>
  </ul>
  
  <p>
    iAd framework(iAd.framework)做了如下修改——让广告更好的融入到程序中：
  </p>
  
  <ol>
    <li>
      在<span style="color: #339966;">MPMoviePlayerController</span>类中的新方法可以让你在播放电影之前运行广告
    </li>
    <li>
      framework对<span style="color: #339966;">UIViewController</span>进行了扩展，让其更容易创建广告内容。现在，你可以对view controller进行适当的配置——在实际内容显示之前先显示出广告内容。
    </li>
  </ol>
  
  <p>
    关于新接口请看framework中的头文件。关于framework的介绍，请看Ad Support Framework Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Game Kit Framework</span></strong>
    </li>
  </ul>
  
  <p>
    关于Game Kit Framework(GameKit.framework)的改变，已经在这里介绍过：<span style="text-decoration: underline;"><span style="color: #339966;"><a title="固定链接到 iOS7新特征汇总[02]新特征介绍2" href="http://beyondvincent.com/2013/06/12/ios7%e6%96%b0%e7%89%b9%e5%be%81%e6%b1%87%e6%80%bb02%e6%96%b0%e7%89%b9%e5%be%81%e4%bb%8b%e7%bb%8d2/" target="_blank" rel="bookmark"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总[02]新特征介绍2</span></a></span></span>
  </p>
  
  <p>
    更多相关介绍，请看Game Kit Framework Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Foundation Framework</span></strong>
    </li>
  </ul>
  
  <p>
    Foundation framework(Foundation.framework)主要做了如下改进：
  </p>
  
  <ol>
    <li>
      <span style="color: #339966;">NSURLSession</span>类是一个新增的类，主要用于程序在后台运行时，对网络资源的操作。这个类替换了NSURLConnection和相关delegate；同样也替换了NSURLDownload和相关delegate。
    </li>
    <li>
      <span style="color: #339966;">NSURLComponents</span>类也是一个新增类——用来解析URL的构建。这个类在解析URL的时候支持URI标准(rfc3986/STD66)。
    </li>
    <li>
      <span style="color: #339966;">NSNetService</span>和<span style="color: #339966;">NSNetServiceBrowser</span>用于在蓝牙和Wi-Fi中点对点的查找。
    </li>
    <li>
      <span style="color: #339966;">NSURLCredential</span>和<span style="color: #339966;">NSURLCredentialStorage</span>两个类可以用来创建同步策略的证书，并可以从iCloud中移除相关同步策略证书。
    </li>
    <li>
      <span style="color: #339966;">NSURLCache</span>、<span style="color: #339966;">NSURLCredentialStorage</span>和<span style="color: #339966;">NSHTTPCookieStorage</span>三个类支持存储请求的异步处理。
    </li>
    <li>
      <span style="color: #339966;">NSCalendar</span>类支持新的日历类型。
    </li>
  </ol>
  
  <p>
    更多关于新的接口，请看framework中 大头文件和Foundation release notes。关于该framework类的介绍，请看Foundation Framework Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Core Telephony Framework</span></strong>
    </li>
  </ul>
  
  <p>
    Core Telephony framework(CoreTelephony.framework)现在可以获取到设备使用的无线电信息：当前的信号强度、cell ID。由运营商开发的相关程序，同样可以通过预定运营商相关服务，来对他们的程序进行验证。
  </p>
  
  <p>
    更多相关信息请看Core Telephony Framework Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Core Motion Framework</span></strong>
    </li>
  </ul>
  
  <p>
    Core Motion framework(CoreMotion.framework)现在支持step counting(类似计步器)和运动的跟踪。关于step counting——framework通过检测用户的运动，然后根据运动信息计算出步数（貌似很牛叉的样子，不知道准确度如何了）。由于运动信息是由系统检测的，所以即使当程序没有运行的时候，系统也可以持续的收集step数据。通过这样的功能，framework也能区分出不同的运动类型，例如walking、running或者automobile——这对于导航类程序来说，就可以使用这些数据，直接修改用户的运动类型。
  </p>
  
  <p>
    更多相关信息，请看Core Motion Framework Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Core Location Framework</span></strong>
    </li>
  </ul>
  
  <p>
    Core Location framework(CoreLocation.framework)可以通过蓝牙设备来测距。通过测距可以确定附近蓝牙设备的范围，并作出相应的反应。例如，在博物馆的画廊里面，可能有一些蓝牙信号，供参观者通过相关程序显示出画廊的入口和出口。framework还支持推迟位置的更新的通知，直到特定的时间或者用户移动距离超过了最小值。
  </p>
  
  <p>
    更多相关信息，请看Core Location Framework Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Core Foundation Framework</span></strong>
    </li>
  </ul>
  
  <p>
    Core Foundation framework(CoreFoundation.framework)现在支持在派送队列(dispatch queues)中进行流对象的调度。
  </p>
  
  <p>
    更多相关信息，请看Core Foundation Framework Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">Core Bluetooth Framework</span></strong>
    </li>
  </ul>
  
  <p>
    Core Bluetooth framework(CoreBluetooth.framework)做了如下改进：
  </p>
  
  <ol>
    <li>
      <span style="line-height: 13px;">该framework现在可以把<span style="color: #339966;">CBCentral</span>和<span style="color: #339966;">CBPeripheral</span>对象的状态信息进行保存，并且在程序启动的时候还原——这个功能可以支持相关蓝牙设备的长期行为。</span>
    </li>
    <li>
      CBCentral和CBPeripheral类现在使用NSUUID对象来存储唯一标示。
    </li>
    <li>
      现在可以从<span style="color: #339966;">CBCentralManager</span>中同步的获取一个CBPeripheral对象。
    </li>
  </ol>
  
  <p>
    更多相关信息，请看Core Bluetooth Framework Reference。
  </p>
  
  <ul>
    <li>
      <strong><span style="color: #339966;">AV Foundation Framework</span></strong>
    </li>
  </ul>
  
  <p>
    AV Foundation framework(AVFoundation.framework)做了如下改进：
  </p>
  
  <ul>
    <li>
      <span style="color: #339966;">AVAudioSession</span>支持一些新的行为：可以选择音频输入的首选项，包括来自内置麦克风的音频；支持多通道的输入和输出
    </li>
  </ul>
</div>




<div title="Page 16">
  <ul>
    <li>
      <span style="line-height: 13px;"><span style="color: #339966;">AVVideoCompositing</span>和相关的类支持自定义视频合成器(video compositor)</span>
    </li>
    <li>
      <span style="color: #339966;">AVSpeechSynthesizer</span>和相关的类提供了语音合成功能
    </li>
    <li>
      <span style="color: #339966;">capture</span>类新增支持的功能有：查找camaera支持的格式、支持60fps录制、在录制和预览的时候，Video的放大(真实和数字化)、实时查找机器可读的条形码数据、自动对焦范围的限制、采集录制过程中访问时钟。
    </li>
  </ul>
  
  <p>
    另外还有很多信息，笔者就不在这里一一列出，读者可以查阅AV Foundation Framework Reference。
  </p>
</div>




<div title="Page 16">
  <ul>
    <li>
      <strong><span style="color: #339966;">Accelerate Framework</span></strong>
    </li>
  </ul>
  
  <p>
    Accelerate framework(Accelerate.framework)做了如下改进：
  </p>
  
  <ol>
    <li>
      支持Core Graphics数据类型的操作
    </li>
    <li>
      支持灰度图片：每个像素为1、2或4位
    </li>
    <li>
      可以在不同图像格式之间进行转换
    </li>
    <li>
      支持biguad(IIR)操作
    </li>
  </ol>
  
  <p>
    更多相关信息请看Accelerate Framework Reference。
  </p>
  
  <div title="Page 17">
    <div title="Page 18">
      <div title="Page 18">
        <div title="Page 18">
          <h2 title="Page 19">
            <span style="color: #339966;"><b>Objective-C</b></span>
          </h2>
          
          <p>
            Objective-C加强了对模块(module)的支持，这样可以加快build时间，以及工程索引的时间。用Xcode 5创建的新工程，默认支持模块，如果是之前的一个工程，必须明确的启动模块的支持：通过修改该工程的Enable Modules设置。
          </p>
          
          <div title="Page 18">
            <div>
              <div>
                <p>
                  <strong style="font-size: 1.5em;"><span style="color: #339966;">已经过时的API</span></strong>
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>


<p>时不时的，苹果会对一些API增加deprecation 宏，表示在开发中，相关的API不应该继续被使用了。当然，遇到deprecation时，相关api并不是立即就过时了，相反，在一定期限内，苹果会提供相关功能的api，进行过渡。</p>

<p>作为开发者来说，尽量避免在代码中使用过时的api是非常重要的——至少，在新写的代码中不要继续使用过时的api了，另外，对于已有的工程中，如果使用了过时的api，也尽量对代码进行更新。</p>

<p>目前，在iOS7中，过时的api有如下一些：</p>

<ol>
<li>Map Kit framework中的<span style="color: #339966;">MKOverlayView</span>和它相关的子类都已经过时了。并且使用<span style="color: #339966;">MKOverlayRenderer</span>类来代替。更多相关资料，请看Map Kit Framework Reference。</li>
<li>在Audio Toolbox framework中的<span style="color: #339966;">AudioSession</span> API已经过时了。程序中应该使用AV Foundation framework中的<span style="color: #339966;">AVAudioSession</span>类来代替。</li>
<li>在Core Location framework中的<span style="color: #339966;">CLRegion</span>类已经被<span style="color: #339966;">CLCircularRegion</span>类取代了。只不过CLRegion类还继续存在着——当做一个抽象的基类——以对geographic和beacon region的支持。</li>
<li><span style="color: #339966;">CBCentral</span>中的属性<span style="color: #339966;">UUID</span>已经过时了。现在使用<span style="color: #339966;">identifier</span>属性来对central对象进行唯一标示。</li>
<li>Game Kit framework中也有一些过时的api，主要是为了新功能提供更好的支持。相关信息请看上面提到的参考资料。</li>
<li>UIKit中有如下一些过时的内容：<span style="color: #339966;">UIViewController</span>的<span style="color: #339966;">wantsFullScreenLayout</span>属性已经过时。在iOS7以及之后的版本中，view controller一直都是全屏布局；<span style="color: #339966;">UIPopovercontroller</span>类不再支持箭头朝向的概念；现在支持内容呈现（presentation）朝向。<span style="color: #339966;">UIColor</span>对象提供的背景纹理已经不存在了。NSString中的许多功能已经过时，建议使用新的功能。</li>
<li>在<span style="color: #339966;">libsyscall</span>库中的<span style="color: #339966;">gethostuuid</span>方法已经过时。</li>
<li>iOS7以及之后的版本中，如果请求获取iOS设备的MAC地址，系统会返回02:00:00:00:00:00。如果需要唯一标示设备，使用UIDevice的identifierForVendor属性代替。（在程序中，如果需要自己的广告标示符，那么应该考虑使用ASIdentifierManager的advertisingIdentifier属性替代。）</li>
</ol>


<p>关于过时API完整的列表，请看iOS 7.0 API Diffs。</p>

<p>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_</p>

<h2><span style="color: #339966;"><strong>强烈推荐</strong></span></h2>

<p>来自唐巧的一个微信公众账号：<span style="color: #339966;">iosDevTips</span>——基本每天都会有关于iOS开发的精彩内容分享。<br/>
来自唐巧的一个Google Group讨论组：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://groups.google.com/forum/#!forum/iosdevtips" target="_blank"><span style="color: #339966; text-decoration: underline;">iosDevTips</span></a></span></span></p>

<h2><span style="color: #339966;"><strong>新特征汇总更新通知方式</strong></span></h2>

<p>有新的内容我会通过下面的方式进行通知，欢迎关注：<br/>
新浪微博：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://www.weibo.com/beyondvincent" target="_blank"><span style="color: #339966; text-decoration: underline;">beyondvincent</span></a></strong></span></span><br/>
腾讯微博：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://t.qq.com/beyondvincent" target="_blank"><span style="color: #339966; text-decoration: underline;">beyondvincent</span></a></strong></span></span><br/>
微信公众账号：<strong>破船之家</strong><br/>
<a href="http://beyondvincent.com/wp-content/uploads/2013/03/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7-%E7%A0%B4%E8%88%B9%E4%B9%8B%E5%AE%B6.jpg"><img alt="微信公众账号-破船之家" src="http://beyondvincent.com/wp-content/uploads/2013/03/微信公众账号-破船之家-150x150.jpg" width="150" height="150" /></a></p>

<div>
</div>




<div>
  本文由<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-14</time>
</div>




		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-06-13T00:00:00+08:00" data-updated="true" itemprop="datePublished">Jun 13<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>, <a class='category' href='/blog/categories/ios7xin-te-zheng/'>iOS7新特征</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/06/13/86/" itemprop="url">iOS7新特征汇总[03]新特征介绍3</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>提醒：这里是新特征汇总博文链接：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://beyondvincent.com/2013/06/11/ios7%E6%96%B0%E7%89%B9%E5%BE%81%E6%B1%87%E6%80%BB/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总</span></a></strong></span></span></p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>上一篇文章（<a href="http://beyondvincent.com/?p=1306" target="_blank"><strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总[02]新特征介绍2</span></span></span></strong></a>）中，笔者介绍了在iOS7中关于游戏、地图和AirDrop相关内容。本文将继续介绍iOS7中的新特征：程序间的音频（inter-App Audio）、点对点的连接、新增的Framework。</p>

<h2><strong><span style="color: #339966;">程序间的音频（inter-App Audio）</span></strong></h2>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/InterAppAudio2013.png"><img class="alignnone size-full wp-image-1325" alt="InterAppAudio2013" src="http://beyondvincent.com/wp-content/uploads/2013/06/InterAppAudio2013.png" width="853" height="480" /></a></p>

<p><span style="color: #339966;">Audio Unit framework (AudioUnit.framework)</span>现在支持程序间的音频了——可以在同一台设备上不同的两个程序之间发送MIDI命令和音频流。例如，通过该功能，你可以使用一个程序来录制音乐，然后将录制的音乐音乐发送到另外一个能对音乐进行处理的程序中。</p>

<p>为了公开（vend）你程序中的音频数据，需要发布一个<span style="color: #339966;">AURemoteIO</span>实例来充当音频组件——对其它进程是可见的。在iOS7里面，要在另外一个程序中使用程序间的音频功能，请使用音频组件发现接口。【翻译自苹果官网中的如下内容，还不是太理解具体意思，如果大家知道的话，可以告诉我，谢谢！】</p>

<blockquote><p><em>To vend your app’s audio data, publish a AURemoteIO instance as an audio component that is visible to other processes. to use audio features from another app, use the audio component discovery interface in iOS 7.</em></p></blockquote>

<p>更多相关内容请看：Audio Toolbox Framework Reference</p>

<h2><strong><span style="color: #339966;">点对点的连接</span></strong></h2>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/apple-wwdc-2013-3a.jpg"><img class="alignnone size-full wp-image-1326" alt="apple-wwdc-2013-3a" src="http://beyondvincent.com/wp-content/uploads/2013/06/apple-wwdc-2013-3a.jpg" width="680" height="400" /></a></p>

<p>通过<span style="color: #339966;">Multipeer Connectivity framework (MultipeerConnectivity.framework)</span>可以查找附近的设备，并直接与这些设备进行通讯——不需要通过互联网。该Framework具有这样的特点：很容易的创建多点（multipeer）会话、支持稳定、可靠和实时的数据传输。可以看出，通过该Framework，你的程序可以与附近的设备进行通讯，并做到数据的无缝交换。</p>

<p>该Framework提供了两种方式来查找并管理网络服务：编程方式和基于UI选项。可以使用<span style="color: #339966;">MCNearbyServiceBrowser</span>类以编程的方式查找并管理设备。另外，我们可以将<span style="color: #339966;">MCPeerPickerViewController</span>集成到程序中——用来显示用户可以选择的设备列表。</p>

<p>更多相关信息，请阅读：Multipeer Connectivity Framework Reference</p>

<h2><strong><span style="color: #339966;">新增的Framework</span></strong></h2>

<p>在iOS7中，新增了如下一些Framework：</p>

<ol>
<li>Game Controller framework(<span style="color: #339966;">GameController.framework</span>)：提供了与游戏相关的硬件通讯接口。</li>
<li>Sprite Kit framework(<span style="color: #339966;">SpriteKit.framework</span>)：提供了基于精灵（sprite-based）的动画和图形渲染。</li>
<li>Multipeer Connectivity framework(<span style="color: #339966;">MultipeerConnectivity.framework</span>)：提供设备间点对点通讯的功能。</li>
<li>JavaScript Core framework (<span style="color: #339966;">JavaScriptCore.framework</span>)：提供了用Objective-C封装的大量标准JavaScript对象。通过该framework可以对JavaScript代码进行评估（evaluate），以及解析JSON。</li>
<li>Media Accessibility framework (<span style="color: #339966;">MediaAccessibility.framework</span>)：管理媒体文件中字幕（closed-caption）内容的显示。通过该Framework与settings的结合，可以让用户开启字幕的显示。</li>
<li>Safari Services framework (<span style="color: #339966;">SafariServices.framework</span>)：通过该framework，可以通过编程的方式将URL添加到用户的Safari阅读列表中。</li>
</ol>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130612-20.png"><img class="alignnone size-full wp-image-1327" alt="QQ20130612-20" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130612-20.png" width="970" height="499" /></a></p>

<p>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_</p>

<h2><span style="color: #339966;"><strong>强烈推荐</strong></span></h2>

<p>来自唐巧的一个微信公众账号：<span style="color: #339966;">iosDevTips</span>——基本每天都会有关于iOS开发的精彩内容分享。<br/>
来自唐巧的一个Google Group讨论组：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://groups.google.com/forum/#!forum/iosdevtips" target="_blank"><span style="color: #339966; text-decoration: underline;">iosDevTips</span></a></span></span></p>

<h2><span style="color: #339966;"><strong>新特征汇总更新通知方式</strong></span></h2>

<p>有新的内容我会通过下面的方式进行通知，欢迎关注：<br/>
新浪微博：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://www.weibo.com/beyondvincent" target="_blank"><span style="color: #339966; text-decoration: underline;">beyondvincent</span></a></strong></span></span><br/>
腾讯微博：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://t.qq.com/beyondvincent" target="_blank"><span style="color: #339966; text-decoration: underline;">beyondvincent</span></a></strong></span></span><br/>
微信公众账号：<strong>破船之家</strong><br/>
<a href="http://beyondvincent.com/wp-content/uploads/2013/03/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7-%E7%A0%B4%E8%88%B9%E4%B9%8B%E5%AE%B6.jpg"><img alt="微信公众账号-破船之家" src="http://beyondvincent.com/wp-content/uploads/2013/03/微信公众账号-破船之家-150x150.jpg" width="150" height="150" /></a></p>

<div>
</div>




<div>
  本文由<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-13</time>
</div>




		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="/blog/page/3/" class="prev">Prev</a>
    
    
        <a href="/blog/page/5/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">所有文章</a></div>
    
    <script type="text/javascript">
var duoshuoQuery = {short_name:"beyondvincent"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
</nav>

</div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2013 - 破船(BeyondVincent) -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'beyondvincent001';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-42893468-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>





<script type="text/javascript">
    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F1a3c98825a726bfbf68a83ba97e0b9be' type='text/javascript'%3E%3C/script%3E"));
    </script>

		</div>
	</div>
</body>
</html>
